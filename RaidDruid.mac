|**	AUTOBOT XP AND RAIDING MACRO v4.29.11
		Last Update 04-11-2020

	Editing for changing group healing using new TLO
	Added PullSpell to guard routine, in the "settings" section. Will take spell, alt, comb, or item to cast. Will get with in 200', then with in line of sight to cast. 

 Full instruction on the MacroQuest2 wiki
 http://www.macroquest2.com/wiki/index.php/AutoBot.mac-V4.28%2B



	New "who has XXXX" command added. Use for checking who, in your listening channel, has XXX item. It will announce in your chat channel the item.
		If it is an augment it will announce what item it is in. Augments need an exact name, not partial name.
		It will announce if the item is a worn item, top inventory, in bags, or a bank item. (Credit = LamaHerder, exspes007)





 Debugging options: To help debug something, you can "/varset Debug true" to turn it on. Warning, there is a LOT of spam
	Debug
	DebugBard
	DebugGuard
	DebugHeal
	DebugMez
	DebugPet
	DebugSelfBuff

REQUIREMENTS:
	MQ2Nav (optional, used with Guard function)
	MQ2Debuffs (optional, used to self cure)
	MQ2Melee 
	MQ2MoveUtils
	AAPurchase.inc
	Defense.inc
	Spell_Routines.inc
	Ninjadvloot.inc
	QuickBeg.inc
	Wait4Rez.inc
**|

#warning
#include AAPurchase.inc
#include Ninjadvloot.inc
#include Spell_Routines.inc
#include wait4rez.inc
#include QuickBeg.inc
#include Defense.inc
#turbo 80
#CHAT BC
#CHAT CHAT
#CHAT RAIDSAY
#CHAT GROUPSAY

#Event AddCombatSong  	"[MQ2] AddCombatSong #1#"
#Event AddAlert       	"[MQ2] AddAlert #1#"
#Event AddAlertCommon 	"[MQ2] AddAlertCommon #1#"
#Event AddRestSong    	"[MQ2] AddRestSong #1#"
#Event ShowDebuffs    	"[MQ2] ShowDebuffs #1#"
#Event Campout			"It will take about 25 more seconds to prepare your camp."
#Event CanNotSee		"You cannot see your target."
#Event ChangeTank		"change tank #1#"
#Event CombatGem		"[MQ2] CombatGem #1#"
#Event Dead           	"#*#You have been slain by#*#"
#Event DelCombatSong  	"[MQ2] DelCombatSong #1#"
#Event DelRestSong    	"[MQ2] DelRestSong #1#"
#Event Experience     	"#*#You gain party experience#*#"
#Event Faded	      	"#*#You escape from combat, hiding yourself from view."
#Event ImHit          	"#*#YOU for#*#points of damage."
#Event ImHit    	  	"#1#to#*#YOU, but #*#"
#Event Invite         	"#1# invites you to join a group."
#Event IRC            	"<#1#> #2#"
#Event IRC            	"[#1#(msg)] #2#"
#Event IRCNoChan      	"#*#You are not on any channels.#*#"
#Event IRCNoChan      	"#*#You are not connected. Please use /iconnect to establish a connection.#*#"
#Event ListSongs      	"[MQ2] ListSongs #1#"
#Event ListSpells     	"[MQ2] ListSpells#1#"
#Event LoadAlert      	"[MQ2] LoadAlert#1#"
#Event LoadIni        	"[MQ2] LoadIni #1#"
#Event MakeStuff      	"You are low on #1# and #2#."
#Event MakeStuff      	"You are out of #1# and #2#."
#Event MakeStuff      	"You are out of #1# and low on #2#."
#Event MakeStuff      	"You are low on #1#."
#Event MakeStuff      	"You are out of #1#."
#Event MezIt          	"#1# begins to cast a spell. <Complete Heal>"
#Event MezIt          	"#1# begins to cast the gate spell."
#Event NeedStuff      	"You are #1#."
#Event NewZone        	"You have entered#*#"
#Event NoLuclin       	"You must have both the Horse Models and your current Luclin Character Model enabled#*#"
#Event NoLuclin       	"You can not summon a mount in this form#*#"
#Event RaidExperience 	"#*#You gained raid experience#*#"
#Event lootall        	"#*#lootall#*#"
#Event Rampage        	"#*#goes on a RAMPAGE#*#"
#Event RemoveAura		"You do not have sufficient focus to maintain that ability."
#Event RestGem			"[MQ2] RestGem #1#"
#Event Restricted     	"This spell does not work here#*#"
|#Event Restricted     	"You are missing some required comp#*#"
#Event Restricted     	"You can only cast this spell in the outdoors#*#"
#Event Restricted     	"You need to be in a more open area to summon a mount#*#"
#Event Restricted     	"A voice whispers in your mind, 'There are no heroes here#*#"
#Event NoMount        	"You can not summon a mount here#*#"
#Event Recovered		"You haven't recovered yet..."
#Event SaveIni        	"[MQ2] SaveIni#1#"
#Event SetBuff        	"[MQ2] SetBuff#1#"
#Event SetMA1         	"[MQ2] SetMA1#1#"
#Event SetMA2         	"[MQ2] SetMA2#1#"
#Event SetMA3         	"[MQ2] SetMA3#1#"
#Event SetRampTank    	"[MQ2] SetRampTank#1#"
#Event SongAlias      	"[MQ2] SongAlias #1# #2#"
#Event Stand          	"You must be standing to attack!"
#Event Stand	      	"Auto attack is off."
#Event Stand	      	"You must be standing to cast a spell."
#Event ToggleString   	"[MQ2] ToggleString #1#,#2#,#3#,#4#,#5#"
#Event ToggleVar      	"[MQ2] ToggleVar #1#,#2#,#3#,#4#,#5#"
#Event ToggleAABuy    	"[MQ2] ToggleAABuy"
#Event TooClose			"Your target is too close to use a ranged weapon!!"
#Event TooFar         	"Your target is too far away, get closer!"
#Event TooFar         	"You are too far away from your target"
#Event WornOff        	"#*#Your #1# spell has worn off of #2#."
|#Event MezBroke      	"#1# has been awakened by #2#."

Sub Main
|	/if (${MacroQuest.GameState.NotEqual[INGAME]}) /endmacro
	/if (!${Defined[PuppetMaster]}) /declare PuppetMaster string outer ${Me.CleanName}
	/echo I come Optimus...
	/declare AEHeal 			bool 	outer FALSE
	/declare AlertTimer   	    timer  	outer
	/declare AssistHeal 		bool 	outer FALSE
	/declare AssistTimer     	timer  	outer
	/declare AutoRestOff 		bool 	outer FALSE
	/declare AutoRestRadius 	lnt 	outer 125
	/declare BagNum				int		outer
 	/declare BattleBuffFlag 	bool 	outer FALSE
	/declare BardSwap 			bool	outer FALSE	
	/declare BegIfMeInvis       bool    outer FALSE	
	/declare CampX				int		outer 0
	/declare CampY				int		outer 0
	/declare CampZ				int		outer 0
	/declare castReturn     	string 	outer
	/declare CheckGroupTimer 	timer  	outer
	/declare CombatStuffTimer   timer   outer	
	/declare CombatTwist 		string outer	
	/declare Debug				bool	outer FALSE
	/declare DebugBard			bool	outer FALSE
	/declare DebugGuard			bool	outer FALSE
	/declare DebugHeal			bool	outer FALSE
	/declare DebugMez			bool	outer FALSE
	/declare DebugPet			bool	outer FALSE
	/declare DebugSelfBuff		bool	outer FALSE
	/declare DebuffLowest       int     outer 0	
	/declare DivArbGem			string 	outer ALT
	/declare DivArbHPs			int		outer 30						  				   
	/declare DivArbSpell 		string 	outer Divine Arbitration
	/declare DivArbSpellID 		int		outer 	
	/declare DivArbTimer 		timer 	outer 0
	/declare DoBardMeleeSwap	bool	outer FALSE
	/declare DoBardSwap			bool	outer FALSE	
 	/declare DoBuffLowest 		int 	outer 10	
	/declare DoBuffs 			bool 	outer FALSE	
    /declare DoBuffTimer        timer   outer 0	
    /declare DoBuffTotal        int     outer
    /declare DoBuffQueue[25,2]  int     outer	
	/declare DoCanni 			bool 	outer FALSE	
	/declare DoCharm 			bool 	outer FALSE	
 	/declare DoCombatStuff 		bool 	outer FALSE	
 	/declare DoConcussion 		bool 	outer FALSE	
	/declare DoCures 			bool 	outer FALSE	
	/declare DoDebuffs 			bool 	outer FALSE	
    /declare DoDelayedTimer     timer   outer	
	/declare DoDichotomic		bool 	outer FALSE
	/declare DoDoTs             bool    outer FALSE
	/declare DoHolyShit         bool    outer FALSE	
	/declare DoManaTaps 		bool 	outer FALSE
	/declare DoMez				bool	outer FALSE	
 	/declare DoNamedStuff 		bool 	outer FALSE	
	/declare DoNukes            bool    outer FALSE
	/declare DoRally 			bool 	outer FALSE
	/declare DoRamp				bool	outer FALSE	
	/declare DoRestStuff 		bool 	outer FALSE	
	/declare DoRetort	 		bool 	outer FALSE	
	/declare DoSotwFunction 	string 	outer DoSotW	
	/declare DoWard 			bool 	outer FALSE
	/declare DoWoW 				bool 	outer FALSE	
	/declare EvaluateFunction 	string 	outer EvaluateGroup	
	/declare FollowFlag       	bool   	outer FALSE
	/declare FollowGuy       	int    	outer
	/declare GMob 				string 	outer 999999
	/declare GroupHealing 		bool 	outer FALSE
  	/declare GroupHurtCount		int 	outer 0	
	/declare GuardPause 		timer 	outer 0	
	/declare HealGroup 			bool 	outer FALSE
	/declare HealPets 			bool 	outer FALSE
	/declare HealXTarget 		bool 	outer FALSE
	/declare IRCConnect      	timer  	outer
	/declare LastCast       	string 	outer
 	/declare LastSpawnCount 	int 	outer 0
	/declare LOSOnly			bool	outer FALSE
	/declare MATarget        	int    	outer 999999
    /declare MainTankID         int     outer
	/declare MaxGems     		int    	outer ${Me.NumGems}
    /declare Gems[${MaxGems}]	int    	outer	
	/declare MercStanceTimer	timer	outer 0
	/declare MezReturn			int		outer 0
    /declare MezSong     		string 	outer
	/declare Meztimer			timer	outer 0
	/declare NeedRod			int		outer 0
	/declare noFeigning 		bool	outer TRUE	
	/declare noInterrupt 		int 	outer 1
	/declare noInvis         	int    	outer 1
	/declare NPCRadChk       	int    	outer 0
	/declare NukeLowest         int     outer 100	
	/declare NukeTimer          timer   outer 
	/declare PetAttack 			bool 	outer FALSE
	/declare PetBuffTimer 		timer 	outer 0
	/declare PetID		  		int    	outer
	/declare PetMana 			int 	outer 0
	/declare PetToysDone    	int    	outer       0
	/declare PetToys[4]    		string 	outer
	/declare Parse          	string 	outer 
	/declare PauseFlag 			bool 	outer FALSE	
	/declare PauseTimer			timer	outer 0	
    /declare QueueCount         int     outer 0
	/declare RDPause         	bool   	outer FALSE
	/declare RDIni		 		string 	outer RD1_${Me.CleanName}.ini	
	/declare RDVersion      	string 	outer 4.29.10	
	/declare RecoveredTimer		timer	outer 0	
	/declare RefreshBuffs       bool    outer TRUE
	/declare ReportMana         bool    outer FALSE
	/declare ReportManaPct      int     outer 
 	/declare RestStuffTimer 	timer 	outer 0	
  	/declare RestTwist   		string outer									  
	/declare RetortSpell 		string 	outer 
	/declare RetortSpellGem 	string 	outer 
	/declare RetortTimer 		timer 	outer 0
	/declare SpamTimer			timer	outer 0	
	/declare SelfBuffs 			bool 	outer FALSE	
	/declare SelfBuffTimer		timer 	outer 0
	/declare SitTimer        	timer  	outer
	/declare ShieldTimer        timer   outer	
	/declare SpamFlag        	bool   	outer
	/declare StayOnHealTimer 	timer  	outer	
	/declare TravelMode      	bool   	outer
	/declare TwistTimer			timer	outer 0	
 	/declare UniqueSongs 		int    outer
	/declare UseCH 				bool 	outer FALSE	
	/declare UseBDA				bool	outer FALSE
	/declare UseDiscs 			bool 	outer FALSE	
	/declare UseDivArb			bool	outer FALSE
	/declare UsePet 			bool 	outer FALSE	
	/declare UseRods            bool    outer FALSE	
	/declare UseTankHoT         bool    outer FALSE	
	/declare WardSpell 			string 	outer 
	/declare WardSpellGem 		string 	outer 
	/declare WhichNuke			int		outer 1
	/declare WorstHPs 			int		outer 100
    /declare WorstID       		int    	outer 0	
	/declare YaulpSpell 		string 	outer Yaulp	
	/declare ZoneName       	string 	outer	
	/if (!${Bool[${Plugin[MQ2GMCheck]}]}) /declare GMCheck            bool    outer TRUE
	
	/if (${Bool[${Plugin[MQ2Netheal]}]}) {
		/if (!${Defined[DoSotwFunction]}) {
			/declare DoSotwFunction 	string 	outer DoSotW
			}
		/varset EvaluateFunction EvaluateGroupNet
		/varset DoSotwFunction DoSotWNet
		}
	/if (!${Bool[${Plugin[MQ2Melee]}]}) /multiline ; /echo \ar MQ2Melee required for this macro!! ;/end
	/if (!${Bool[${Plugin[MQ2MoveUtils]}]}) /multiline ; /echo \ar MQ2MoveUtils required for this macro!! ;/end
	/if (!${Bool[${Plugin[MQ2AutoLogin]}]}) /echo \ay MQ2AutoLogin recommended for this macro if you want to change to trader.
	
	/if (${RDVersion.NotEqual[${Ini[RDCommon.ini,Settings,Version]}]}) {
		/if (${Bool[${Plugin[MQ2CEcho]}]}) /echo \ar Version Mismatch Detected, Loading Aliases
		/squelch /alias /aabuy		      /echo ToggleAABuy
		/squelch /alias /addalert         /echo AddAlert
		/squelch /alias /addcombatsong    /echo AddCombatSong
		/squelch /alias /addrestsong      /echo AddRestSong
		/squelch /alias /aeheal           /echo ToggleVar AE Healing,AEHeal,HealStuff,AEHealing,	
		/squelch /alias /assistdelay      /echo ToggleString Assist Delay,AssistDelay,GeneralStuff,AssistDelay,
		/squelch /alias /assistheal       /echo ToggleVar Assist Healing,AssistHeal,HealStuff,AssistHealing,
		/squelch /alias /assistma         /echo ToggleVar Auto Assisting the MA,AssistMA,GeneralStuff,AssistMA,
		/squelch /alias /autoloot         /echo ToggleVar Auto Looting,AutoNinja,Settings,AutoNinja,
		/squelch /alias /autoninja        /echo ToggleVar Ninja Looting,AutoNinja,Settings,AutoNinja,
		/squelch /alias /autorestoff      /echo ToggleVar Auto Rest Twist Disabling,AutoRestOff,Bard,AutoRestOff,
		/squelch /alias /autorestradius   /echo ToggleString Auto Rest Twist Off Radius,AutoRestRadius,Bard,AutoRestRadius,
		/squelch /alias /autosit          /echo ToggleVar Auto Sitting,AutoSit,Settings,AutoSit,
		/squelch /alias /buff             /echo SetBuff
		/squelch /alias /cancelpct        /echo ToggleString Cancel Percent,CancelPct,HealStuff,CancelPct,
		/squelch /alias /charm            /echo ToggleVar Auto Charm,DoCharm,DebuffStuff,DoCharm,
		/squelch /alias /changetank 	  /echo ToggleVar Change MA1 on call or death,ChangeTank,GeneralStuff,ChangeTank,
		/squelch /alias /chatchannel      /echo ToggleString Chat Channel,ChatChannel,GeneralStuff,ChatChannel,
		/squelch /alias /checkgroup       /echo ToggleString check Group Interval,CheckGroupInterval,HealStuff,CheckGroupInterval,
		/squelch /alias /checkstatus   	  /echo ToggleVar Toggle group status checking,Status,MeleeStuff,Status,
		/squelch /alias /combatgem 		  /echo CombatGem
		/squelch /alias /debuff           /echo ToggleVar Auto Debuffing,DoDebuffs,DebuffStuff,DoDebuffs,
		/squelch /alias /debuffchannel    /echo ToggleString Report Channel,DebuffChannel,DebuffStuff,DebuffChannel,
		/squelch /alias /delayedhealpct   /echo ToggleString Main Assist Delayed Heal Percent Hitpoints,DelayedHealPct,HealStuff,DelayedHealPct,
		/squelch /alias /delcombatsong    /echo DelCombatSong
		/squelch /alias /delrestsong      /echo DelRestSong
		/squelch /alias /divarbhps        /echo ToggleString Divine Arbitration Hitpoints,DivArbHPs,HealStuff,DivArbHPs,
		/squelch /alias /dodefense        /echo ToggleVar Auto Engaging Defensive Abilities,DoDefense,MeleeStuff,DoDefense,
		/squelch /alias /dobuffs          /echo ToggleVar Auto Buffing,DoBuffs,DoBuffStuff,DoBuffs,
		/squelch /alias /dobufftells      /echo ToggleVar Buffing Tells,DoBuffTells,DoBuffStuff,DoBuffTells,
		/squelch /alias /docanni          /echo ToggleVar Auto Cannibalization/Harvest,DoCanni,GeneralStuff,DoCanni,
		/squelch /alias /docombat         /echo ToggleVar Combat Scripts,DoCombatStuff,CombatStuff,DoCombatStuff,
		/squelch /alias /docures          /echo ToggleVar Auto Curing,DoCures,CureStuff,DoCures,
		/squelch /alias /dointerrupting	  /echo ToggleVar Interrupting to heal others,Stop4Pad,HealStuff,AutoInterrupt,
		/squelch /alias /domancy		  /echo ToggleVar Toggle auto activating of Pryomancy Acromany Cryomancy,DoMancy,NukeStuff,DoMancy
		/squelch /alias /domercstance     /echo ToggleVar Auto change mercenary stance,DoMercStance,MeleeStuff,DoMercStance,
		/squelch /alias /domercassist     /echo ToggleVar Auto engage macro control of merc assist,DoMercAssist,MeleeStuff,DoMercAssist,
		/squelch /alias /mercengagehps    /echo ToggleString Auto change mercenary stance,MercEngageHPs,MeleeStuff,MercEngageHPs
		/squelch /alias /domelee          /echo ToggleVar Auto Melee,DoMelee,MeleeStuff,DoMelee,
		/squelch /alias /donamed          /echo ToggleVar Named Scripts,DoNamedStuff,NamedStuff,DoNamedStuff,
		/squelch /alias /dopettoys	 	  /echo ToggleVar Auto Summoning pettoys,DoPetToys,SummonStuff,DoPetToys,
		/squelch /alias /doports          /echo ToggleVar Auto Ports,DoPorts,GeneralStuff,DoPorts,
		/squelch /alias /doranged         /echo ToggleVar Auto engage Range attacks,DoRanged,MeleeStuff,DoRanged,		
		/squelch /alias /dorest           /echo ToggleVar Rest Scripts,DoRestStuff,RestStuff,DoRestStuff,
		/squelch /alias /doretort         /echo ToggleVar Using Retort on MA1,DoRetort,HealStuff,DoRetort,
		/squelch /alias /doshrink	  	  /echo ToggleVar DoShrink,DoShrink,Settings,DoShrink,
		/squelch /alias /dot              /echo ToggleVar Auto DoTing,DoDoTs,DebuffStuff,DoDoTs,
		/squelch /alias /doward			  /echo ToggleVar Using Ward on MA1,DoWard,HealStuff,DoWard,		
		/squelch /alias /doyaulp          /echo ToggleVar Auto Yaulping in combat,DoYaulp,GeneralStuff,DoYaulp,	
		/squelch /alias /engagehps        /echo ToggleString Engage Hitpoints,EngageHPs,GeneralStuff,EngageHPs,
		/squelch /alias /guard      	  /echo ToggleVar Guard Melee,Guard,MeleeStuff,Guard,
		/squelch /alias /healchannel      /echo ToggleString Heal Channel,HealChannel,HealStuff,HealChannel,
		/squelch /alias /healfd           /echo ToggleVar Ignoring Non-FD FD classes,HealFD,HealStuff,HealFD,
		/squelch /alias /healgroup        /echo ToggleVar Group Healing,HealGroup,HealStuff,GroupHealing,
		/squelch /alias /healmefirst      /echo ToggleVar Healing Myself over anyone else,HealMeFirst,HealStuff,HealMeFirst,
		/squelch /alias /healpct          /echo ToggleString Heal Hitpoint Percent,HealPct,HealStuff,HealPct,
		/squelch /alias /healpets         /echo ToggleVar pet Healing,HealPets,HealStuff,PetHealing,
		/squelch /alias /healramp         /echo ToggleVar Rampage Healing,DoRamp,HealStuff,RampHealing,
		/squelch /alias /healxtarget      /echo ToggleVar Heal pet or PCs on Xtarget,HealXTarget,HealStuff,HealXTarget,
		/squelch /alias /ignorenpc        /echo AddAlert
		/squelch /alias /ignorenpccommon  /echo AddAlertCommon
		/squelch /alias /ignorerefresh    /echo LoadAlert	
		/squelch /alias /leashlength      /echo ToggleString Leash Length,LeashDistance,Settings,LeashLength,
		/squelch /alias /listsongs        /echo ListSongs
		/squelch /alias /listspells       /echo ListSpells
		/squelch /alias /loadini          /echo LoadIni
		/squelch /alias /losonly          /echo ToggleVar Changing the Guard pull limit to Line of Sight,LOSOnly,MeleeStuff,LOSOnly,
		/squelch /alias /ma1              /echo SetMA1
		/squelch /alias /ma2              /echo SetMA2
		/squelch /alias /ma3              /echo SetMA3
		/squelch /alias /medpct           /echo ToggleString Sit/Summon horse Mana Percent,MedPct,Settings,MedPct,
		/squelch /alias /mez              /echo ToggleVar Auto Mezzing,DoMez,DebuffStuff,DoMez,
		/squelch /alias /mezz             /echo ToggleVar Auto Mezzing,DoMez,DebuffStuff,DoMez,		
        /squelch /alias /moveupjitter     /echo ToggleString Jittering for move up,MoveUpJitter,Settings,MoveUpJitter,
		/squelch /alias /npcradchk 		  /echo ToggleString Radius to check for NPC's is now,NPCRadChk,NULL,NULL,
		/squelch /alias /npcradius        /echo ToggleString npc Checking radius,NPCRadius,Settings,NPCRadius,
		/squelch /alias /npczradius       /echo ToggleString npc Checking Z radius,NPCZRadius,Settings,NPCZRadius,
		/squelch /alias /nukes            /echo ToggleVar Auto Nuking,DoNukes,NukeStuff,DoNukes,
		/squelch /alias /nukedelay        /echo ToggleString Delay between Nukes,NukeDelay,NukeStuff,NukeDelay,
		/squelch /alias /nukeset          /echo ToggleString Nuke Spell set is now,WhichNuke,NukeStuff,WhichNuke,
		/squelch /alias /pcradius         /echo ToggleString pc Checking radius,PCRadius,Settings,PCRadius,
		/squelch /alias /pczradius        /echo ToggleString pc Checking Z radius,PCZRadius,Settings,PCZRadius,
		/squelch /alias /PetAttack		  /echo ToggleVar Pet attacking,PetAttack,PetStuff,PetAttack,
		/squelch /alias /petbuff          /echo ToggleVar pet Buffing,DoPetBuffs,PetStuff,DoPetBuffs,
		/squelch /alias /pethealpct       /echo ToggleString pet Healing Percent Hitpoints,PetHealPct,HealStuff,PetHealPct,
		/squelch /alias /pettoyschannel   /echo ToggleString PetToys Channel,PetToysChannel,SummonStuff,PetToysChannel,
		/squelch /alias /ramptank         /echo SetRampTank
		/squelch /alias /rangedist        /echo ToggleString Range attack limit,RangeDist,MeleeStuff,RangeDist,		
		/squelch /alias /rdpause          /echo ToggleVar AutoBot Pause,RDPause,NULL,NULL,
		/squelch /alias /refreshbuffs     /echo ToggleVar Auto Buff Refreshing,RefreshBuffs,DoBuffStuff,RefreshBuffs,
		/squelch /alias /relaytells       /echo ToggleVar Relaying Tells,RelayTells,GeneralStuff,RelayTells,
		/squelch /alias /reportcures      /echo ToggleVar Cure Reporting,ReportCures,CureStuff,ReportCures,
		/squelch /alias /reportdebuffs    /echo ToggleVar Debuff Reporting,ReportDebuffs,DebuffStuff,ReportDebuffs,
		/squelch /alias /reportdefense    /echo ToggleVar Defense Reporting,ReportDefense,MeleeStuff,ReportDefense,
		/squelch /alias /reportdobuffs    /echo ToggleVar Buff Reporting,ReportDoBuffs,DoBuffStuff,ReportDoBuffs,
		/squelch /alias /reportdots       /echo ToggleVar DoT Reporting,ReportDoTs,DebuffStuff,ReportDoTs,
		/squelch /alias /reportevents     /echo ToggleVar Event Reporting,ReportEvents,GeneralStuff,ReportEvents,
		/squelch /alias /reportheals      /echo ToggleVar Heal Reporting,ReportHeals,HealStuff,ReportHeals,
		/squelch /alias /reportinterrupts /echo ToggleVar Interrupt Reporting,ReportInterrupts,HealStuff,ReportInterrupts,
		/squelch /alias /reportmana       /echo ToggleVar Mana Reporting,ReportMana,GeneralStuff,ReportMana,
		/squelch /alias /reportmanapct    /echo ToggleString ReportMana Percent,ReportManaPct,GeneralStuff,ReportManaPct,
		/squelch /alias /reportmez        /echo ToggleVar Mezz Reporting,ReportMez,DebuffStuff,ReportMez,
		/squelch /alias /reportmezbroke   /echo ToggleVar Report Mez breaking,Mezbroke,DebuffStuff,Mezbroke,
		/squelch /alias /reportpettoys    /echo ToggleVar PetToys Reporting,ReportPetToys,SummonStuff,ReportPetToys,
		/squelch /alias /reportselfbuffs  /echo ToggleVar Self Buff Reporting,ReportSelfBuffs,SelfBuffStuff,ReportSelfBuffs,
		/squelch /alias /reportsotw       /echo ToggleVar Spirit of the Wood Reporting,ReportSotW,HealStuff,ReportSotW,
		/squelch /alias /reporttoggles    /echo ToggleVar Toggle Reporting,ReportToggles,GeneralStuff,ReportToggles,
		/squelch /alias /reportwow        /echo ToggleVar Wrath of the Wild Reporting,ReportWoW,GeneralStuff,ReportWoW,
		/squelch /alias /restgem 		  /echo RestGem
		/squelch /alias /saveini          /echo SaveIni
		/squelch /alias /selfbuff         /echo ToggleVar Auto Self Buffing,SelfBuffs,SelfBuffStuff,SelfBuffs,
		/squelch /alias /showdebuffs	  /echo ShowDebuffs	
		/squelch /alias /sitdelay         /echo ToggleString Sit Delay after casting,SitDelay,Settings,SitDelay,
		/squelch /alias /SongAlias        /echo SongAlias
		/squelch /alias /sotw             /echo ToggleVar Auto Spirit of the Wood,DoSotW,HealStuff,DoSotW,
		/squelch /alias /sotwpct          /echo ToggleString SotW/CR/AAid Average Group Percent Hitpoints,SotWPct,HealStuff,SotWPct,
		/squelch /alias /stayonheal	      /echo ToggleString Staying on heal,StayOnHeal,HealStuff,StayOnHeal,	
		/squelch /alias /stickargs        /echo ToggleString Melee args for stick,StickArgs,MeleeStuff,StickArgs,
		/squelch /alias /stophps          /echo ToggleString Stop Nuking Percent Hitpoints,StopHPs,GeneralStuff,StopHPs,
		/squelch /alias /summonmeals      /echo ToggleVar Auto Summoning of food and drink,SummonFood,SummonStuff,SummonFood,
		/squelch /alias /tankhealpct      /echo ToggleString Main Assist Complete Heal Percent Hitpoints,TankHealPct,HealStuff,TankHealPct,
		/squelch /alias /targetlock       /echo ToggleVar Using non-assist target lock,TargetLock,GeneralStuff,TargetLock,
		/squelch /alias /useammoclicky    /echo ToggleVar Summoning of ammo,UseAmmoClicky,SummonStuff,UseAmmoClicky,
		/squelch /alias /UseCH            /echo ToggleVar CHing of MA1,UseCH,HealStuff,UseCH,
		/squelch /alias /usedelayed       /echo ToggleVar Delayed Heal of MA1,UseDelayedHeal,HealStuff,UseDelayedHeal,
		/squelch /alias /usedivarb        /echo ToggleVar Auto Divine Arbitration,UseDivArb,HealStuff,UseDivArb,
		/squelch /alias /useepic          /echo ToggleString Mobs for use epic,UseEpic,GeneralStuff,UseEpic,
		/squelch /alias /usetankhot       /echo ToggleVar Useage of Heal over Time on MA1,UseTankHoT,HealStuff,UseTankHoT,
		/squelch /alias /useirc           /echo ToggleVar Using the IRC Plugin,UseIRC,Settings,UseIRC,
		/squelch /alias /usegroupassist   /echo ToggleVar Use Grouprole Main Assist as MA1,UseGroupMA,GeneralStuff,UseGroupMA,		
		/squelch /alias /usegroupma 	  /echo ToggleVar Use Grouprole Main Assist as MA1,UseGroupMA,GeneralStuff,UseGroupMA,
        /squelch /alias /usegrouptank     /echo ToggleVar Use Tank set by Role instead of MA1 for healing,UseGroupTank,GeneralStuff,UseGroupTank,
		/squelch /alias /usehott          /echo ToggleVar Health of Target's Target Evaluation for Debuffs,UseHoTT,DebuffStuff,UseHoTT,	
		/squelch /alias /usemount         /echo ToggleVar Auto Mounting,UseMount,Settings,UseMount,
		/squelch /alias /UsePet           /echo ToggleVar Auto Pet summoning and melee,UsePet,PetStuff,UsePet,
		/squelch /alias /useraidassist    /echo ToggleVar Use Raid Designated Main Assist1 as MA1,UseRaidMA,GeneralStuff,UseRaidMA,
		/squelch /alias /useraidma		  /echo ToggleVar Use Raid Designated Main Assist1 as MA1,UseRaidMA,GeneralStuff,UseRaidMA,		
		/squelch /alias /waittocancel     /echo ToggleVar Waiting to Cancel Heals,WaitToCancel,HealStuff,WaitToCancel,
		/squelch /alias /wow              /echo ToggleVar Auto Wrath of the Wild,DoWoW,GeneralStuff,DoWoW,
		
		/ini "RDCommon.ini" "Settings" "Version" "${RDVersion}"
	}
	/call LoadIni "${RDIni}" LOAD
	/call QuickBegDeclares
	/call SetupAdvLootVars
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (!${Bool[${Plugin[MQ2Twist].Name}]}) /plugin MQ2Twist noauto
		/delay 10s ${Bool[${Plugin[MQ2Twist].Name}]}
		/if (!${Bool[${Plugin[MQ2Twist].Name}]}) {
			/echo You need MQ2Twist to play a bard!
			/end
			}
|---EDIT per Sifun forum post 10-2-17
|		/call Event_ListSongs None All
|		/call SetTwists
		}
	/varset ZoneName ${Zone.Name}
	/echo Finished loading, ready for battle.
	/call AnnounceMessage ${ChatChannel} 1 g Ready
	/call INICheck1
	
:mainloop
	/doevents
	/if (!${Me.Moving}) {
		/call AutoSit
		}
	/if (!${RDPause}) {
		/varset PauseFlag FALSE
		}
	/if (${Me.State.Equal[HOVER]}) {
		/call Event_Dead
		}
	/if (!${Zone.Name.Equal[${ZoneName}]}) {
		/call Event_NewZone
		}
	/if (${UseGroupMA}==TRUE) {
		/if (${Group.MainAssist.ID}!=${Spawn[${MA1}].ID}) {
			/varset MA1 ${Group.MainAssist}
			/if (${Me.GroupAssistTarget.ID}) {
				/if (${Spawn[${Me.GroupAssistTarget.ID}].Type.Equal[NPC]}) /varset MATarget ${Me.GroupAssistTarget.ID}
				}
			}
		}
	/if (${UseRaidMA}==TRUE) {
		/if (${UseGroupMA}==FALSE && ${Raid.MainAssist.ID}!=${Spawn[${MA1}].ID}) {
			/varset MA1 ${Raid.MainAssist}
			}
		}
    /if (${UseGroupTank}) {
        /varset MainTankID ${Group.MainTank.ID}
		} else {
        /varset MainTankID ${Spawn[${MA1}].ID}
		}
	/if (!${RDPause} && (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]})) {
		/if (${Me.Class.ShortName.Equal[BRD]}) {
			/if (!${TwistTimer}) {
				/call SingSongs
				}
			}
		/call MeBegBuff
		/call MeBegItem
		/call PetBegBuff
		/if (${DoRestStuff}) {
			/if (!${Me.CombatState.Equal[COMBAT]} && !${RestStuffTimer}) {
				/call DoStuff Rest
				/call MercStuff
				/call ClassStuffRest
				}
			}
		/if (!${RDPause} && !${Me.Moving}) {
			/call SummonStuff
			}
		/if (${Bool[${Plugin[MQ2Debuffs]}]}) {
			/if (${Debuff}) {
				/call MeBegCure
				}
			}
		/if (${UseRods}) {
			/call ClickRods
			}
		/if (!${CheckGroupTimer}) {
			/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) {
				/call CheckGroup
				}
			}
		/if (${UseTankHoT}) {
			/if (!${RDPause} && ${Select[${Me.Class.ShortName},CLR,SHM]}) {
				/call HealOverTime
				}
			}
		/if (${DoShrink}) {
			/if (!${RDPause} && !${Me.Moving}) {
				/if (!${Me.Invis}) {
					/if (!${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) {
						/call ShrinkStuff
						}
					}
				}
			}
		/if (!${RDPause} && ${QueueCount}) {
			/if (!${Me.Moving}) {
				/if (${DoBuffs}) {
					/if (${BattleBuffFlag} || !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) {
						/if (${Me.PctMana}>=${DoBuffLowest}) {
							/if (${Debug}) /echo Calling DoBuffEvents with QueueCount=${QueueCount}
							/call DoBuffEvents
							}
						}
					}
				}
			}
		/if (!${RDPause} && !${DoBuffTimer}) {
			/if (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]}) {
				/if (!${Me.Moving}) {
					/if (!${Melee.Combat}) {
						/if (!${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) {
							/if (!${Me.Casting.ID} || ${Me.Class.ShortName.Equal[BRD]}) {
								/if (${SelfBuffs} && !${SelfBuffTimer}) {
									/call CheckBuffs
									}
								/if ((${UsePet} || ${DoCharm}) && ${Me.PctMana}>=${PetMana} && !${Bool[${PetBuffTimer}]}) {
									/call PetStuff
									}
								/if (!${Me.Moving} && ${DoWoW} && ${Me.AltAbilityReady[Wrath of the Wild]}) {
									/call DoWoW
									}
								/if (${DoBuffTotal}) {
									/varset DoBuffTimer 3s
									}
								}
							}
						}
					}
				}
			}
		/if (!${RDPause} && ${Zone.ID}!=202 && ${Zone.ID}!=344) {
			/if (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]}) {
				/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
					/if (${AssistHeal}) {
						/call DoAssistHeal
						}
					/if (${AEHeal}) {
						/call DoAEHeal
						}
					/if (${HealXTarget} && !${RDPause}) {
						/call HealXTarget
						}
					/if (${AssistMA}) {
						/call AssistMA1
						}
					/if ((${DoMez} || ${DoCharm}) && ${Select[${Me.Class.ShortName},BRD,ENC,DRU]} && (!${CheckGroupTimer} || ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}!=${LastSpawnCount})) {
						/call CheckMez
						}
					/if (${Guard}) {
						/if (${MakeCamp.Status.Equal[ON]}) {
							/if (${Group.MainTank.ID}==${Me.ID}) {
									/if (!${Bool[${RDPause}]}) {
										/if (${Me.XTarget[1].ID}) {
											/if (!${Me.Combat}) {
												/if (${Me.XTarget[1].Distance}<100) {
													/target ID ${Me.XTarget[1].ID}
													/attack
													}
												}
											}
										}
									}
								}
						/if (${MATarget}==999999) {
							/if (${Defined[GuardTimer]}) {
								/if (${GuardTimer}<1) {
									/call Guard
									}
								} else /call Guard
							}
						}
					/if (${PetAttack})	{
						/if (${Spawn[${MATarget}].PctHPs}<${EngageHPs}) {
							/if (!${PetAssistTimer}) {
								/call PetAttackStuff
								}
							}
						}
					/if ((${DoDebuffs} || ${DoDoTs} || ${DoManaTaps}) && ${Me.PctMana}>=${DebuffLowest}) {
						/call DebuffIt
						}
					/if (${DoNukes}) {
						/if (!${NukeTimer}) {
							/if (${Me.PctMana}>=${NukeLowest}) {
								/if (${Spawn[${MATarget}].Type.NotEqual[Corpse]}) {
									/if (${MATarget}!=999999) {
										/call Nukeit
										}
									}
								}
							}
						}
					/if (${DoCombatStuff}) {
						/if (${Me.CombatState.Equal[COMBAT]}) {
							/if (!${CombatStuffTimer}) {
								/call DoStuff Combat
								}
							}
						}
					/if (${DoDefense}) {
						/if (${Me.CombatState.Equal[COMBAT]}) {
							/if (${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) {
								/if (${Target.Distance}<75) {
									/if (${Spawn[${MATarget}].Named} || ${Me.XTarget}>2 || (${Spawn[id ${MATarget}].Level}>=${Math.Calc[${Me.Level}+4]}) || ${Me.PctHPs}<70) {
										/call Defense
										}
									}
								}
							}
						}
					/if (${DoNamedStuff}) {
						/if (${Target.Type.Equal[npc]}) {
							/if (${Spawn[${MATarget}].Named} || ${Spawn[id ${MATarget}].Level}>=${Math.Calc[${Me.Level}+4]} || ${Me.XTarget}>2) { 
								/call Named
								}
							}
						}
					/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]}) {
						/call ClassStuffCombat
						}
					}
				}
			}
		}
	/call MoveStuff
	/if (!${Me.Moving}) {
		/call AutoSit
		}
	/if (${Defined[Irc]}) {
		/if (!${Irc} && ${IRCConnect}) /call Connect
		}
	/doevents
	/if (${Window[TradeWnd].HisTradeReady}) {
		/if (${MasterList.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList2.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList3.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList4.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList5.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]}) {
			/notify TradeWnd TRDW_Trade_Button leftmouseup
			}
		}
	/doevents
	/if (!${Me.Casting.ID}) /varset castReturn CAST_CANCELLED
|	/if (${Target.Type.Equal[PC]}) {
|		/if  (${Me.Class.ShortName.NotEqual[CLR]}) {
|			/if (!${RDPause}) {
|				/target clear
|				}
|			}
|		}
	/goto :mainloop
	/return

Sub PauseFunction
	/delay 10s !${Me.Casting.ID}
	/return
	
Sub INICheck1
|------------------
| Checks sections that are turned on, announces check in MQ2Chat window. If there are errors, announces the section and number of the problem INI entry
| sort 1 = single variables with "spell" in the name
| sort 2 = single variables with out "spell" in the name
| sort 3 = multiple variables with "spell" in the name
| sort 4 = multiple variables with out "spell" in the name
|------------------
	/if (${SelfBuffs}) {
		/call INICheck2 SelfBuff 4
		}
	/if (${DoBuffs}) {
		/call INICheck2 DoBuff 4
		}
	/if (${DoDebuffs}) {
		/call INICheck2 Debuff 3
		}
	/if (${Defined[DoNukes]}) {
		/if (${DoNukes}) /call INICheck2 Nuke 4
		}
	/if (${UseGroupMA}) {
		/echo ${If[${Group.MainAssist.ID},\am Group MA is \ay ${Group.MainAssist},\ar NO assigned group MA!!]}
		}	
	/if (${UseRaidMA}) {
		/if (${Raid.Members}<1) {
			/echo \ar ERROR \ay using Raid Assist while not on a raid!
			}
		/if (${Raid.Members}>1 && !${Raid.MainAssist.ID}) {
			/echo \ar ERROR \ay no Raid Main Assist assigned
			}
		/if (${UseGroupMA} || ${UseGroupTank}) {
			/echo \ar ERROR \ay trying to use Raid Assist with ${If[${UseGroupMA},UseGroupMA on!!,]} ${If[${UseGroupTank},UseGroupTank on!!,]}
			}
		}
	/if (${UseGroupTank}) {
		/echo ${If[${Group.MainTank.ID},\am Main Tank is \ay ${Group.MainTank},\ar NO Main Tank assigned!!]}
		/if (${UseGroupMA} && ${Group.MainAssist.ID}!=${Group.MainTank.ID}) {
			/echo \ao Both "/usegrouptank" and "/usegroupma" are on, need one of them off
			}
		}
	/if (${DoShrink}) {
		/call INICheck2 Shrink 1
		}
	/if (${Defined[HealGroup]}) {
		/if (${HealGroup}) {
			/if (${DoRetort}) {
				/if (!${Me.Book[${Me.Book[${Spell[${RetortSpell}].RankName}]}].ID}) /echo \ar Retort spell ${RetortSpell} not in spellbook.
				}
			/if (${UseTankHoT}) {
				/call INICheck2 Hot 1
				}
			/if (${UseFranticHeal}) {
				/call INICheck2 FranticHeal 2
				}
			/if (${HealGroup} || ${Bool[${FastHeal}]}) {
				/call INICheck2 FastHeal 2
				}
			/if (${UseCH}) {
				/call INICheck2 TankHeal 2
				}
			/if (${HealPets}) {
				/call INICheck2 PetHeal 2
				}
			/if (${GroupHealing}) {
				/call INICheck2 GroupHeal 2
				}
			/if (${UseDelayedHeal}) {
				/call INICheck2 DelayedHeal 2
				}
			}
		}
	/if (${Defined[UseDivArb]}) {
		/if (${UseDivArb}) {
			/call INICheck2 DivArb 1
			}
		}
	/if (${Defined[DoWard]}) {
		/if (${DoWard}) {
			/if (!${Me.Book[${Me.Book[${Spell[${WardSpell}].RankName}]}].ID}) /echo \ar Ward spell ${WardSpell} not in spellbook.
			}
		}
	/if (${DoCures}) {
		/call INICheck2 Cure 3
		}
	/if (${Defined[UsePet]}) {
		/if (${UsePet}) {
			/call INICheck2 Pet 1
			}
		}
	/if (${Defined[PetShrink]}) {
		/if (${PetShrink}) {
			/call INICheck2 PetShrink 1
			}
		}
	/if (${Defined[DoPetBuffs]}) {
		/if (${DoPetBuffs}) {
			/call INICheck2 PetBuff 4
			}
		}
	/if (${SummonFood}) {
		/call INICheck2 food 1
		/call INICheck2 drink 1
		}
	/return

Sub INICheck2(Types,Sort)
|------------------
| The actualy function of the INI check feature.
|------------------	
	/declare x int local
	/if (${Sort}==1) {
	|For spells with "spell" in the name IE InvisibilitySpell
		/echo \ay Checking \ao ${Types}
		/if (!${Select[${${Types}Gem},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}Spell}].RankName}]}].ID}) {
			/echo \ar ${${Types}Spell} not in spellbook.
			}
		/if (${${Types}Gem.Equal[item]} && !${FindItem[${${Types}Spell}].ID}) {
			/echo \ar ${Types} ${${Types}Spell} is marked as an item and not in inventory.
			}
		/if (${${Types}Gem.Equal[alt]} && !${Me.AltAbility[${${Types}Spell}].ID}) {
			/echo \ar ${Types} ${${Types}Spell} is marked as an AA, you don't appear to have.	
			}
		}
	/if (${Sort}==2) {
	|For spells with out "spell" in the name IE DelayedHeal
		/echo \ay Checking \ao ${Types}
		/if (!${Select[${${Types}Gem},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}}].RankName}]}].ID}) {
			/echo \ar ${${Types}} not in spellbook.
			}
		/if (${${Types}Gem.Equal[item]} && !${FindItem[${${Types}}].ID}) {
			/echo \ar ${${Types}} is marked as an item and not in inventory.
			}
		/if (${${Types}Gem.Equal[alt]} && !${Me.AltAbility[${${Types}}].ID}) {
			/echo \ar ${${Types}} is marked as an AA, you don't appear to have.	
			}
		}		
	/if (${Sort}==3) {
	|for spells with a variable at the end, with "spell" in the name IE DebuffSpell
		/echo \ay Checking \ao ${Types}
		/for x 1 to ${${Types}Total}
			/if (!${Select[${${Types}Gem${x}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}Spell${x}}].RankName}]}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} not in spellbook.
				}
			/if (${${Types}Gem${x}.Equal[item]} && !${FindItem[${${Types}Spell${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} is marked as an item and not in inventory.
				}
			/if (${${Types}Gem${x}.Equal[alt]} && !${Me.AltAbility[${${Types}Spell${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} is marked as an AA, you don't appear to have.
				}
		/next x
		}
	/if (${Sort}==4) {
	|for spells with a variable at the end,but no "spell" in the name IE Dobuff1
		/echo \ay Checking \ao ${Types}
		/for x 1 to ${${Types}Total}
			/if (!${Select[${${Types}Gem${x}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}${x}}].RankName}]}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} not in spellbook.
				}
			/if (${${Types}Gem${x}.Equal[item]} && !${FindItem[${${Types}${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} is marked as an item and not in inventory.
				}
			/if (${${Types}Gem${x}.Equal[alt]} && !${Me.AltAbility[${${Types}${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} is marked as an AA, you don't appear to have.
				}
		/next x
		}		
	/return	

sub check_who_has(string _sender, string _verbage)
	| Credit = LamaHerder, exspes007
	/declare _slot          int local
	/declare _augslot    int local
	/declare _bagslot    int local

	/if (${FindItem[${_verbage}].ID} && !${FindItem[${_verbage}].Type.Equal[Augmentation]}) {
		/call AnnounceMessage "${ChatChannel}" 2 m "${FindItem[${_verbage}]}" y ": Item Inventory"
		} else /if (${FindItemBank[${_verbage}].ID} && !${FindItemBank[${_verbage}].Type.Equal[Augmentation]}) {
		/call AnnounceMessage "${ChatChannel}" 2 m "${FindItemBank[${_verbage}]}" y ": Item Bank"
		}
	| augment search   
	| worn inventory skip powersource (21) unless your powersource does something mine doesn't?
	/for _slot 0 to 22
		/if (${_slot} == 21) /goto :noWornItemAug
		/for _augslot 0 to ${Me.Inventory[${_slot}].Augs}
			/if (${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name}" g ": Worn Augment in" y "${Me.Inventory[${_slot}].Name}" g ":item is worn"
				/return
				}
		/next _augslot
		:noWornItemAug
	/next _slot         
	| bag inventory
	/for _slot 23 to 32
    | top slot augs
		/if (${Me.Inventory[${_slot}].Name.Equal[${_verbage}]}) /call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Name}" g ": Inventory Augment in" y "${Me.Inventory[${_slot}].Name}" g ":in a top inventory slot"
	| top slot item   with augs
		/if (${Me.Inventory[${_slot}].Augs}) {
			/for _augslot 0 to ${Me.Inventory[${_slot}].Augs}
				/if (${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name}" g ": Inventory Item Augment in" y "${Me.Inventory[${_slot}].Name}" g ":in a top inventory slot"
				/return
				}
			/next _augslot
			}
	| inside bags
		/if (${InvSlot[${_slot}].Item.Container}) {
         /for _bagslot 1 to ${InvSlot[${_slot}].Item.Container}
            /if (${Me.Inventory[${_slot}].Item[${_bagslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Item[${_bagslot}].Name}" g ": Inventory Item in" y  "${Me.Inventory[${_slot}].Name}" g ":in my bags"
				/return
				}
            | augmented items inside bags
            /if (${Me.Inventory[${_slot}].Item[${_bagslot}].Augs}) {
               /for _augslot 0 to ${Me.Inventory[${_slot}].Item[${_bagslot}].Augs}
					/if (${Me.Inventory[${_slot}].Item[${_bagslot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
					/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Item[${_bagslot}].AugSlot[${_augslot}].Name}" g ": Inventory Item Augment in" y "${Me.Inventory[${_slot}].Item[${_bagslot}].Name}" g ":in my bags"
					/return
					}
               /next _augslot   
            }
         /next _bagslot
      }
   /next _slot 
   :exit
/return		
	
Sub ClassStuffCombat
|	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/if (${Defined[QM]}) {
			/if (${QM}) {
				/call QuietMiracle 
				}
			}
		/if (${Defined[DoRetort]}) {
			/if (${DoRetort}) {
				/call Retort
				}
			}
		/if (${Defined[DoWard]}) {
			/if (${DoWard}) {
				/call Ward
				}
			}
		/if (${Defined[UseDelayedHeal]}) {
			/if (${UseDelayedHeal} && ${Bool[!${DoDelayedTimer}]}) {
				/call DelayedHeal
				}
			}
		}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${DoDichotomic}) {
			/if (${Me.Casting.ID} && !${Cast.Timing}) /squelch /twist off
			/call DichotomicPsalm
			}
		}	
	/if (${Me.Class.ShortName.Equal[DRU]}) {
		/if (${DoWoW} && ${Me.AltAbilityReady[Wrath of the Wild]}) {
			/call DoWoW
			}
		/if (${UseDelayedHeal} && !${DoDelayedTimer}) {
			/call DelayedHeal
			}
		}
	/if (${Me.Class.ShortName.Equal[ENC]}) {
		/if (${Defined[QM]}) {
			/if (${QM}) {
				/if (${Me.AltAbilityReady[Fundament: Second Spire of Enchantment]})
				/if (${Cast.Ready[${InvSlot[chest].Item.Name}]}) /casting "${InvSlot[chest].Item.Name}"
				}
			}
		}
	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/if (${UseDelayedHeal} && !${DoDelayedTimer}) {
			/call DelayedHeal
			}
		}
	/if (${Me.Class.ShortName.Equal[BST]}) { 
		/if (${QM}) {
			/call ParagonOfSpirit 
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Capacity].RankName}]}]}) {
			/call Cast "${Spell[Gather Capacity].RankName}" Gem${Me.Gem[Gather Capacity]} 5 SpellFiller 3
			}	
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Potential].RankName}]}]}) {
			/call Cast "${Spell[Gather Potential].RankName}" Gem${Me.Gem[Gather Potential]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Capacity].RankName}]}]}) {
			/call Cast "${Spell[Gather Capacity].RankName}" Gem${Me.Gem[Gather Capacity]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Magnitude].RankName}]}]}) {
			/call Cast "${Spell[Gather Magnitude].RankName}" Gem${Me.Gem[Gather Magnitude]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<20 && ${Me.AltAbilityReady[Mana Reserve]}) {
			/call Cast "Mana Researve" ALT 5 SpellFiller 3
			}
		}
	/if (${Select[${Me.Class.ShortName},MAG]}) {
		/if (${Me.Pet.ID} && ${SelfPetHealing}) {
			/call PetHealing
			}
		/if (${Me.Pet.ID} && ${PetDelayedHealing}) {
			/call PetDelayedHealing
			}
		}
	/return


	
Sub ClassStuffRest	
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/if (${QM}) {
			/call QuietMiracle
			}
		}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${DoRally}) {
			/call RallyingCall
			}
		}
	/if (${Me.Class.ShortName.Equal[BST]}) { 
		/if (${QM}) {
			/call ParagonOfSpirit
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Potential].RankName}]}]}) {
			/call Cast "${Spell[Gather Potential].RankName}" Gem${Me.Gem[Gather Potential]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Capacity].RankName}]}]}) {
			/call Cast "${Spell[Gather Capacity].RankName}" Gem${Me.Gem[Gather Capacity]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Magnitude].RankName}]}]}) {
			/call Cast "${Spell[Gather Magnitude].RankName}" Gem${Me.Gem[Gather Magnitude]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<20 && ${Me.AltAbilityReady[Mana Reserve]}) {
			/call Cast "Mana Researve" ALT 5 SpellFiller 3
			}
		/if (!${Me.Pet.Primary} && ${Me.Pet.ID} && ${DoPetToys}) {
			/call PetToys ${Me.Pet.ID}
			}
		/if (${Me.Pet.ID} && ${SelfPetHealing}) {
			/call PetHealing
			}
		/if (${Me.Pet.ID} && ${PetDelayedHealing}) {
			/call PetDelayedHealing
			}
		}
	/call AutoSit
	/return

	
Sub DelayedHeal
	/if (${Select[${Me.Class.ShortName},MNK,NEC,SHD,WAR,ROG,ENC,BRD,WIZ,BER]}) /return
	/if (${DoDelayedTimer}) /return
	/if (!${Me.Gem[${Spell[${DelayedHeal}].RankName}]}) {
		/memspell ${DelayedHealGem} "${Spell[${DelayedHeal}].RankName}"
		/return
		}
	/if (${DebugHeal}) {
		/echo Delayed called, test1	
		}
	/if (!${RDPause} && ${MainTankID} && ${Spawn[ID ${MainTankID}].PctHPs}<${DelayedHealPct} && ${Me.SpellReady[${Spell[${DelayedHeal}].RankName}]} && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${DelayedHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${DelayedHealID}].Mana}) {
		/if (${DebugHeal}) {
			/echo Delayed check passed, test2
			}
		/invoke ${Spawn[${MA1}].DoTarget}
		/if (${Bool[!${Target.Buff[${DelayedHeal}].ID}]}) {
			/call Cast "${Spell[${DelayedHeal}].RankName}" ${DelayedHealGem} 2s Check4Pad
			/if (${DebugHeal}) {
				/echo casting "${Spell[${DelayedHeal}].RankName}" ${DelayedHealGem} , test 3
				}
			/if (${castReturn.Equal[CAST_SUCCESS]}) {
				/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ has Delayed Heal" t "${Spell[${DelayedHeal}].RankName}"
				}
			/varcalc DoDelayedTimer 3+10*${Spell[${DelayedHealID}].Duration.TotalSeconds}
			} else {
			/varcalc DoDelayedTimer 2+10*${Target.BuffDuration[${DelayedHeal}].TotalSeconds}
			}
		}
	/varset castReturn CAST_CANCELLED
	/if (${DebugHeal}) {
		/echo leaving Delayed routine
		}
	/return
	
Sub AddMaster(Master)
	/if (${Debug}) /echo \ag Entering \ao Masterlist sub
	/if (${Ini[RDCommon.ini,Settings,Masterlist].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 1
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist2].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 2
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList2"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist3].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 3
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList3"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist4].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 4
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList4"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist5].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 5
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList5"
		/return
		}
	/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}>350 && ${MasterList5.Length}>350) {
		/if (${Debug}) /echo all masterlists full
		/call AnnounceMessage "${ChatChannel}" ${ChatChannel} 3 m ${Master} r "NOT added," y MasterList is full
		/return
		}		
	/if (!${Ini[RDCommon.ini,Settings,Masterlist].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist2].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist3].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist4].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist5].Find[${Master}]}) {
		/if (${MasterList.Length}<350) /ini RDCommon.ini Settings Masterlist ${MasterList}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}<350) /ini RDCommon.ini Settings Masterlist2 ${MasterList2}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}<350) /ini RDCommon.ini Settings Masterlist3 ${MasterList3}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}<350) /ini RDCommon.ini Settings Masterlist4 ${MasterList4}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}>350 && ${MasterList5.Length}>350) /ini RDCommon.ini Settings Masterlist5 ${MasterList5}${Master}|

		/call AnnounceMessage ${ChatChannel} 3 m ${Master} g "added to the" y MasterList
		/delay 2s
		/call LoadVar Settings MasterList "Put your list of master bots here" MasterList "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList2 "Put your list of master bots here" MasterList2 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList3 "Put your list of master bots here" MasterList3 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList4 "Put your list of master bots here" MasterList4 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList5 "Put your list of master bots here" MasterList5 "RDCommon.ini" ${Function} string
		} else {
		/call AnnounceMessage ${ChatChannel} 4 m ${Master} r "NOT ADDED" g "to the" y MasterList
		}

	/return	

Sub AddToMobList(int NPCID)
	/if (${Debug}) /echo \ag Entering \ao AddToMobList sub
	/if (!${PetID} && ${DoCharm} && ${Spawn[${NPCID}].Level}<=${MaxCharmLvl}) {
		/varset PetID ${NPCID}
		}
	/declare e int local
	/declare b int local
	/for e 1 to ${MaxMobs}
		/if (!${Bool[${e}]}) /next e
		/if (${Debug}) /echo Add Mob to List first \ag for \ao loop a = \ay ${e} \ao bool = \ag ${Bool[${e}]} \ao moblist = ${MobList[${e}]}
		/if (!${MobList[${e}]}) {
			/varcalc VarNPCCount ${VarNPCCount}+1
			/varset MobList[${e}] ${NPCID}
			/for b 1 to ${DebuffTotal}
				/if (${Debug}) /echo Add Mob to list second \ag for \ao loop b = \ay ${b}
				/varset DebuffArray[${e},${b}] ${Macro.RunTime}
			/next b
			/return
		}
	/next e
	/if (${Debug}) /echo \am Exiting AddToMobList
	/return	

Sub AddToQueue(int Buffee,int BuffNumber)
	/if (${Debug}) /echo \ag Entering \ao AddToQueue sub
	/declare a           int local 1
	/declare Compare     int local 0
	/if (!${RestrictedList.Find[|${DoBuffID[${BuffNumber}]}|]} && ${QueueCount}<25 && !(${Spawn[${Buffee}].Type.Equal[corpse]} ^^ ${RezBuff${BuffNumber}}) && ${Spawn[${Buffee}].ID}) {
		/if (${Debug}) {
			/echo First check: \ay Restricted List = \ag !${RestrictedList.Find[|${DoBuffID[${BuffNumber}]}|]} 
			/echo QueCount is \ag ${QueueCount}<25 \ao Buffee is not a corpse = ${Spawn[${Buffee}].Type.NotEqual[corpse]}
			/echo Rez buff number = \ag ${RezBuff${BuffNumber}} 
			/echo Buff ${BuffNumber}, Bufee is \am ${Spawn[${Buffee}].CleanName} \ao and ID is \am ${Spawn[${Buffee}].ID}
			}
		/varset Compare 0
		/for a 1 to 25
		/if (${Debug}) {
			/echo For loop a = \ag ${a}
			}
		/if ((${Buffee}==${DoBuffQueue[${a},1]} || (${Select[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} && (${Group.Member[${Spawn[${Buffee}].CleanName}].Index} || ${Group.Member[${Spawn[${Buffee}].Master.CleanName}].Index}) && ${Group.Member[${Spawn[${DoBuffQueue[${a},1]}].CleanName}].Index})) && ${BuffNumber}==${DoBuffQueue[${a},2]}) {
			/varset Compare 1
			}
		/if (${Debug}) {
			/echo does buffee equal queue? \ag ${Buffee}==${DoBuffQueue[${a},1]}
			/echo is the buff a group spell? \ag ${Select[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} \ao and buff a group member? \ay ${Group.Member[${Spawn[${Buffee}].CleanName}].Index}
			/echo if the bufee a pet is it's master in the group? \ag  ${Group.Member[${Spawn[${Buffee}].Master.CleanName}].Index}
			/echo does the buffnumber equal the queue? \ag ${BuffNumber}==${DoBuffQueue[${a},2]}
			}
		/next a
		/if (!${Compare}) {
			/for a 1 to 25
				/if (!${DoBuffQueue[${a},1]}) {
					/varset DoBuffQueue[${a},1] ${Buffee}
					/varset DoBuffQueue[${a},2] ${BuffNumber}
					/varcalc QueueCount ${QueueCount}+1
					/return
				}
			/next a
		}
	}
	/if (${Debug}) /echo \am Exiting AddToQueue
	/return
	
Sub AnnounceMessage(Channel, EventTotal, Color1, Event1, Color2, Event2, Color3, Event3, Color4, Event4, Color5, Event5,)
	/if (${Channel.Equal[NULL]}) /return
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[1]}) /BC [+${Color1}+] ${Event1}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[2]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[3]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[4]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3} [+${Color4}+] ${Event4}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[5]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3} [+${Color4}+] ${Event4} ${Event5}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[1]}) /${Channel} ${Event1}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[2]}) /${Channel} ${Event1} ${Event2} 
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[3]}) /${Channel} ${Event1} ${Event2} ${Event3} 
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[4]}) /${Channel} ${Event1} ${Event2} ${Event3} ${Event4}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[5]}) /${Channel} ${Event1} ${Event2} ${Event3} ${Event4} ${Event5}
	/return	
	
Sub AssistLoop
	/if (${RDPause}) /return
	/declare i int local
	/if (${UseGroupMA} && ${Group.Members} && ${Group.MainAssist.ID}) {
		|If we have GroupAssist and group assist is a valid target get it.
		/if (${Me.GroupAssistTarget.ID} && (${Me.GroupAssistTarget.Type.Equal[NPC]} || ${Me.GroupAssistTarget.Master.Type.Equal[npc]}) && ${Me.GroupAssistTarget.ID}!=${MATarget} && ${Me.GroupAssistTarget.Type.NotEqual[corpse]}) {
			/varset MATarget ${Me.GroupAssistTarget.ID}
			/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			/varset AssistTimer ${AssistDelay}
			/if (${Debug}) {
				/echo MATarget ${MATarget}
				/echo Me.GroupAssistTarget.ID ${Me.GroupAssistTarget.ID}
				}
			/return
		}
		|If we had a valid MATarget then stay with it.
		/if (${Spawn[${MATarget}].ID} && !${Spawn[${MATarget}].Type.Equal[corpse]}) {
			/if (${Debug}) /echo we had a valid MATarget then stay with it.
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|Else we reset the MA
		/varset MATarget 999999
		/varset AssistTimer ${AssistDelay}
		/return
	}
	/if (${UseRaidMA} && !${UseGroupMA} && ${Raid.Members}>1 && ${Raid.MainAssist.ID}) {
		|If we have RaidAssist and Raid Assist's target is a valid target, get it.
		/if (${Me.RaidAssistTarget[1].ID} && (${Me.RaidAssistTarget[1].Type.Equal[NPC]} || ${Me.RaidAssistTarget[1].Master.Type.Equal[npc]}) && ${Me.RaidAssistTarget[1].ID}!=${MATarget} && ${Me.RaidAssistTarget[1].Type.NotEqual[corpse]}) {
			/varset MATarget ${Me.RaidAssistTarget[1].ID}
			/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|If we had a valid MATarget then stay with it.
		/if (${Spawn[${MATarget}].ID} && !${Spawn[${MATarget}].Type.Equal[corpse]}) {
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|Else we reset the MA
		/varset MATarget 999999
		/varset AssistTimer ${AssistDelay}
		/return
	}	
	/for i 1 to 3
		/if (${Spawn[${MA${i}} radius 150 zradius 50].ID} && !${UseRaidMA} && !${UseGroupMA}) {
			/if (${Me.CleanName.NotEqual[${MA${i}}]}) /call AssistStuff ${i}
			/if ((${Target.Type.Equal[NPC]} || ${Target.Master.Type.Equal[npc]}) && ${Target.ID}!=${MATarget} && ${Target.Type.NotEqual[corpse]}) {
				/varset MATarget ${Target.ID}
				/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			}
			/varset AssistTimer ${AssistDelay}
			/return
		}
	/next i
	/varset MATarget 999999
	/varset AssistTimer ${AssistDelay}
	/return

Sub AssistMA1
	| if we are not assisting, set the MATarget to our target
	| unless someone set it for us...
	/if (${Spawn[${MA1}].ID}==${Me.ID}) /return
	/if (${RDPause}) /return
	/if (!${RDPause} && !${AssistTimer}) {
		/call AssistLoop
		}	
	/if (!${AssistMA} && !${RDPause}) {
		/if (${TargetLock}) {
			/if (${MATarget}!=999999 && ${Spawn[${MATarget}].ID} && ${Target.ID}!=${MATarget} && ${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${Bool[${Spawn[${MATarget}].Type.NotEqual[PC]}]}) {
				/target targetable id ${MATarget}
				/delay 1s ${Target.ID}==${MATarget}
				} else {
				/varset MATarget ${Target.ID}
				/if (!${MATarget}) /varset MATarget 999999
				}
			}
		/call MoveStuff
		/return
		}
|	/if (!${RDPause} && (!${AssistTimer} || !${Spawn[${MATarget}].ID} || ${Spawn[${MATarget}].Type.Equal[corpse]})) {
|		/call AssistLoop
|		}
	/if (${Spawn[${MATarget}].Type.Equal[Corpse]}) {
		/varset MATarget 999999
		/return
		}
	/call MoveStuff
	/return	
	
Sub AssistStuff(int i)
	/if (${RDPause}) /return
	/declare OldTarget int local ${Target.ID}
	/if (${Spawn[${MA${i}}].ID}==${Me.ID}) /return
	/if (!${RDPause} && ${Target.ID} && (!${Melee.Combat} || ${Target.ID}!=${MATarget})) {
		/varset OldTarget NULL
|		/squelch /target clear
		}
	/delay 1s !${Target.ID} || ${Melee.Combat}
	/assist ${Spawn[${MA${i}}].CleanName}
	/delay 5s ${Target.ID}!=${OldTarget} && ${Me.AssistComplete}==TRUE
/return	

Sub AutoSit	
	/if (${RDPause}) /return
	/declare i int local
	/declare TempGuy int local
	/if (!${RDPause}) {
		/if (${MakeCamp.Status.Equal[ON]} && ${MakeCamp.CampDist}>20) /makecamp return
		/delay 30s !${Me.Moving}
		/if (${Me.PctMana}==100 && !${Bool[${Select[${Me.Class.ShortName},MNK,WAR,BER,ROG]}]}) {
			/if (${ReportFM}) /call AnnounceMessage "${ChatChannel}" 3 g "Mana at" t "${Me.PctMana}" g "GTG boss!"
			/varset ReportFM FALSE
			}
		/if (${Select[${Me.Class.ShortName},WIZ,SHM,NEC,MAG,ENC,CLR,BST]} && ${Defined[CanniTotal]} && ${Defined[MedPct]})	{
			/if (${DoCanni}) {
				/if (!${Defined[CanniTotal]}) /call AnnounceMessage "${ChatChannel}" 3 r WARNING g CanniTotal y "is not defined, check INI"
				/if (!${Defined[MedPct]}) /call AnnounceMessage "${ChatChannel}" 3 r WARNING g MedPct y "is not defined, check ini"
				/if (!${Defined[CanniTotal]} || !${Defined[MedPct]}) /goto :skipcanni
				/if (${Defined[CanniTotal]} && ${Defined[MedPct]} && ${CanniTotal} && !${Me.Casting.ID} && ${Me.PctMana}<${MedPct} && !${Me.Invis}) {
					/for i 1 to ${CanniTotal}
					/if (((${Me.SpellReady[${Spell[${CanniSpell${i}}].RankName}]} || (!${Me.Gem[${CanniSpell${i}}]} && ${Spell[${CanniSpell${i}}].RankName.ID})) || ${Me.AltAbilityReady[${CanniSpell${i}}]} || (${CanniGem${i}.Equal[item]} && !${FindItem[${CanniSpell${i}}].Timer})) && ${Me.PctHPs}>${CanniHPs${i}} && ${Me.PctMana}<${CanniMana${i}} && !${Me.Buff[${CanniSpell${i}}].ID}) /call Cast "${CanniSpell${i}}" ${CanniGem${i}} 10s Check4Pad
					/if (${Me.Class.ShortName.Equal[WIZ]} && ${Me.Buff[${CanniSpell${i}}].ID}) /delay 19s !${Me.Buff[${CanniSpell${i}}].ID}
					/if (${Me.Buff[${CanniSpell${i}}].ID} && ${Me.PctHPs}<${CanniHPs${i}}) /nomodkey /notify BuffWindow buff${Me.Buff[${CanniSpell${i}}].ID} leftmouseup
					/if (!${Me.Buff[${CanniHealSpell}].ID} && ${Me.PctHPs}<${CanniHealHPs}) {
						/squelch /target targetable id ${Me.ID}
						/delay 1s ${Target.ID}==${Me.ID}		 		 		 		 
						/if (${Target.ID}==${Me.ID}) /call Cast "${CanniHealSpell}" ${CanniHealGem} 10s Check4Pad
						}
					/delay 10s !${Me.Casting.ID}
					/next i
					}
				}
			}
			:skipcanni
		/if (${Select[${Cursor.ID},3426,6346,18745,52674,52709,52803,52817,52888,57264,64951,76502,76503,79320,79321,79322,17574]}) {
			/if (${Me.FreeInventory}<=1 || ${Select[${Me.Class.ShortName},MNK,WAR,BER,ROG]}) {
				/call AnnounceMessage "${ChatChannel}" 3 y "I don't have enough free space for this mod-rod" w "(or I'm not a caster)" r "so I'm destroying it."
				/destroy
				}
			/autoinv	
			}
		/if (${Defined[QM]}) {
			/if (${QM} && !${Me.Invis}) /call QuietMiracle
			}
	|	/if (${DoYaulp} && !${Me.Buff[${YaulpSpell}].ID} && ${Spell[${YaulpSpell}].Stacks[0]} && (${Me.SpellReady[${Spell[${YaulpSpell}].RankName}]} || !${Me.Gem[${Spell[${YaulpSpell}].RankName}]}) && !${Me.Casting.ID} && ${Me.PctMana}<${MedPct} && !${Me.Mount.ID} && ((${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]} && ${NearestSpawn[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1].LineOfSight}) || !${AutoSit})) /call Cast "${YaulpSpell}" ${YaulpGem} 10s SpellFiller 3 
		/if (${Defined[GatherPct]}) {
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${FindItem["Azure Mind Crystal"].ID} && !${FindItem["Azure Mind Crystal"].Timer}) /useitem "Azure Mind Crystal"
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${Me.AltAbilityReady[Mana draw]}) /call Cast "Mana draw" alt 10s SpellFiller 3
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${Me.AltAbilityReady[Gather Mana]}) /call Cast "Gather Mana" alt 10s SpellFiller 3
			}
		/if (${Defined[MedPct]} || ${Defined[EndMedPct]}) {
			/if (!${Me.Casting.ID} && !${Me.Invis} && (${Me.PctMana}<${MedPct} || ${Me.PctEndurance}<${EndMedPct}) && !${Me.Mount.ID} && !${Melee.Combat} && !${Me.Buff[${YaulpSpell}].ID}) {
				/if (${UseMount} && !${Me.FeetWet} && !${RestrictedList.Find[|NoMount|]}) {
					/doevents flush Restricted
					/call Cast "${MountItem}" item 10s Check4Pad
					/call DoRestrictedEvents NoMount
					}
				/if (${AutoSit} && !${Me.AutoFire} && !${SitTimer} && ${Me.Standing} && ${Me.CombatState.Equal[ACTIVE]} && (!${SpawnCount[npc targetable radius ${ASRadius} zradius ${ASZRadius} noalert 1]} || (${Me.PctAggro}<60)) && (${Stick.Status.NotEqual[ON]} || ${Spawn[id ${FollowGuy}].Distance}<${LeashDistance})) {
					/if (${Me.Class.ShortName.Equal[BRD]}) {
						/if  (${Twist.Twisting} && (${Me.PctMana}<${MedPct} || ${Me.PctEndurance}<${EndMedPct}) && !${Me.Mount.ID} && !${Melee.Combat}) /squelch /twist off
						}
					/sit
					/varset SitTimer ${SitDelay}
					}
				}
			}
		}
	/return
	
Sub FranticHeal
	/target targetable id ${Spawn[$MA1]}.ID}
	/if (${Me.SpellReady[${FranticHeal}]}) {
		/call Cast "${FranticHeal}" ${FranticHealGem} 2s SpellFiller 3
		/if (${ReportHeals} && ${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage "${HealChannel}" 4 y "Frantic Heal" m "-> ${Target.CleanName} <-" g "with" t "${FranticHeal}"
		} else {
		/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 y "ACK!" t "${FranticHeal}" r "IS NOT CAST" y "because it is not ready!"
		}
	/return

Sub BegFrantic
	/if (${FranticSpamTimer}>0) {
		/return
		} else {
		/call AnnounceMessage "${ChatChannel}" 1 y "Frantic Heal NOW!" 
		/varset FranticSpamTimer 10s
		}
	/return

Sub BreakInvis
	/varset TravelMode FALSE
	/squelch /makemevisible
	/delay 10s !${Me.Invis}
	/return

Sub CalmGroup(Puller)
	/declare oldTarget int local 0
	/declare i int local 1
	/declare tempTarget int local 0
	/declare centerMob int local 0
	/declare casted int local 0
	/if (${Spawn[${Puller}].ID} && ((${FindItem[${CalmSpell}].ID} && ${CalmGem.Equal[item]}) || (${CalmGem.Equal[alt]} && ${Me.AltAbilityReady[${CalmSpell}]}) || ${Spell[${CalmSpell}].RankName.ID})) {
			/if (${Puller}!=${Me.ID}) {
			/squelch /target targetable id ${Puller}
			/delay 1s ${Target.ID}==${Puller} && ${Me.AssistComplete}==TRUE
			/assist
			/delay 1s ${Target.ID}!=${Puller} && ${Me.AssistComplete}==TRUE
		}
		/varset centerMob ${Target.ID}
		/while (${casted}<4 && ${Spawn[${centerMob}].NearestSpawn[${i},npc targetable radius 40 zradius 50 range 1 ${MaxCalmLvl} noalert 1].ID})
			/varset tempTarget ${Spawn[${centerMob}].NearestSpawn[${i},npc targetable radius 40 zradius 50 range 1 ${MaxCalmLvl} noalert 1].ID})
			/squelch /target targetable id ${tempTarget}
			/delay 1s ${Target.ID}==${tempTarget}
			/call Cast "${CalmSpell}" ${CalmGem} 3s Check4Pad 3		 
			/if (${castReturn.Equal[CAST_IMMUNE]} && ${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /call AnnounceMessage "${DebuffChannel}" 3 w "${Target.CleanName" r "is Immune to" y "${CalmSpell}"
			/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /call AnnounceMessage "${ChatChannel}" 2 y "${Target.CleanName}" g "is calmed" 
            /if (${castReturn.Equal[CAST_RESIST]}) {
				/if (${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /${DebuffChannel} ${Target.CleanName} ressisted calm
				/varset casted -1
				/break
			}
			/varcalc casted ${casted}+1		 		 
			/varcalc i ${i}+1		 
		/endwhile
		/if (${casted}==-1 && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 y "Calm not properly done" 
		/if (${casted} && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 g "Calm done pull away" 
		/if (!${casted} && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 y "No mobs to calm"
	}
	/return
	
Sub Check4Pad(int spellID)
|	/if (${Cursor.ID}) /autoinventory
	/IF (${RDPause}) /return
	/if (${DoMez}) /doevents MezIt
	/if (!${RDPause}) {
		/if (${DoMez} || ${DoCharm}) {
			/if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
				/if (!${Meztimer}) {
					/if (!${CheckGroupTimer} && ((${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID})) && ${Meztimer}<10) /call CheckMez ${spellID}
					/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount}) {
						/call CheckMez ${spellID}
						/call PopulateNPCs
						}
					}
				}
			}
		}		
	/if (${Select[${Me.Class.ShortName},MNK,NEC,SHD,WAR,ROG,ENC,BRD,WIZ,BER,MAG]}) /return
	/if (!${RDPause}) {
		/if (${UseCH} && ${MainTankID}) {
|			/call CheckPPS
			/if (${Spawn[ID ${MainTankID}].Type.NotEqual[corpse]} && ${Spawn[ID ${MainTankID}].PctHPs}<${TankHealPct} && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${TankHealID}].Mana}) /call DoHeal ${MainTankID} Tank
			}
		/if (${HealXTarget} && !${RDPause} && ${Me.XTarget}) /call HealXTarget
		/if (${HealGroup}) {
			/call ${EvaluateFunction}
			/if (${Spawn[ID ${WorstID}].Type.NotEqual[corpse]} && ${WorstHPs}<${HealPct} && ${Me.CurrentMana}>${Spell[${FastHealID}].Mana} && (${Bool[${Plugin[MQ2Netheal]}]} || !${DAArray[${WorstMember},2]})) /call DoHeal ${WorstID} Fast
			}
		}
	/doevents ImHit
	/return


Sub CheckBuffs
	/if (${DebugSelfBuff}) /echo \ag Entering \ay CheckBuffs
	/if (${Me.Moving} || ${Melee.Combat} || (${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[Corpse]})) /return
	/declare BuffAuthorize bool local false
	/if (${Cursor.ID}) /autoinventory
	/if (!${RDPause}) {
		/declare SelfBuffSpells int local 1
		/declare a int local
		/for SelfBuffSpells 1 to ${SelfBuffTotal}
			/if (!${Range.Between[1,${SelfBuffTotal}:${Int[${SelfBuffSpells}]}]}) /continue
			/if (${RDPause}) /break
			/if (${DebugSelfBuff}) /echo Self Buff Spell is \ag ${SelfBuff${SelfBuffSpells}}
	|-----Check to be sure your toon has the DoBuff spell, item, or AA	
			/if (!${Select[${SelfBuffGem${SelfBuffSpells}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${SelfBuff${SelfBuffSpells}}].RankName}]}].ID}) /multiline ; /echo \ar SelfBuff -${SelfBuffSpells}- ${SelfBuff${SelfBuffSpells}} not in spellbook. ; /continue
			/if (${SelfBuffGem${SelfBuffSpells}.Equal[item]} && !${FindItem[${SelfBuff${SelfBuffSpells}}].ID}) /multiline ; /echo \ar SelfBuff -${SelfBuffSpells}- ${SelfBuff${SelfBuffSpells}} is marked as an item and not in inventory. ; /continue
			/if (${SelfBuffGem${SelfBuffSpells}.Equal[alt]} && !${Me.AltAbility[${SelfBuff${SelfBuffSpells}}].ID}) /multiline ; /echo \ar SelfBuff -${SelfBuffSpells}- ${SelfBuff${SelfBuffSpells}} is marked as an AA, you don't appear to have. ; /continue
	|-----
			/if ((${Me.CurrentMana}<${Spell[${SelfBuff${SelfBuffSpells}}].Mana} && !${Select[${SelfBuffGem${SelfBuffSpells}},alt,item,comb]}) || (${Select[${SelfBuffGem${SelfBuffSpells}},comb]} && ${Me.Endurance}<200)) {
				/if (${DebugSelfBuff}) {
					/echo not enough mana or endurance
					/echo \am Exiting \ay Checkbuffs
					}
				/continue
				}
			/if (${DebugSelfBuff}) /echo Am I feigned? \ag ${Me.State.Equal[FEIGN]}
			/if (${Me.State.NotEqual[FEIGN]}) {
				/if (${DebugSelfBuff}) /echo Is the buff on the restricted list? \ag ${Bool[${RestrictedList.Find[|${SelfBuffID[${SelfBuffSpells}]}|]}]} 
				/if (!${RestrictedList.Find[|${SelfBuffID[${SelfBuffSpells}]}|]}) {
					/if (${DebugSelfBuff}) {
						/echo Sit Timer? \ag ${SitTimer}
						/echo Is the buff already loaded? \ag ${Bool[${Me.Gem[${SelfBuff${SelfBuffSpells}}]}]}
						/echo Am I mounted? \ag ${Bool[${Me.Mount.ID}]}
						}
					/if (!${SitTimer} || ${Me.Gem[${SelfBuff${SelfBuffSpells}}]} || ${Me.Mount.ID}) {
						/if (${DebugSelfBuff}) {
							/echo Is the Self Buff an Aura? \ag ${SelfBuffAura${SelfBuffSpells}} 
							/if (${SelfBuffAura${SelfBuffSpells}}) /echo Am I missing the Aura? \ag ${Bool[!${Bool[${Me.Aura[${SelfBuffIcon${SelfBuffSpells}}]}]}]}
							}
						/if (${SelfBuffAura${SelfBuffSpells}} && !${Bool[${Me.Aura[${SelfBuffIcon${SelfBuffSpells}}]}]}) {
							/varset BuffAuthorize TRUE
							}
						/if (!${SelfBuffAura${SelfBuffSpells}}) {
							/if (${DebugSelfBuff}) /echo My buffcount below the INI listed buff count limit? \ag ${Me.CountBuffs}<${SelfBuffCount${SelfBuffSpells}} 
							/if (${Me.CountBuffs}<${SelfBuffCount${SelfBuffSpells}}) {
								/if (${DebugSelfBuff}) {
									/echo Does the spell stack with my current buffs? \ag ${Spell[${SelfBuffIcon${SelfBuffSpells}}].Stacks[0]}
									/echo Is the Self Buff Icon missing from my buff window? \ag ${Bool[!${Me.Buff[${SelfBuffIcon${SelfBuffSpells}}].ID}]}
									/echo Is the Self Buff Icon missing from my song window? \ag ${Bool[!${Me.Song[${SelfBuffIcon${SelfBuffSpells}}].ID}]}
									}
								/if (${Spell[${SelfBuffIcon${SelfBuffSpells}}].Stacks[0]} && !${Me.Buff[${SelfBuffIcon${SelfBuffSpells}}].ID} && !${Me.Song[${SelfBuffIcon${SelfBuffSpells}}].ID}) {
									/if (${DebugSelfBuff}) {
										/if (${Bool[!${Select[${SelfBuffGem${SelfBuffSpells}},item,alt,comb]}]}) /echo Buff is a spell
										/if (${SelfBuffGem${SelfBuffSpells}.Equal[item]}) /echo Buff is an item, is the item ready? \ag ${Bool[!${FindItem[${SelfBuff${SelfBuffSpells}}].Timer}]}
										/if (${SelfBuffGem${SelfBuffSpells}.Equal[alt]}) /echo Buff is an ALT, is it ready? \ag ${Me.AltAbilityReady[${SelfBuff${SelfBuffSpells}}]} 
										/if (${SelfBuffGem${SelfBuffSpells}.Equal[comb]}) /echo Buff is a Discipline, is it ready? \ag ${Me.CombatAbilityReady[${SelfBuff${SelfBuffSpells}}]}
										}
									/if (${Me.CurrentMana}>${Spell[${SelfBuff${SelfBuffSpells}}].Mana} && !${Select[${SelfBuffGem${SelfBuffSpells}},item,alt,comb]}) {
										/varset BuffAuthorize TRUE
										}
									/if (${SelfBuffGem${SelfBuffSpells}.Equal[item]} && !${FindItem[${SelfBuff${SelfBuffSpells}}].Timer}) {
										/varset BuffAuthorize TRUE
										}
									/if (${SelfBuffGem${SelfBuffSpells}.Equal[alt]} && ${Me.AltAbilityReady[${SelfBuff${SelfBuffSpells}}]}) {
										/varset BuffAuthorize TRUE
										}
									/if (${SelfBuffGem${SelfBuffSpells}.Equal[comb]} && ${Me.CombatAbilityReady[${SelfBuff${SelfBuffSpells}}]}) {
										/varset BuffAuthorize TRUE
										}
									}
								}
							}
						}
					}
				}
				/if (!${BuffAuthorize}) {
					/if (${DebugSelfBuff}) /echo Am I authorized to buff? \ag ${BuffAuthorize}
					/continue
					}
				/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
				/if (${Select[${Spell[${SelfBuffID[${SelfBuffSpells}]}].TargetType},pc,Single]} || (${Me.Class.ShortName.Equal[ENC]} && ${Spell[${SelfBuffID[${SelfBuffSpells}]}].Name.Find[Illusion:]})) {
					/squelch /target targetable id ${Me.ID}
					/delay 1s ${Target.ID}==${Me.ID}
					}
				/if (${ReportSelfBuffs}) /call AnnounceMessage  4 g "Buffing" o "${Spell[${SelfBuff${SelfBuffSpells}}]}" g "on" m "myself... OOH!"
				/varset SitTimer ${SitDelay}
	|-----
	|Bard Spell section
	|-----			
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${SelfBuffGem${SelfBuffSpells}},item,alt,comb]}) {
					/if (${DebugSelfBuff}) /echo Self Buff enter Bard section
					/squelch /twist stop
					/delay 5s !${Me.Casting.ID}
					/delay 1s
					/if (!${Me.Gem[${Spell[${SelfBuff1}].RankName}]}) {
						/memspell ${SelfBuffGem1.Right[-3]} "${Spell[${SelfBuff${SelfBuffSpells}}].RankName}"
						/delay 30s ${Me.SpellReady[${Spell[${SelfBuff${SelfBuffSpells}}].RankName}]}
						/if (${DebugSelfBuff}) /echo Memorizing spell
						}
					/delay 1s
					/call DoCastingEvents
					/if (${DebugSelfBuff}) /echo Twisting spell ${Spell[${SelfBuff${SelfBuffSpells}}].RankName}
					/squelch /twist once ${Me.Gem[${Spell[${SelfBuff${SelfBuffSpells}}].RankName}]}
					/delay ${Spell[${SelfBuff${SelfBuffSpells}}].MyCastTime.TotalSeconds}s
					/delay 2s
					/squelch /twist off
					/varset castReturn CAST_SUCCESS
					/call DoCastingEvents
					/squelch /twist stop
					/if (${DebugSelfBuff}) /echo \am exiting Bard section
					/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
	|-----
	| End Bard Spell section
	|-----					
				} else {
					/if (${Select[${SelfBuffGem${SelfBuffSpells}},comb]}) /disc ${SelfBuff${SelfBuffSpells}}
					/if (!${Select[${SelfBuffGem${SelfBuffSpells}},comb]}) {
						/if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]} && ${Me.Casting.ID}!=${SelfBuffID[${SelfBuffSpells}]}) /call DoInterrupt
						/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
						/doevents flush Restricted
						/squelch /target targetable id ${Me.ID}
						/if (${SelfBuffGem${SelfBuffSpells}.Equal[item]} && ${Me.HaveExpansion[Veil of Alaris]}) {
							/useitem ${SelfBuff${SelfBuffSpells}}
							/if (${ReportSelfBuffs}) /call AnnounceMessage  2 g "Clicking item" o "${SelfBuff${SelfBuffSpells}}"
							/return
							}
						/if (${Spell[${SelfBuff${SelfBuffSpells}}].RankName.ID} && ${SelfBuffGem${SelfBuffSpells}.NotEqual[ALT]} && ${SelfBuffGem${SelfBuffSpells}.NotEqual[comb]}) {
							/call Cast "${Spell[${SelfBuff${SelfBuffSpells}}].RankName}" ${SelfBuffGem${SelfBuffSpells}} 30s Check4Pad
							} else {
							/call Cast "${SelfBuff${SelfBuffSpells}}" ${SelfBuffGem${SelfBuffSpells}} 30s Check4Pad
							}
						/call DoRestrictedEvents ${SelfBuffID[${SelfBuffSpells}]}
						/if (${castReturn.Equal[CAST_SUCCESS]} && ${Select[${Spell[${SelfBuffID[${SelfBuffSpells}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) /call RemoveFromQueue 0 ${SelfBuffID[${SelfBuffSpells}]}
						/if (${castReturn.Equal[CAST_SUCCESS]}) /call RemoveFromQueue 0 ${SelfBuffID[${SelfBuffSpells}]}
						
						/if (${castReturn.Equal[CAST_UNKNOWNSPELL ]}) {
							/call AnnounceMessage "${ChatChannel"}" 2 o "${SelfBuff${SelfBuffSpells}}" r "not found"
							/call RemoveFromQueue 0 ${SelfBuffID[${SelfBuffSpells}]}
							}
						/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
							/call AnnounceMessage "${ChatChannel"}" 2 o "${SelfBuff${SelfBuffSpells}}" r "wont take hold!!"
							/call RemoveFromQueue 0 ${SelfBuffID[${SelfBuffSpells}]}
							}
						/if (${Me.Class.ShortName.Equal[BRD]}) {
							/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
							}
						}
					}
			}
		/varset BuffAuthorize FALSE
		/next SelfBuffSpells
		}
	/varset SelfBuffTimer ${SelfBuffRecheck}
	/call MoveStuff
	/if (${DebugSelfBuff}) /echo \am Exiting \ay Checkbuffs
	/return

Sub CheckDoBuffs(Sender,ChatText)
	/declare a        int local
	/declare i        int local
	/for i 1 to ${DoBuffTotal}
		/for a 1 to ${DoBuffAliases${i}.Count[|]}
			/if (${ChatText.Find["${DoBuffAliases${i}.Arg[${a},|]}"]}) {
				/if (${ChatText.Find[" pet"]} || ${ChatText.Find[${Spawn[pc "${Sender}"].Pet.CleanName}]}) {
					/call AddToQueue ${Spawn[pc ${Sender}].Pet.ID} ${i}
				} else /if (${Spawn[pc "${Sender}"].ID} && ${Spawn[corpse "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[pc ${Sender}].ID} ${i}
					/call AddToQueue ${Spawn[corpse ${Sender}].ID} ${i}
				} else /if (${Spawn[pc "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[pc ${Sender}].ID} ${i}
				} else /if (${Spawn[corpse "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[corpse ${Sender}].ID} ${i}
				}		 		 
			}
		/next a
	/next i
	/return
	
Sub CheckGroup
:StayOnHeal
	/if (!${RDPause} && ${UseCH}) {
		/if (${MainTankID} && (${Me.Gem[${TankHeal}]}) && ${Me.SpellReady[${Spell[${TankHeal}].RankName}]}) {
			/call CheckPPS
			/if ((${TankTTL}<200 || ${Spawn[ID ${MainTankID}].PctHPs}<${TankHealPct}) && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${TankHealID}].Mana}) /call DoHeal ${MainTankID} Tank
			}
		}	
	/if (!${RDPause} && ${HealGroup}) {
		/call ${EvaluateFunction}
		/if (${WorstHPs}<${HealPct} && (${Bool[${Plugin[MQ2Netheal]}]} || !${DAArray[${WorstMember},2]})) {
			/if ((${GroupHurtCount}>=${GroupHealCount}) && (${Me.CurrentMana}>${Spell[${GroupHealID}].Mana}) && (${Me.Gem[${GroupHeal}]} || ${Me.SpellReady[${Spell[${GroupHeal}].RankName}]})) {
				/call DoHeal ${WorstID} Group
			} else /if ((${Me.CurrentMana}>${Spell[${FastHealID}].Mana}) && (${Me.Gem[${FastHeal}]} || ${Me.SpellReady[${Spell[${FastHeal}].RankName}]})) {
				/call DoHeal ${WorstID} Fast
				}
		}
	}
	/if (${HealXTarget} && !${RDPause} && ${Me.XTarget}) /call HealXTarget
	/if (!${RDPause} && ${HealPets}) {
		/if ((${Me.Gem[${PetHeal}]} || ${Me.SpellReady[${Spell[${PetHeal}].RankName}]}) && ${Me.CurrentMana}>${Spell[${PetHeal}].Mana}) {
			/call EvaluatePets
			/if (${WorstHPs}<${PetHealPct}) {
				/call DoHeal ${WorstID} Pet
				}
			}
		}
	/if (${StayOnHealTimer}) /goto :StayOnHeal
	/if (${DoCures} && ${CureTotal} && !${Me.Casting.ID}) /call CureMe
	/if (${Bool[${Plugin[MQ2Debuffs]}]}) {
		/if (${Debuff}) /call Cureme
		}
	/doevents
	/if (!${RDPause}) {
		/if (${DoMez} || ${DoCharm}) {
			/if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
				/if (!${CheckGroupTimer} || ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID}))){
					/if (!${Bool[${Meztimer}]}) {
						/if (${DebugMez}) {
							/echo Calling ChekMez
							}
						/call CheckMez
						}
					}
				}
			}
		}
	/if (!${Me.Moving}) /call AutoSit
	/if (${Me.Class.ShortName.Equal[CLR]}) /call RezCheck
	/return	
	
Sub CheckHP
	/if (!${RDPause} && ${Me.Casting.ID}) {
		/if (!${SpamFlag} && ${ReportHeals} && ${Target.ID}) {
			/call AnnounceMessage "${ChatChannel}"  4 t "Healing" m "${Target.CleanName}" t "with" o "${Me.Casting}"
			/varset SpamFlag TRUE
			}
	 	/if (${HealFD} && ${Target.State.Equal["FEIGN"]} && ${Select[${Target.Class.ShortName},MNK,NEC,SHD]}) /call DoInterrupt
	 	/call ${EvaluateFunction}
		/if (${UseCH} && ${Me.Casting.ID}==${TankHealID} && ${Target.ID}==${MainTankID} && ${FastHealID}!=${TankHealID}) {
			/call CheckPPS
			/if (${Target.PctHPs}>${TankHealPct} && ${TankTTL}>250 && ${castEndTime}<40 && ${castEndTime}>=${TankTTL}+50) {
				/call Interrupt
				/call DoHeal ${Target.ID} Fast
				}
			}
|		/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${TankHealID} && ${Me.Casting.ID}!=${DelayedHealID} && ${Me.Casting.ID}!=${DivArbSpellID} && ${Target.PctHPs}>=${CancelPct} && (!${WaitToCancel} || ${castEndTime}<5)) /call Interrupt
		/if (${HealMeFirst} && ${Me.PctHPs}<=${HealPct} && ${Target.ID}!=${Me.ID}) /call DoHeal ${Me.ID} Fast
		}
	/doevents ImHit
	/return	

Sub CheckMez(int spellID)
	/if (${DebugMez}) /echo \ag ENTERING \ao CheckMez
	/declare DebuffInteger int local
	/declare MobInteger int local
	/declare DebuffSpellType int local
   |   Check if casting a charm
	/if (${spellID}) {
		/for DebuffInteger 1 to ${DebuffTotal}
			/if (${DebuffInteger}==30) /break
			/if (${SpellType${DebuffInteger}}!=5) /continue
			/if (${DebuffID[${DebuffInteger}]}==${spellID}) {
				/if (${DebugMez}) /echo \ao We are casting a charm, returning
				/return
				}
		/next DebuffInteger
		}
	/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID})) /call PopulateNPCs
	/declare canAEMez bool local FALSE
	/if (${VarNPCCount}-${VarOldNPCCount}>2) /varset canAEMez TRUE
	/for DebuffSpellType 1 to ${DebuffTotal}
		/if (${DebuffSpellType}>30) {
			/if (${DebugMez}) /echo \ag j \ao variable is over 30, breaking
			/break
			}
		/if (${DebuffSpellType}<1) {
			/if (${DebugMez}) /echo \ag j \ao j variable is under 1, breaking
			/break
			}
		/doevents
		/if (!((${SpellType${DebuffSpellType}}==2  || ${SpellType${DebuffSpellType}}==4) && ${DoMez}) && !(${SpellType${DebuffSpellType}}==5 && ${DoCharm})) /continue
		/if (${Me.Casting.ID}==${DebuffID[${DebuffSpellType}]} && ${SpellType${DebuffSpellType}}==2 && (${Target.ID}==${MATarget} || ${Target.Assist})) {
			/call DoInterrupt
			/varset castReturn X
			/return
			}
		/if (${spellID}==${DebuffID[${DebuffSpellType}]}) /return
		/for MobInteger 1 to ${MaxMobs}  
			/if (${MobInteger}>30) {
				/if (${DebugMez}) /echo \ag a \ao ariable is over 30, breaking
				/break
				}
			/if (${MobInteger}<1) {
				/if (${DebugMez}) /echo \ag a \ao variable is under 1, breaking
				/break
				}
			/if (!${MobList[${MobInteger}]}) {
				/if (${DebugMez}) /echo There is no moblist, continuing
				/continue
				}
			/if (${DoCharm} &&!${RDPause} && ${SpellType${DebuffSpellType}}==5 && !${Me.Pet.ID} && ${MobList[${MobInteger}]} && ${Spawn[${MobList[${MobInteger}]}].LineOfSight} && ${Spawn[${MobList[${MobInteger}]}].Standing} && ${Spawn[${MobList[${MobInteger}]}].Level}<=${MaxCharmLvl} && ${MobList[${MobInteger}]}==${PetID}) {
				/if (!${${DebuffID[${DebuffSpellType}]}Immune.Find[|${Spawn[${MobList[${MobInteger}]}].CleanName}|]} && (${Spawn[${MobList[${MobInteger}]}].Distance}<${Int[${Spell[${DebuffID[${DebuffSpellType}]}].MyRange}]} || !${Spell[${DebuffID[${DebuffSpellType}]}].MyRange}) && (${spellID}!=${DebuffID[${DebuffSpellType}]} || ${Me.Class.ShortName.Equal[BRD]})) {
					/call DebuffStuff ${MobInteger} ${DebuffSpellType}
					}
				}
			/if (${DoMez} && ${canAEMez} && ${SpellType${DebuffSpellType}}==4 && !${RDPause} && ${MobList[${MobInteger}]} && ${Spawn[${MobList[${MobInteger}]}].LineOfSight} && ${MobList[${MobInteger}]}!=${MATarget} && !${Spawn[${MobList[${MobInteger}]}].Assist} && ${DebuffArray[${MobInteger},${DebuffSpellType}]}<=${Macro.RunTime} && ${Spawn[${MobList[${MobInteger}]}].Standing} && ${Spawn[${MobList[${MobInteger}]}].Level}<=${MaxMezLvl}) {
				/if (!${${DebuffID[${DebuffSpellType}]}Immune.Find[|${Spawn[${MobList[${MobInteger}]}].CleanName}|]} && (${Spawn[${MobList[${MobInteger}]}].NearestSpawn[2,npc targetable radius 30 noalert 1].ID}) && ((${Spawn[${MobList[${MobInteger}]}].Distance} < ${Int[${Spell[${DebuffID[${DebuffSpellType}]}].MyRange}]}) || (!${Spell[${DebuffID[${DebuffSpellType}]}].MyRange} && ${Spawn[${MobList[${MobInteger}]}].Distance}<${Int[${Spell[${DebuffID[${DebuffSpellType}]}].AERange}]}))) {
					/varset VarOldNPCCount ${VarNPCCount}
					/varset canAEMez FALSE                    
					/call DebuffStuff ${MobInteger} ${DebuffSpellType}                    
					}
				}      
			/if (${DoMez} && ${MobList[${MobInteger}]} && ${PetID}!=${MobList[${MobInteger}]} && !${RDPause} && ${SpellType${DebuffSpellType}}==2 && ${Spawn[${MobList[${MobInteger}]}].LineOfSight} && ${MobList[${MobInteger}]}!=${MATarget} && !${Spawn[${MobList[${MobInteger}]}].Assist} && ${DebuffArray[${MobInteger},${DebuffSpellType}]}<=${Macro.RunTime} && ${Spawn[${MobList[${MobInteger}]}].Standing} && ${Spawn[${MobList[${MobInteger}]}].Level}<=${MaxMezLvl}) {
				/if (!${${DebuffID[${DebuffSpellType}]}Immune.Find[|${Spawn[${MobList[${MobInteger}]}].CleanName}|]} && (${Spawn[${MobList[${MobInteger}]}].Distance}<${Int[${Spell[${DebuffID[${DebuffSpellType}]}].MyRange}]} || !${Spell[${DebuffID[${DebuffSpellType}]}].MyRange}) && (${Me.Casting.ID}!=${DebuffID[${DebuffSpellType}]} || ${Me.Class.ShortName.Equal[BRD]})) /call DebuffStuff ${MobInteger} ${DebuffSpellType}
				}
				/varset VarOldNPCCount ${VarNPCCount}
				/varset canAEMez FALSE
			/next MobInteger
			/delay 1
		/next DebuffSpellType
	/call MoveStuff
	/varset CheckGroupTimer 1s
	/if (${DebugMez}) /echo \am EXITING \ao Checkmez
	/return	
	
Sub CheckPPS
	/if (${Debug}) /echo entering CheckPPS
|not pretty doing it here again but should tank die and receive rez it will not reset!
    /if (${UseGroupTank}) {
        /varset MainTankID ${Group.MainTank.ID}
		} else {
        /varset MainTankID ${Spawn[${MA1}].ID}
		}
|keep 3 around
    /declare tmpTarget int local 0
    /declare wegothit int local 0
    /if (!${UseGroupTank}) {
        /if (${Target.ID}!=${Spawn[pc ${MA1}].ID} && !${Spawn[pc group ${MA1}].ID}) {
            /varset tmpTarget ${Target.ID}
            /target targetable id ${Spawn[pc ${MA1}].ID}
            /delay 1s ${Target.ID}==${Spawn[pc ${MA1}].ID}
			}
		} else {
|do nothing because Tank will be in OUR group !${Group.MainTank.ID} evaluates FALSE
		}
|if he's not in our group
|and is pct went down 
|and it wasn't a complete heal
    /if (!${UseGroupTank}) {
        /if (!${Spawn[pc group ${MA1}].ID} && ${TankLastPct}>${Target.PctHPs} && ${Target.PctHPs}!=100) {
|he got hit by something (bad assumption of complete heal)
            | /varcalc TotalTankHits ${TotalTankHits}+(${TankLastPct}-${Target.PctHPs})
            /varset wegothit ${Target.PctHPs}
			} else {
 |if (tank in group) && (hp went down) && (hp != 100)
 | tothits = tothits+deltahp
            /if (${Spawn[pc group ${MA1}].ID} && ${TankLastPct}>${Spawn[pc group ${MA1}].PctHPs}) {
                | /varcalc TotalTankHits ${TotalTankHits}+(${TankLastPct}-${Spawn[pc group ${MA1}].PctHPs})
                /varset wegothit ${Spawn[pc group ${MA1}].PctHPs}
            }
        }
    } else {
        | using UseGroupTank - will always be in group so we do not need to check like above
        /if (${TankLastPct}>${Spawn[ID ${MainTankID}].PctHPs}) {
            /varset wegothit ${Spawn[ID ${MainTankID}].PctHPs}
        }
    }

    /if (${wegothit}) {
        /varcalc TotalTankHits ${TotalTankHits}-${TankHitsArray[${TankHitsIndex}]}+${TankLastPct}-${wegothit}
        /varcalc TankHitsArray[${TankHitsIndex}] ${TankLastPct}-${wegothit}
        /varset TankTimeArray[${TankHitsIndex}] ${Macro.RunTime}
        /varcalc TankHitsIndex ${TankHitsIndex}+1
        /if (${TankHitsIndex}>3) /varset TankHitsIndex 1
    }

    | we incremented the index already so we are pointing to the first
    | data point we recorded
    /if (${TankTimeArray[${TankHitsIndex}]} || ${TankHitsIndex}>1) {
        /varcalc TotalTankTime ${Macro.RunTime}-${If[${TankTimeArray[${TankHitsIndex}]},${TankTimeArray[${TankHitsIndex}]},${TankTimeArray[1]}]}
        /if (${TotalTankTime}) /varcalc TankPPS ${TotalTankHits}/${TotalTankTime}
    } else {
        | don't return anything until we've taken two hits
        /varset TankPPS 0
    }

    /if (!${TankPPS}) {
             /varset TankTTL 3000
    } else {
             /varcalc TankTTL (${Spawn[ID ${MainTankID}].PctHPs}*10)/${TankPPS}
    }

    |/if (${SpawnCount[npc radius 200]} && ${TankTTL}!=3000) {
    |/echo TankPPS ${TankPPS} TankTTL ${TankTTL} 
    |/echo TotalTankTime ${TotalTankTime} TotalTankHits ${TotalTankHits}
    |}

    /varset TankLastPct ${Spawn[ID ${MainTankID}].PctHPs}
    /if (${tmpTarget}) {
        /target targetable id ${tmpTarget}
        /delay 1
		}
	/return
	
Sub ClearCursor
    /declare i int local
    :auto_inv
    /if (${Cursor.ID}) {
		/if (${Cursor.Container}) {
			|---- Inventory Bag Slots
			/for i 1 to 10   
            /if (!${InvSlot[pack${i}].Item.Container}) /nomodkey /itemnotify pack${i} leftmouseup
			/next i
			|---- Inventory Bag Slots   
			} else {
			/timed 5 /autoinventory
			}
		/goto :auto_inv
		}
	/return	
	
Sub ClickRods
	|I am not paused
	|My mana is below RodMana
	|I have a rod in inventory and it does not have a timer
	|Click a rod
	/if (!${RDPause} && ${Me.PctMana}<${RodMana} && ${Me.PctHPs}>30) {
		/if (${FindItem[Summoned: Glowing Modulation Shard].ID} && !${FindItem[Summoned: Glowing Modulation Shard].TimerReady} && ${Me.CurrentHPs}>30100) /useitem "Summoned: Glowing Modulation Shard" 
		/if (${FindItem[Summoned: Giant Modulation Shard].ID} && !${FindItem[Summoned: Giant Modulation Shard].TimerReady} && ${Me.CurrentHPs}>30100) /useitem "Summoned: Giant Modulation Shard" 
		/if (${FindItem[=Wand of Restless Modulation].ID} && !${FindItem[Wand of Restless Modulation].TimerReady} && ${Me.CurrentHPs}>30100) /useitem "Wand of Restless Modulation" 
		/if (${FindItem[=Wand of Arcronite Modulation].ID} && !${FindItem[Wand of Arcronite Modulation].TimerReady} && ${Me.CurrentHPs}>12850) /useitem "Wand of Arcronite Modulation" 
		/if (${FindItem[=Wand of Pelagic Modulation].ID} && !${FindItem[Wand of Pelagic Modulation].TimerReady} && ${Me.CurrentHPs}>12850) /useitem "Wand of Pelagic Modulation" 
		/if (${FindItem[=Wand of Pelagic Transvergence].ID} && !${FindItem[Wand of Pelagic Transvergence].TimerReady} && ${Me.CurrentHPs}>3594) /useitem "Wand of Pelagic Transvergence" 
		/if (${FindItem[Summoned: Large Modulation Shard].ID} && !${FindItem[Large Modulation Shard].TimerReady} && ${Me.CurrentHPs}>23100) /useitem "Summoned: Large Modulation Shard" 
		/if (${FindItem[Summoned: Medium Modulation Shard].ID} && !${FindItem[Medium Modulation Shard].TimerReady} && ${Me.CurrentHPs}>15100) /useitem "Summoned: Medium Modulation Shard" 
		/if (${FindItem[Summoned: Small Modulation Shard].ID} && !${FindItem[Small Modulation Shard].TimerReady} && ${Me.CurrentHPs}>7600) /useitem "Summoned: Small Modulation Shard" 
		/if (${FindItem[=Wand of Phantasmal Modulation].ID} && !${FindItem[Wand of Phantasmal Modulation].TimerReady} && ${Me.CurrentHPs}>11100) /useitem "Wand of Phantasmal Modulation" 
		/if (${FindItem[=Wand of Phantasmal Transvergence].ID} && !${FindItem[Wand of Phantasmal Transvergence].TimerReady} && ${Me.CurrentHPs}>3138) /useitem "Wand of Phantasmal Transvergence" 
		/if (${FindItem[=Rod of Arcane Transvergence].ID} && !${FindItem[Rod of Arcane Transvergence].TimerReady} && ${Me.CurrentHPs}>2530) /useitem "Rod of Arcane Transvergence" 
		/if (${FindItem[=Rod of Spectral Transvergence].ID} && !${FindItem[Rod of Spectral Transvergence].TimerReady} && ${Me.CurrentHPs}>1720) /useitem "Rod of Spectral Transvergence" 
		/if (${FindItem[=Rod of Ethereal Transvergence].ID} && !${FindItem[Rod of Ethereal Transvergence].TimerReady} && ${Me.CurrentHPs}>1320) /useitem "Rod of Ethereal Transvergence" 
		/if (${FindItem[=Rod of Prime Transvergence].ID} && !${FindItem[Rod of Prime Transvergence].TimerReady} && ${Me.CurrentHPs}>1000) /useitem "Rod of Prime Transvergence" 
		/if (${FindItem[=Wand of Elemental Transvergence].ID} && !${FindItem[Wand of Elemental Transvergence].TimerReady} && ${Me.CurrentHPs}>920) /useitem "Wand of Elemental Transvergence"  
		/if (${FindItem[=Rod of Mystical Transvergence].ID} && !${FindItem[Rod of Mystical Transvergence].TimerReady} && ${Me.CurrentHPs}>550) /useitem "Rod of Mystical Transvergence" 
		/if (${FindItem[=Rod of Mechamagical Mastery].ID} && !${FindItem[Rod of Mechamagical Mastery].TimerReady} && ${Me.CurrentHPs}>1400) /useitem "Rod of Mechamagical Mastery" 
		/if (${FindItem[=Wand of Temporal Mastery].ID} && !${FindItem[Wand of Temporal Mastery].TimerReady} && ${Me.CurrentHPs}>1686) /useitem "Wand of Temporal Mastery" 
		/if (${FindItem[=Summoned: Modulating Rod].ID} && !${FindItem[Summoned: Modulating Rod].TimerReady} && ${Me.CurrentHPs}>325) /useitem "Summoned: Modulating Rod" 
		}
   /call MoveStuff
/return	

Sub CureMe
	/if (!${DoCures}) /return
	/declare i int local
	/for i 1 to ${CureTotal}
		/if ((!${RDPause} && ((${Debuff.Cursed} && ${Debuff.Cursed}<=${CurseCounters${i}}) || (${Debuff.Diseased} && ${Debuff.Diseased}<=${DiseaseCounters${i}}) || (${Debuff.Poisoned} && ${Debuff.Poisoned}<=${PoisonCounters${i}}) || (${Debuff.Corrupted} && ${Debuff.Corrupted}<=${CorruptionCounters${i}}))) && ((${Me.SpellReady[${CureSpell${i}}]} || (!${Me.Gem[${CureSpell${i}}]} && ${Me.Book[${CureSpell${i}}]})) || ${Me.AltAbilityReady[${CureSpell${i}}]} || (${CureGem${i}.Equal[item]} && !${FindItem[${CureSpell${i}}].Timer}))) {
        
			/target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			/if (${ReportCures}) /call AnnounceMessage "${ChatChannel}"  4 g "Casting CureSpell-" t "${CureSpell${i}}" g "on" m "myself"
			/call Cast "${CureSpell${i}}" ${CureGem${i}} 1s Check4Pad
		}
	/next i
	/return
	
|-----------------------------
|taken from Dead2SK, author unknown
|------------------------------
	
Sub CreateCampfire
	/if (!${RDPause}) {
		/windowstate FellowshipWnd open
		/delay 5s
		/nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
		/nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
		/delay 5s ${Window[ConfirmationDialogBox].Open}
		/if (${Window[ConfirmationDialogBox].Open}) {
			/nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
			}
		/delay 2s
		/nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
		/delay 1s        
		/nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
		/delay 1s
		/nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
		/delay 5s
		/windowstate FellowshipWnd close
		/call AnnounceMessage "${ChatChannel}" 2 g "Made a" r "CAMPFIRE!" 
		}
	/return

Sub CreateTimer(MyTimer,MyLength)
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[${MyTimer}]}) /declare ${MyTimer} timer outer 0
	/if (${MyLength.NotEqual[NULL]}) /varset ${MyTimer} ${MyLength}
	/return	
	
Sub Connect
	/if (${UseIRC}==TRUE && ${Irc}==FALSE) {
		/if (${IRCConnect}>0) /return
		/i quit
		/iconnect ${IRCAddress} ${IRCPort} ${IRCChannel} ${Me.Name}
		/varset IRCConnect 20s
	}
	/if (!${EQBC.Connected}) {
		/bccmd connect ${EQBC.Server}
	}
	/return	

Sub DebuffCommon(int a, int i)
	/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${PetAssistTimer}) /call PetAttackStuff
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
	/if (${DoCombatStuff} && ${Me.CombatState.Equal[COMBAT]} && !${CombatStuffTimer}) /call DoStuff Combat
	/if (${DoNamedStuff}) {
		/if (${Target.Type.Equal[npc]}) {
			/if (${Spawn[${MATarget}].Named} || ${Spawn[id ${MATarget}].Level}>=${Math.Calc[${Me.Level}+4]} || ${Me.XTarget}>2) { 
				/call Named
				}
			}
		}
	/if ((${MobList[${a}]}!=${MATarget}) && ((!${MADebuffed} && ${DebuffMAFirst}) || ${DebuffMAOnly${i}})) /return
	/if (!${RDPause} && (${Me.Class.ShortName.Equal[BRD]} || !${Me.Casting.ID}) && ${Spawn[${MobList[${a}]}].LineOfSight} && ${Spawn[${MobList[${a}]}].Standing}  && (${WhichNuke}==${DebuffSpellSet${i}} || !${DebuffSpellSet${i}}) && ${DebuffArray[${a},${i}]}<=${Macro.RunTime} && ${MobList[${a}]} && (${NearestSpawn[npc targetable named].ID}==${MobList[${a}]} || !${DebuffNamedOnly${i}})) {
		/if (!${${DebuffID[${i}]}Immune.Find[|${Spawn[${MobList[${a}]}].CleanName}|]} && (${Spawn[${MobList[${a}]}].Distance}<${Int[${Spell[${DebuffID[${i}]}].MyRange}]} || !${Spell[${DebuffID[${i}]}].MyRange})) {
			/if ((${Me.PctMana}>=${DebuffMana${i}} && !${Select[${DebuffGem${i}},item,alt]} && (!${SitTimer} || ${Me.Gem[${DebuffSpell${i}}]} || ${Me.Mount.ID})) || ${Me.AltAbilityReady[${DebuffSpell${i}}]} || (${FindItem[${DebuffSpell${i}}].ID} && !${FindItem[${DebuffSpell${i}}].TimerReady})) {
			/if ((${DoDebuffs} && !${SpellType${i}}) || (${DoDoTs} && ${SpellType${i}}==1) || (${DoManaTaps} && ${SpellType${i}}==3 && (${Spawn[${MobList[${a}]}].Class.CanCast} || ${Zone.ID}>=400))) /call DebuffStuff ${a} ${i}
			}
		}
	}
	/return
	
Sub DebuffIt
	/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID})) /call PopulateNPCs
	/call AssistMA1
	/varset MADebuffed FALSE
	/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${PetAssistTimer}) {
		/call PetAttackStuff
		}																		
	/declare i int local
	/declare a int local
	/declare localMaxMobs int local ${MaxMobs}
	| loop through and find the MATarget in MobList if DebuffMAFirst
	/if (${DebuffMAFirst} || ${MADebuffOnly}) {
		/for a 1 to ${localMaxMobs}
			/if (${a}>30) /break
			/if (${a}<1) /break
			/if (${MobList[${a}]} && ${MobList[${a}]}==${MATarget}) {
				/for i 1 to ${DebuffTotal}
					/call DebuffCommon ${a} ${i}
				/next i
				/goto :continuedebuffs
			}
		/next a
	}
:continuedebuffs
	/varset MADebuffed TRUE
	/if (${MADebuffOnly}) /goto :enddebuffs

	/if (${AllDebuffsFirst}) {
		/for a 1 to ${localMaxMobs}
			/if (${a}>30) /break
			/if (${a}<1) /break
			/if (${MobList[${a}]} && ${Spawn[${MobList[${a}]}].ID}) {
				/for i 1 to ${DebuffTotal}
					/if (${SpellType${i}}==0 || ${SpellType${i}}==1 || ${SpellType${i}}==3) /call DebuffCommon ${a} ${i}
				/next i
			}
		/next a
	} else {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==0 || ${SpellType${i}}==1 || ${SpellType${i}}==3) {
			/for a 1 to ${localMaxMobs}
				/if (${a}>30) /break
				/if (${a}<1) /break
				/if (${MobList[${a}]} && ${Spawn[${MobList[${a}]}].ID}) /call DebuffCommon ${a} ${i}
			/next a
			}
		/next i
	}
	:enddebuffs
	/call MoveStuff
/return

Sub DebuffStuff(int a,int i)
	/if (${RDPause}) /return
	/declare x int local
	/declare DebuffDuration int local
	/declare DOTBurnDurationPenalty int local
:RecastDebuff
|	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
	/if (${Me.Combat} && ${MobList[${a}]}!=${MATarget}) {
		/attack off
		}
	/delay 1s !${Melee.Combat} || ${MobList[${a}]}==${MATarget}
	/if (${Target.ID}!=${MobList[${a}]}) {
		/target targetable id ${MobList[${a}]}
		}
	/delay 1s ${Target.ID}
	/if (${Target.ID}!=${MobList[${a}]}) {
		/return
		}
	/if (${SpellType${i}}==4 && ${MobList[${a}]}==${MATarget}) {
		/doevents flush MezIt
		/return
		}
|-----Check to be sure your toon has the DeBuff spell, item, or AA	
	/if (!${Select[${DebuffGem${i}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${DebuffSpell${i}}].RankName}]}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ay not in spellbook.
		}
	/if (${DebuffGem${i}.Equal[item]} && !${FindItem[${DebuffSpell${i}}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ay is marked as an item and not in inventory.
		}
	/if (${DebuffGem${i}.Equal[alt]} && !${Me.AltAbility[${DebuffSpell${i}}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ao is marked as an AA, you don't appear to have.
		}
|-----	
|	/delay 2s ${Target.BuffsPopulated}
	/call EvaluateCondition "${DebuffCondition${i}}"
	/if (!${Macro.Return}) {
		/return
		}
	/if ((!(${UseHoTT} && !${Me.TargetOfTarget.ID})) && ((${Target.PctHPs}<=${DebuffHPs${i}} || ${SpellType${i}}==2 || ${SpellType${i}}==4 || ${SpellType${i}}==5) && ${Target.PctHPs}>${DebuffStopHPs${i}}) && ${Target.Type.Equal[NPC]}) {
|-----	Bard section
		/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${DebuffGem${i}},item,alt]} && ${Me.Gem[${DebuffSpell${i}}]}) {
			/varset x ${DebuffRecast${i}}
			/call DoCastingEvents
:bardrecast
			/if (${Me.Invis}) {
				/return
				}
			/squelch /twist once ${Me.Gem[${DebuffSpell${i}}]}
			/varset castReturn CAST_SUCCESS
			/delay ${Spell[${DebuffSpell${i}}].MyCastTime.TotalSeconds}s
			/delay 1s
			/call DoCastingEvents
			/if (${castReturn.Equal[CAST_RESISTED]} && ${x}) {
				/multiline ; /varcalc x ${x}-1;/goto :bardrecast
				}
|-----	End Bard section
			} else {
			/if ((${Me.Class.ShortName.NotEqual[BRD]} || ${Select[${DebuffGem${i}},item,alt]}) && ${Me.Casting.ID}!=${DebuffID[${i}]} && ${DebuffArray[${a},${i}]}<=${Macro.RunTime}) {
				/if (${Me.Class.ShortName.Equal[BRD]}) {
					/squelch /twist stop		 		 		 
					}
|				/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${DebuffID[${i}]}) {
					/call DoInterrupt
					}
:RecastDebuff
				/call Cast "${DebuffSpell${i}}" ${DebuffGem${i}} 3s Check4Pad ${DebuffRecast${i}}
				/delay 5s !${Me.Casting.ID}
				/if (${Me.Class.ShortName.Equal[BRD]}) {
					/if (!${Me.Invis} && !${TwistTimer}) {
						/call SingSongs
						}
					}
				}
			}
		/if (${castReturn.Equal[CAST_RESISTED]} && ${SpellType${i}}==2 && !${Target.Type.Equal[corpse]}) {
			/echo \ar MEZ RESISTED!! \ay Trying again
			/if (${Bool[${Plugin[MQ2EQBC]}]} && ${EQBC.Connected}) /bc [+r+]MEZ RESISTED!! [+y+]Trying again....
			/goto :RecastDebuff
			}
		/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]} && !${Target.Type.Equal[corpse]} && ((${SpellType${i}}!=2 && ${SpellType${i}}!=4) || (!${Target.Assist} && ${Target.ID}!=${MATarget}))) {
			/goto :RecastDebuff
			}
		/if (${Select[${castReturn},CAST_IMMUNE,CAST_RESISTED,CAST_TAKEHOLD]}) {
			/if (${castReturn.Equal[CAST_IMMUNE]}) {
				/if (((${ReportDebuffs} && !${SpellType${i}}) || (${ReportDoTs} && ${SpellType${i}}==1) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Target.ID} && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]}) {
					/call AnnounceMessage "${DebuffChannel}" 4 r "Warning!" y "${Spawn[${MobList[${a}]}].CleanName}" r "is IMMUNE to" o "${DebuffSpell${i}}"
					}
				/varset ${DebuffID[${i}]}Immune ${${DebuffID[${i}]}Immune}${Spawn[${MobList[${a}]}].CleanName}|
		 		/ini RDCommon.ini ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune "${${DebuffID[${i}]}Immune}"
				}
		 	/if (${castReturn.Equal[CAST_RESISTED]} && ((${ReportDebuffs} && !${SpellType${i}}) || (${ReportDoTs} && ${SpellType${i}}==1) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Target.ID} && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]}) {
				/call AnnounceMessage "${DebuffChannel}" 3 y "${Spawn[${MobList[${a}]}].CleanName}" r "RESISTED" o "${DebuffSpell${i}}." "--"
				}
		 	/varcalc DebuffArray[${a},${i}] ${Macro.RunTime}+10000
			}		 
		/if (${castReturn.Equal[CAST_SUCCESS]}) {
			/if (${SpellType${i}}==2) {
				/varset Meztimer 45s
				}
		 	/varset Parse ${DebuffMessage${i}}
		 	/if (${DebuffMessage${i}.Find[%Target]}) {
				/Call ParseMessage "%Target" "${Spawn[${MobList[${a}]}].CleanName}"
				}
		 	/if (${DebuffMessage${i}.Find[%Spell]}) {
				/Call ParseMessage "%Spell"  "${DebuffSpell${i}}"
				}
		 	/if (${DebuffMessage${i}.Find[%Duration]}) {
				/Call ParseMessage "%Duration"  "${Target.BuffDuration[${DebuffSpell${i}}].TotalSeconds}"
				}
			/if (((${ReportDebuffs} && !${SpellType${i}} && ${Parse.NotEqual[None]}) || (${ReportDoTs} && ${SpellType${i}}==1  && ${Parse.NotEqual[None]}) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]} && ${Parse.NotEqual[None]}) /${DebuffChannel} ${Parse}
			/if (!${Spell[${DebuffID[${i}]}].Duration}) {
				/varset DebuffDuration 10003
				} else {
				/varset DebuffDuration ${Spell[${DebuffID[${i}]}].Duration.TotalSeconds}
				/if (${SpellType${i}}==1) { 
					| For a necro who's burning using "Funeral Pyre" AA, dot durations are shortened.
					/docommand ${If[${Me.Song[Smoldering Fury].ID},/varset DOTBurnDurationPenalty 50,/varset DOTBurnDurationPenalty 0]}
					/if (${DebuffDuration}>=24) {
						/varcalc DebuffDuration (${DebuffDuration}*((${DoTDurFocus}-${DOTBurnDurationPenalty}+200)/200)+${DoTDurAASecs})
						}
					/if (${DebuffDuration}<${Spell[${DebuffID[${i}]}].RecastTime.TotalSeconds}) {
						/varcalc DebuffDuration ${Spell[${DebuffID[${i}]}].RecastTime.TotalSeconds} + 3
						}
					}
				/if ((${SpellType${i}}==2) || (${SpellType${i}}==4)) /varcalc DebuffDuration (${DebuffDuration}+${MezDurAASecs})
				}
			/varcalc DebuffArray[${a},${i}] ${Macro.RunTime}+${DebuffDuration}-3
			}
		/varset castReturn CAST_CANCELLED
		}
	/doevents
	/if (!${Melee.Combat} && ${Target.ID}!=${MATarget} && !${RDPause}) {
		/call AssistMA1
		}
	/Call MercStuff
	/return
	
Sub Delayer
	/delay 1s
	/return	

Sub DestroyBag
	/declare j int local
|========================================	
| Make sure bag has no items other than summoned in it before deleting.
|========================================
	/if (${InvSlot[pack${BagNum}].Item.Items}) {
		/for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
		/if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
			/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${ChatChannel}"	2 y "Bag has non summoned item(s) in it. Aborting delete." r "Pet Toys Off"
			/varset DoPetToys 0
			/return
			}
		/next j
        }
	/if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
		/nomodkey /itemnotify pack${BagNum} leftmouseup
		/delay 5s ${Cursor.ID}
		/if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
		/delay 20 !${Cursor.ID}
        }
	/return
	
Sub DiscStuff(int DiscCall)
	/declare i int local
	/for i 1 to ${DiscTotal}
		/if (!${RDPause} && ${Window[CombatAbilityWnd].Child[CAW_CombatEffectLabel].Text.Equal["No Effect"]} && ${Me.PctEndurance}>${DiscEndurance${i}} && ${Me.CombatAbilityReady[${DiscName${i}}]} && ${DiscSpawnCount${i}}>=${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1 playerstate 4]} && ${DiscType${i}}==${DiscCall} && ((${DiscType${i}} && ${Target.ID}==${MATarget} && ${Target.PctHPs}<=${DiscMinHPs${i}} && ${Target.PctHPs}>=${DiscMaxHPs${i}} && ${Melee.Combat}) || (!${DiscType${i}} && ${Me.PctHPs}<=${DiscMinHPs${i}} && ${Me.PctHPs}>=${DiscMaxHPs${i}}))) {
			/disc ${DiscName${i}}
			/return
		}
	/next i
	/return

Sub DoAEHeal
	/declare i            int local
	/declare PCArray[100] int local
	/declare PCsInRange   int local ${SpawnCount[pc radius ${PCRadius} zradius ${PCZRadius}]}
	/for i 1 to ${PCsInRange}
		/varset PCArray[${i}] ${NearestSpawn[${i}, pc].ID}
	/next i
	/for i 1 to ${PCsInRange}
		/if (${Me.CurrentMana}<${Spell[${FastHealID}].Mana}) /return
		/if (!${RDPause} && ${Spawn[${PCArray[${i}]}].Type.NotEqual[corpse]} && ${Spawn[${PCArray[${i}]}].Type.NotEqual[untargetable]}) {
			/target targetable id ${PCArray[${i}]}
			/delay 3
			/call ShouldIHeal
		}
	/next i
	/return	
	
Sub DoAssistHeal
	/declare i            int local
	/declare NPCArray[50] int local
	/declare NPCsInRange  int local ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}
	/for i 1 to ${NPCsInRange}
		/if (!${i}) /return
		/varset NPCArray[${i}] ${NearestSpawn[${i}, npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4].ID}
	/next i
	/for i 1 to ${NPCsInRange}
		/if (${Me.CurrentMana}<${Spell[${FastHealID}].Mana}) /return
		/if (!${RDPause} && ${Spawn[${NPCArray[${i}]}].LineOfSight} && ${Spawn[${NPCArray[${i}]}].Type.NotEqual[corpse]} && ${Spawn[${NPCArray[${i}]}].Standing} && ${Spawn[${NPCArray[${i}]}].Type.NotEqual[untargetable]}) {
			/squelch /target targetable id ${NPCArray[${i}]}
			/delay 5s ${Target.ID}==${NPCArray[${i}]} && ${Me.AssistComplete}==TRUE
			/assist
			/delay 5s ${Target.Type.Equal[PC]} && ${Me.AssistComplete}==TRUE
			/call ShouldIHeal
		}
	/next i
	/return

Sub DoBuffEvents
	/if (${Debug}) /echo \ag Entering \ao DoBuffEvents sub
	/if (${Cursor.ID}) /autoinventory
	/declare a int local 1
|	/declare TempVar int local ${Math.Calc[${DoBuffTotal}+1]}	
	/declare TempVar int local ${If[${Bool[${DoBuffTotal}]}, ${DoBuffTotal}, ${Math.Calc[${DoBuffTotal}+1]}]}
|	/declare TempVar int local ${DoBuffTotal}
	/declare TempGuy int local 0
	/doevents WornOff
	/for a 1 to 25
|		/if (${Debug}) /echo QueueCount = ${QueueCount}( ${DoBuffQueue[${a},2]} <= ${TempVar} and ${Spawn[${DoBuffQueue[${a},1]}].ID} and ( ${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].Name.Find[Illusion:]} or ${Spawn[${DoBuffQueue[${a},1]}].Distance} < ${Int[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].MyRange}]} or ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].AERange} ) )
		/if (${DoBuffQueue[${a},2]}<=${TempVar} && ${Spawn[${DoBuffQueue[${a},1]}].ID} && (${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].Name.Find[Illusion:]} || ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Int[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].MyRange}]} || ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].AERange})) {
			/varset TempGuy ${DoBuffQueue[${a},1]}
			/varset TempVar ${DoBuffQueue[${a},2]}
			/if (${Debug}) {
				/echo \ao DoBuff Que - \ag TempGuy \am ${Spawn[${TempGuy}].CleanName} \ag Buff \ay ${DoBuffQueue[${a},2]} and a= ${a}
				}
			}
		/if (${Defined[RezBuff${DoBuffQueue[${a},2]}]}) {
			/if (!(${Spawn[${DoBuffQueue[${a},1]}].Type.Equal[corpse]} ^^ ${RezBuff${DoBuffQueue[${a},2]}})) {
				/varset TempGuy ${DoBuffQueue[${a},1]}
				/varset TempVar ${DoBuffQueue[${a},2]}
				/if (${Debug}) /echo \ao DoBuff Que REZ section - \ag TempGuy \am ${Spawn[${TempGuy}].CleanName} \ag Buff \ay ${DoBuffQueue[${a},2]}			
				}
			}	
	/next a
	/if (${Debug}) /echo \ao DoBuffQueue set 
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
|-----Check to be sure your toon has the DoBuff spell, item, or AA
	/if (!${Select[${DoBuffGem${TempVar}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${DoBuff${TempVar}}].RankName}]}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} not in spellbook.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
	/if (${DoBuffGem${TempVar}.Equal[item]} && !${FindItem[${DoBuff${TempVar}}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} is marked as an item and not in inventory.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
	/if (${DoBuffGem${TempVar}.Equal[alt]} && !${Me.AltAbility[${DoBuff${TempVar}}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} is marked as an AA, you don't appear to have.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
|-----
	/if ((${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && ${BattleBuff${TempVar}}==1) || (${BattleBuff${TempVar}}==2 && ${Me.CombatState.Equal[COMBAT]}) || (!${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && ${BattleBuff${TempVar}}!=2)) {
		/if (${Debug}) /echo \ao DoBuff - passed battlebuff check or spawn check Target= \ay ${Spawn[${TempGuy}].CleanName} \ag DoBuff \ay ${DoBuff${TempVar}}
		/if (${TempGuy}) {
			/if (((${Me.SpellReady[${DoBuff${TempVar}}]} || !${Me.Gem[${DoBuff${TempVar}}]} || ${Spell[${DoBuffID[${TempVar}]}].RecastTime}<30) && ${Me.CurrentMana}>${Spell[${DoBuffID[${TempVar}]}].Mana} && ${Me.PctMana}>=${DoBuffMana${TempVar}}) && (!${Select[${DoBuffGem${TempVar}},item,alt]} || (${DoBuffGem${TempVar}.Equal[item]} && ${FindItem[${DoBuff${TempVar}}].TimerReady}<30) || (${DoBuffGem${TempVar}.Equal[alt]} && ${Me.AltAbilityReady[${DoBuff${TempVar}}]}))) {
				/if (${Debug}) /echo \ao DoBuff there is a target, and the spell is ready
				/squelch /target targetable id ${TempGuy}
				/delay 1s ${Target.ID}==${TempGuy}
				/if (${Target.ID}==${TempGuy}) {
					/if (${DoBuffTells}) /tt ${Spell[${DoBuffID[${TempVar}]}].Name}
					/if (${ReportDoBuffs} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Buffing" o "${Spell[${DoBuffID[${TempVar}]}].Name}" g "on" m "${Spawn[${TempGuy}].CleanName}"
					/doevents flush Restricted
					/call Cast "${DoBuff${TempVar}}" ${DoBuffGem${TempVar}} 30s Check4Pad
					/call DoRestrictedEvents ${DoBuffID[${TempVar}]}
					/delay 10s !${Me.Casting.ID}
					/if (${Select[${castReturn},CAST_SUCCESS,CAST_TAKEHOLD,CAST_NOTHOLD]}) {
						/if (${Debug}) /echo \ao DoBuff Cast sucessful or did not take hold
						/if (${castReturn.Equal[CAST_SUCCESS]} || ${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
							/if (${Select[${Spell[${DoBuff${TempVar}}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} && (${Group.Member[${Spawn[${TempGuy}].CleanName}].Index} || ${Group.Member[${Spawn[${TempGuy}].Master.CleanName}].Index} || ${Target.Type.Equal[Pet]} || ${Target.Type.Equal[Mercenary]})) /varset TempGuy 0
							/call RemoveFromQueue ${TempGuy} ${TempVar}
							} else {
								/call RemoveFromQueue ${TempGuy} ${TempVar}
								}
						/call AutoSit
						}
					}
				}
			}
	}
	/varset DoBuffTimer 10s
/return
	
Sub DoDivArb
	/if ((!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) || (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID})) {
		/if (${Me.Casting.ID}) /call DoInterrupt
		/if (${FindItem[Harmony of the Soul].ID}) /call Cast "Harmony of the Soul" item 5s SpellFiller 3
		/if (${FindItem[Aegis of Superior Divinity].ID}) /call Cast "Aegis of Superior Divinity" item 5s SpellFiller 3
		} else /if ((${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) || (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) || (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer}))) {
		/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${DivArbSpellID}) /call DoInterrupt
		/call Cast "${DivArbSpell}" ${DivArbGem} 5s SpellFiller 3
		}
	/if (!${Select[${DivArbGem},alt,item]} && ${Spell[${DivArbSpell}].RankName.ID}) /varset DivArbTimer ${Spell[${DivArbSpell}].RecastTime.TotalSeconds}s
	/varset StayOnHealTimer ${StayOnHeal}
	/return	

Sub DoHeal(int HealGuy,HealType)
	/if (${DebugHeal}) /echo DoHeal ${HealGuy} ${HealType}
	/if (${Me.Casting.ID} && !${Select[${Me.Casting.ID},${DivArbSpellID},${GroupHealID},${FastHealID},${TankHealID},${DelayedHealID},${PetHealID}]}) {
		/call DoInterrupt
		/if (${DebugHeal}) /echo Interupt called
		/delay 1s !${Me.Casting.ID}
		}
	/if (${Target.ID}!=${HealGuy}) /target targetable id ${HealGuy}
	/delay 1s ${Target.ID}==${HealGuy}
|-----If tankheal is not ready, switch to caster heal.
	/if (${HealType.Equal[Tank]} && !${Me.SpellReady[${Spell[${TankHeal}].RankName}]}) /varset HealType Fast
	/if (${HealType.Equal[Fast]}) /varset StartHPs ${Target.PctHPs}
	/if (${Target.ID}==${HealGuy} && ${Spawn[${HealGuy}].Type.NotEqual[corpse]}) {
		/call Cast "${Spell[${${HealType}Heal}].RankName}" ${${HealType}HealGem} 5s CheckHP
		/if (${DebugHeal}) /echo casting ${${HealType}Heal} ${${HealType}HealGem} 
		}
|	/if (${HealType.Equal[Fast]} && ${Target.ID}==${HealGuy} && ${Target.PctHPs}<${StartHPs}+5 && ${Target.PctHPs}>=${StartHPs}) {
|		/varset DAArray[${WorstMember},1] ${StartHPs}
|		/varset DAArray[${WorstMember},2] 1
|		}
	/varset CheckGroupTimer 0
	/varset SpamFlag FALSE
	/varset StayOnHealTimer ${StayOnHeal}
	/varset WorstHPs 100
	/call DoCastingEvents
	/varset castReturn CAST_CANCELLED
|	/target clear
	/return	
	
Sub DoInterrupt
	/if (${Me.Casting.ID}) {
		/if (${Defined[ReportInterrupts]}) {
			/if (${ReportInterrupts}) /call AnnounceMessage "${ChatChannel}"  4 r "Interrupting" o "${Me.Casting}" g "being cast at" m "${Target.CleanName}"
			}
		/call Interrupt
		/delay 1s !${Me.Casting.ID}
		}
	/return
	
Sub DoMelee
	/if (!${DoMelee}) /return
	/declare i int local
	/if (${Target.Type.Equal[corpse]} && ${Melee.Combat}) {
		/target clear
		/return
	}
	/if (!${RDPause} && ${Bool[${Spawn[${MATarget}].ID}]}) {
		/if (${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${Spawn[${MATarget}].Distance}<${NPCRadius} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && ${Spawn[${MATarget}].LineOfSight} && ${UseEpic} && (!${FindItem[${Epic}].Timer} && ${FindItem[${Epic}].ID}) && ${UseEpic}<=${SpawnCount[npc targetable radius ${NPCRadius} zradius 50 noalert 1 playerstate 4]} && (${Me.Class.ShortName.Equal[BRD]} || !${Me.Casting.ID})) {
			/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
			/if (${Me.Casting.ID}) {
				/call DoInterrupt
				}
			/target ID ${MATarget}
			/call Cast "${Epic}" item 2s SpellFiller 3
			/if (${Me.Class.ShortName.Equal[BRD]}) {
				/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
				}
			}
		/if (${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${Spawn[${MATarget}].Distance}<${NPCRadius} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && ${Spawn[${MATarget}].LineOfSight} && (${DoMelee} || ${DoRanged} || (${DoCharm} && ${Me.Pet.ID}) || (${UsePet} && ${Me.Pet.ID})) && !${Me.Moving} && (${MATarget}!=${Melee.Target} || ${Target.ID}!=${MATarget})) {
			/if (${Target.ID}!=${MATarget}) /target targetable id ${MATarget}
			/delay 1s ${Target.ID}==${MATarget}
			/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
			/stick off
			/if (${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist}) {
				/face fast
				/autofire on
				/delay 5s (${Me.AutoFire})
				}
			/if ((!${DoRanged} || ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
				/if (${Me.Sitting}) /stand
				/delay 5s !${Me.Sitting}
				/squelch /killthis
				}
			/if (${PetAttack} && ${Me.Pet.ID} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${PetAssistTimer}) {
				/call PetAttackStuff
				}
		}
		/if (${UseDiscs}) /call DiscStuff 1
		/if (${Defined[DoShield]}) {
			/if (${DoShield} && !${ShieldTimer}) {
				/for i 1 to ${Group}
					/if (${Window[CombatAbilityWnd].Child[CAW_CombatEffectLabel].Text.Equal["No Effect"]} && ${Group.Member[${i}].PctHPs}<${ShieldHPs} && ${Group.Member[${i}].Distance}<=${ShieldRange} && (${ShieldClasses.Find[|${Group.Member[${i}].Class.ShortName}|]} || ${ShieldClasses.Equal[All]})) {
						/shield ${Group.Member[${i}].CleanName}
						/varset ShieldTimer 3m
						/return
						}
					/next i
				}
			}

		}
	/if (${Mercenary.State.Equal[ACTIVE]} && !${RDPause}) /call MercStuff
	/return

Sub DoRestrictedEvents(BuffID)
	/if (${Defined[BuffID]}) {
		/varset LastCast ${BuffID}
		/doevents Restricted
		/varset LastCast BLAH
	}
	/return	
	
Sub DoSotW
	/declare i             int local
	/declare GroupTotalHPs int local
	/declare GroupMember   int local
	/varcalc GroupMember ${Group}+1
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].ID}) {
			/varcalc GroupTotalHPs ${GroupTotalHPs}+${Group.Member[${i}].PctHPs}
		} else {
			/varcalc GroupTotalHPs ${GroupTotalHPs}+100
		}
	/next i
	/if (!${RDPause} && ${GroupTotalHPs}/(${Group}+1)<${SotWPct} && !${Me.Buff[Celestial Regeneration].ID} && !${Me.Buff[Celestial Rejuvenation].ID} && !${Me.Buff[Ethereal Elixir].ID} && !${Me.Buff[Celestial Renewal].ID} && !${Me.Buff[Spirit of the Wood].ID} && !${Me.Buff[Spirit of the Grove].ID} && !${Me.Buff[Ancestral Aid].ID} && !${Me.Buff[Paragon of Spirit].ID} && !${Me.Buff[Perfection of Spirit].ID}) {
		/if (${Target.Type.NotEqual[NPC]}) {
			/target id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
		}
		/if (${ReportSotW}) /call AnnounceMessage "${HealChannel}" 4 g "Prepare for" t "${SotWAA}" g "to heal" m "the group"
		/call Cast "${SotWAA}" alt 1s SpellFiller 3
		}
	/varset GroupTotalHPs 0
	/return

Sub DoSotWNet
	/if (!${RDPause} && ${NetWorst.Request[pc all group radius${Int[${Spell[${SotWAA}].MyRange}]}]}>1 && ${NetWorst.Average}<${SotWPct} && !${Me.Song[Celestial Regeneration].ID} && !${Me.Song[Celestial Rejuvenation].ID} && !${Me.Song[Ethereal Elixir].ID} && !${Me.Song[Celestial Renewal].ID} && !${Me.Song[Spirit of the Wood].ID} && !${Me.Song[Spirit of the Grove].ID} && !${Me.Song[Ancestral Aid].ID} && !${Me.Song[Paragon of Spirit].ID} && !${Me.Song[Perfection of Spirit].ID}) {
		/if (${Target.Type.NotEqual[NPC]}) {
			/target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			}
		/if (${ReportSotW}) /call AnnounceMessage "${ChatChannel}" 4 g "Prepare for" o "${SotWAA}" g "to heal" m "the group"
		/call Cast "${SotWAA}" alt 1s SpellFiller 3
		}
	/return	
	
Sub DoStuff(StuffType)
	/declare i int local 1
	/declare tempTargetID int local 0
|	/varset tempTargetID 0
	/for i 1 to ${${StuffType}Total}
		/if (${RDPause} || (${Me.CombatState.Equal[COMBAT]} && ${StuffType.Equal[Rest]}) || ${Me.State.Equal[HOVER]}) /return
		/if (${HealGroup} && !${CheckGroupTimer}) /call EvaluateGroup
		/if (${tempTargetID}) /target id ${tempTargetID}	
		/call EvaluateCondition "${${StuffType}Condition${i}}"
		/if (${Macro.Return}) /call ExecuteStuff ${StuffType} ${i}
		/varset tempTargetID ${Target.ID}
	/next i
	/varset ${StuffType}StuffTimer ${${StuffType}StuffRecheck}
	/call MoveStuff
	/return

Sub DoWoW
	/if (${Defined[DoWoWTimer]}) {
		/if (${DoWoWTimer}>0) /return
		} 
	/declare i int local
	/for i 1 to 3
		/if (!${RDPause} && ${Spawn[${MA${i}}].ID} && ${Spawn[${MA${i}}].Distance}<100) {
			/target targetable ${MA${i}}
			/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
			/delay 5s ${Target.ID}==${MainTankID}
			/if (${Target.Type.Equal[Corpse]}) {
				/echo MA${i} is dead, can not place Wrathe of the Wild on them
				/call CreateTimer DoWoWTimer 5m
				/return
				}
			/call Cast "Wrath of the Wild" alt Check4Pad
			/if (${castReturn.Equal[CAST_SUCCESS]} || !${Me.AltAbilityReady[Wrath of the Wild]}) {
				/if (${ReportWoW} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Put" o "Wrath of the Wild" g "on" m "${Target.CleanName}"
				/return
				}
			/if (${Select[${castReturn},CAST_IMMUNE,CAST_RESIST,CAST_TAKEHOLD,CAST_NOTHOLD]}) {
				/call AnnounceMessage "${ChatChannel}" 4 r "Failed to put" o "Wrath of the Wild" r "on" m "${Target.CleanName}"
				/call CreateTimer DoWoWTimer 3m
				}
			}
	/next i
	/return	
	
Sub EvaluateCondition(Condition)
	/declare sCondition string local
	/declare sVarL string local
	/declare sVarC string local
	/declare j int local
	/varset sVarC
	/varset sCondition (${Condition})
	/if (${sCondition.Count[{]}>0) {
		/for j 1 to ${sCondition.Count[{]}
			/varset sVarL ${sCondition.Arg[${j},{]}
			/varset sVarC ${sVarC}${sVarL}${
		/next j
		/varset sVarC ${sVarC}${sCondition.Arg[${j},{]}
		}
	} else {
		/varset sVarC ${sCondition}
	}
	/if (${sVarC}) /return 1
	/return 0

Sub EvaluateGroup
	/if (${RDPause}) /return
	/declare i int local
	/varset WorstHPs 100
	/varset GroupHurtCount 0
    
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Type.Equal[Corpse]}) /goto :NextEvaluateGroup
		/if (!${RDPause}) {
			/if (${UseDivArb}) {
				/if (${Group.Member[${i}].PctHPs}<=${DivArbHPs}) {
					/if (${Spawn[${Group.Member[${i}]}].ID} && ${Spawn[${Group.Member[${i}]}].Distance}<${Spell[Divine Arbitration].MyRange}) {
						/if (${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) /call DoDivArb
						/if (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) /call DoDivArb
						/if (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer})) /call DoDivArb
						/if (!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) /call DoDivArb
						/if (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID}) /call DoDivArb
						}
					}
				}
			}
		/if (!${RDPause}) {
			/if (${UseBDA}) {
				/if (${Group.Member[${i}].PctHPs}<=${DivArbHPs}) {
					/if (${Me.AltAbilityReady[Bestow Divine Aura]})
						/if (${Group.Member[${i}].ID}!=${MainTankID}) {
							/if (${Group.Member[${i}].ID}!=${Spawn[${MA2}].ID}) {
								/if (${Group.Member[${i}].ID}!=${Spawn[${MA3}].ID}) {
									/if (${Me.Casting.ID}) {
										/call DoInterrupt
										/bc EvaluateGroup Interrupt1
										}
									/target targetable id ${Group.Member[${i}].ID}
									/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
									/call Cast "Bestow Divine Aura" alt 5s SpellFiller 3
									/varset DAArray[${Math.Calc[${i}+1]},1] ${Group.Member[${i}].PctHPs}
									/varset DAArray[${Math.Calc[${i}+1]},2] 1
								}
							}
						}
					}
				}
			}
		/if (${HealMeFirst} && ${Me.PctHPs}<${HealPct}) {
			/varset WorstHPs 0
			/varset WorstID ${Me.ID}
			/goto :EvaluateGroupreturn
			}
		/if (${DAArray[${Math.Calc[${i}+1]},2]} && (${Group.Member[${i}].PctHPs}>=${DAArray[${Math.Calc[${i}+1]},1]}+5 || ${DAArray[${Math.Calc[${i}+1]},1]}>${Group.Member[${i}].PctHPs})) {
			/varset DAArray[${Math.Calc[${i}+1]},1] 0
			/varset DAArray[${Math.Calc[${i}+1]},2] 0
			}
		/if ((${HealFD} && ${Group.Member[${i}].State.NotEqual["FEIGN"]} && ${Select[${Group.Member[${i}].Class.ShortName},MNK,NEC,SHD]}) || ((${UseCH} || ${Group.Member[${i}].PctHPs}>${TankHealPct}) && ${Group.Member[${i}].ID}==${MainTankID})) /goto :NextEvaluateGroup
			| don't do fast heals on MA1 unless TankHealPct not set
		/if (${Group.Member[${i}].PctHPs}<=${WorstHPs} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<${Spell[${FastHealID}].MyRange} && (${Group.Member[${i}].ID}!=${MainTankID} || !${TankHealPct})) {
			/varset WorstHPs ${Group.Member[${i}].PctHPs}
			/varset WorstID ${Group.Member[${i}].ID}
			/varcalc WorstMember ${i}+1
		}
		/if (${Group.Member[${i}].PctHPs}<${HealPct}) /varcalc GroupHurtCount ${GroupHurtCount}+1
				:NextEvaluateGroup
	/next i
	/if (${Defined[DoSotWFunction]}) {
		/if (!${Me.Casting.ID} && ${DoSotW} && ${Me.AltAbilityReady[${SotWAA}]}) /call ${DoSotWFunction}
		}
	:EvaluateGroupreturn
	/varset CheckGroupTimer ${CheckGroupInterval}
	/return

Sub EvaluateGroupNet
	/declare i int local
	/varset WorstHPs 100
	/varset GroupHurtCount 0
	/declare fd string local
	/if (${HealFD}) /varset fd fd
	/if (!${RDPause} && ${UseDivArb} && ${NetWorst.Request[radius${Int[${Spell[Divine Arbitration].MyRange}]} pc group all hp${DivArbHPs}]} && (((${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) || (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) || (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer}))) || (!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) || (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID}))) /call DoDivArb
	/if (!${RDPause} && ${UseBDA} && ${NetWorst.Request[pc group all hp${DivArbHPs} self]} && ${Me.AltAbilityReady[Bestow Divine Aura]} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA1}].ID} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA2}].ID} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA3}].ID}) {
		/if (${Me.Casting.ID}) {
			/call DoInterrupt
			/bc EvaluateGroupNet Innterrupt 1
			}
		/target targetable id ${NetHeal.ID[1]}
		/delay 1s ${Target.ID}==${NetHeal.ID[1]}
		/call Cast "Bestow Divine Aura" alt 5s SpellFiller 3
		/netheal da 30000 ${NetHeal.ID[1]}
		}		 
	/if (${HealMeFirst} && ${Me.PctHPs}<${HealPct}) {
		/varset WorstHPs ${Me.PctHPs}
		/varset WorstID ${Me.ID}
		/goto :EndCheck
		}
	/if (!${RDPause} && ${NetWorst.Request[radius${Int[${Spell[${FastHealID}].MyRange}]} pc all hp${HealPct} ${fd}]}) {
		/varset i 1
		/if (${TankHealPct} && ${NetHeal.ID[1]}==${Spawn[pc ${MA1}].ID} && ${NetWorst.Counter}==1) /goto :EndCheck
		/if (${TankHealPct} && ${NetHeal.ID[1]}==${Spawn[pc ${MA1}].ID} && ${NetWorst.Counter}>1) /varset i 2
		/varset WorstHPs ${NetHeal.PctHPs[${i}]}
		/varset WorstID ${NetHeal.ID[${i}]}
		}	
	:EndCheck
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].PctHPs}<${HealPct}) /varcalc GroupHurtCount ${GroupHurtCount}+1
	/next i
	/if (!${Me.Casting.ID} && ${DoSotW} && ${Me.AltAbilityReady[${SotWAA}]}) /call DoSotW
	/varset CheckGroupTimer ${CheckGroupInterval}
	/return

Sub EvaluatePets
	/declare i int local
	/varset WorstHPs 100
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Pet.PctHPs}<=${WorstHPs} && ${Group.Member[${i}].Pet.ID} && ${Group.Member[${i}].Pet.Distance}<${Int[${Spell[${PetHealID}].MyRange}]}) {
			/varset WorstHPs ${Group.Member[${i}].Pet.PctHPs}
			/varset WorstID ${Group.Member[${i}].Pet.ID}
		}
	/next i
	/return

Sub ExecuteStuff(StuffType,NumOrder)
	/declare j int local
	/declare sOrder string local
	/declare sVarL string local
	/declare sVarC string local
	/if (${RDPause} || (${Me.CombatState.Equal[COMBAT]} && ${StuffType.Equal[Rest]})) /return
		/varset sVarC
		/varset sOrder ${${StuffType}Command${NumOrder}}
		/if (${sOrder.Count[{]}>0) {
			/for j 1 to ${sOrder.Count[{]}
				/varset sVarL ${sOrder.Arg[${j},{]}
				/varset sVarC ${sVarC}${sVarL}${
			/next j
			/varset sVarC ${sVarC}${sOrder.Arg[${j},{]}
			}
		} else {
			/varset sVarC ${sOrder}
		}	
	/docommand ${sVarC}
	/return


	
Sub GoToCampfire
	/if (!${RDPause} && !${Me.Invis}) /call Cast "Fellowship Registration Insignia" item 5 SpellFiller 3
	/call AnnounceMessage "${ChatChannel}"  1 g "Clicking campfire port!"
	/return


Sub Guard
|========================================
| Activate using "/guard on" sets group's main tank to monitor the extended target window and
|	the mobs around the good. Using command " guard here" in a channel the toon is listening to
|	will cause the toon with guard on to set up a tight /makecamp where the toon is standing
|========================================
	/if (${RDPause}) /return
	/if (${Group.MainTank.ID}==${Me.ID}) {
		/if (${Target.ID}==${Me.ID}) {
			/target clear
			}
		}
	/if (${Target.ID}==${MATarget}) {
		/if (${Spawn[id ${MATarget}].ID}) {
			/if (${Spawn[${MATarget}].Type.NotEqual[corpse]}) {
				/return
				}
			}
		}
	/if (${DebugGuard}) /echo \ay ENTERING \ag Guard sub routine
	/declare i				int local 1
	/declare gl				int local 1
	/declare k				int local 1
	/declare GuardMob		int local 0
	/call GMChecks
	/if ((${MakeCamp.Status.Equal[PAUSED]} || ${MakeCamp.Status.Equal[ON]}) && ${MakeCamp.CampDist}>70) {
		/moveto loc ${MakeCamp.AnchorY} ${MakeCamp.AnchorX}
		}
	/if (!${Defined[GuardTimer]}) /call CreateTimer "GuardTimer" "0"
	/if (!${Me.Standing} && ${Me.CombatState.Equal[COMBAT]}) {
		/if (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]})) {
			/if (${Me.PctEndurance}>95) {
				/if (${Me.PctMana}>95) {
					/stand
					}
				}
			}
		}
|	/if (${Me.State.Equal[FEIGN]} && ${Me.PctHPs}>60) /stand
	/if (${RDPause} || ${Select[${Zone.ID},345,344,202,203,279]}) {
		/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar RDPause, or non-Pulling zone
		/return
		}
	/if (${Me.AutoFire} && ${MATarget}!=999999 && (${Target.ID}!=${MATarget} || ${Target.ID})) {
		/target ID ${Me.ID}
		/autofire off
		/delay 5s (!${Me.AutoFire})
		}
|========================================
|	Checks for Named mobs on the extended target window, switches to them if it finds one. 
|========================================		
	/if (${Me.XTarget}>0 && ${SpawnCount[npc named targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
		/if (${Target.Named}) {
			/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine, target is \ag NAMED
			/return
			}
		/for k 1 to ${Me.XTarget}
			/if (${Me.XTarget[${k}].Named} && ${Me.XTarget[${k}].Type.Equal[NPC]}) {
				/target ID ${Me.XTarget[${k}].ID}
				/if (${Target.ID} && ${Target.ID}==${Me.XTarget[${k}].ID} && ${Me.XTarget[${k}].PctHPs}<${EngageHPs}) {
					/varset MATarget ${Me.XTarget[${k}].ID}
					/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
					/if (${Group.MainTank.ID}==${Me.ID} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
					/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist}) {
						/face fast
						/autofire on
						/delay 5s (${Me.AutoFire})
						} else /if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
						/delay 10s (${Target.Distance}<20)
						/if (${Me.Sitting}) /stand
						/delay 5s !${Me.Sitting}						
						/killthis
						/delay 1s
						/killthis
						/call DoMelee
						}
					/popup Killing ${Target.CleanName}
					/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "r" "/varset MATarget ${Me.XTarget[${k}].ID}"
					/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "y" "Named!!"
					/varset GuardTimer 3
					/if (${DebugGuard}) /echo \ay EXITING \ag Guard Subroutine: \am Named section
					/return
					}
				}
		/next k
|		/return
		}
|========================================
| If there is no MATarget, and not currently fighting something, checks the extended target window. 
|	 Targets XTarget1 and attacks
|========================================		
	/if (${Spawn[${MA1}].ID}==${Me.ID} && ${Me.XTarget} && (!${Me.Combat} && !${Me.AutoFire}) && ${Me.XTarget[1].Distance}<${NPCRadius} && ${Target.ID}!=${Me.XTarget[1].ID}) {
		/xtarget 1
		/if (${Target.ID} && ${Target.ID}==${Me.XTarget[1].ID} && ${Me.XTarget[1].Type.Equal[Pet]}) {
			/xtarget 2
			/if (${Target.ID} && ${Target.ID}==${Me.XTarget[2].ID} && ${Me.XTarget[2].Type.Equal[NPC]}) {
				/varset MATarget ${Target.ID}
			} else {
			/xtarget 1	
			/if (${Target.ID} && ${Target.ID}==${Me.XTarget[1].ID} && (${Me.XTarget[1].Type.Equal[NPC]} || ${Me.XTarget[1].Type.Equal[Pet]})) {
				/varset MATarget ${Target.ID}
					}
				}
			} else {
			/varset MATarget ${Me.XTarget[1].ID}
			}
			/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
			/if (${Group.MainTank.ID}==${Me.ID} && ${Spawn[${MATarget}].Named} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
			/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist} && ${Me.XTarget[1].PctHPs}<${EngageHPs}) {
				/face fast
				/autofire on
				/delay 10s ${Me.XTarget}
				/if (${Me.Class.ShortName.NotEqual[RNG]}) {
					/if (${Me.Sitting}) /stand
					/delay 10s (${Target.Distance}<20)
					/killthis
					/stick
					/delay 1s
					/killthis
					/stick
					/call DoMelee
					}
				} else {
					/if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
					/delay 10s (${Target.Distance}<20)
					/if (${Me.Sitting}) /stand
					/delay 5s !${Me.Sitting}
					/stick ID ${Target.ID}
					/killthis
					/delay 1s
					/killthis
					/call DoMelee
					}
			/popup Killing ${Target.CleanName}
			/squelch /face fast nolook
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "r" "/varset MATarget ${Me.XTarget[1].ID}"
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "y" "Guard function XTarget window activated!"
			/varset GuardTimer 5s
			/if (${DebugGuard}) /echo \ay EXITING \ag Guard Subroutine" \am XTarget section
			/return
			}
		}
	/if (${GuardTimer}>0) {
		/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine due to \ar Guard Timer of \ay ${GuardTimer}
		/return
		}
	/if (${Me.XTarget}) {
		/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine due to \ar Xtarget = ${Me.XTarget}
		/return
		}
|	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]})) && ${Me.PctEndurance}>80) /stand																																			 
|========================================
| Monitors area around toon. If a mob not on the alert list, and comes with in the NPCRadius, and is in line of sight, 
|	 it will initiate combat either through range attack (if DoRanged is on) or using /killthis to initiate MQ2Melee attacking
|========================================	
	/if (${Status}) /call Status
	/if (${GuardPause}) {
		/if (${DebugGuard}) /echo \ay Exiting \ag Guard section due to \ar Guard Pause ${GuardPause}
		/return
		}
	/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}<1) {
		/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine due to \ar no mobs \ay ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]} \ay in radius \ar ${NPCRadius} \ay zradius \ar ${NPCZRadius} 
		/return
		}
	/for gl 1 to ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}
		/if (!${Bool[${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}]}) {
			/if (${DebugGuard}) /echo \ay Exiting \ag Guard section due to \ar NO ALLOWED SPAWNS IN RADIUS ${NPCRadius}
			/varset GuardTimer 10s
			/return
			}
		/if (!${Melee.Combat} && !${Me.AutoFire} && !${RDPause} && !${Me.Invis} && ${Melee.Status.NotEqual[ENGAGED]} && !${GuardPause} && ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
			/varset GuardMob ${NearestSpawn[${gl}, npc radius ${NPCRadius} zradius ${NPCZRadius} targetable noalert 1].ID}
			/if (${Target.Type.Equal[Corpse]} || ${Target.Type.Equal[Pet]} || ${Target.Type.Equal[Mercenary]}) {
				/target clear
				/next gl	
				}
			/if (${Spawn[${GuardMob}].Type.Equal[untargetable]} || ${Spawn[${GuardMob}].Type.Equal[Corpse]}) {
				/varset MATarget 999999
				/next gl	
				}
			}
|========================================
| Attempts to use MQ2Nav, if it is loaded, and there 
|  is a mesh for the zone
|========================================	
		/squelch /target targetable id ${GuardMob}
		/delay 1s ${Target.ID}==${GuardMob}
		/if (${UsePullSpell}) {
			/delay 1s
			/if (${PullSpellGem1.Equal[item]}) {
				/if (${FindItem[${PullSpell1}].ID}) {
					/if (!${FindItem[${SelfBuff${i}}].Timer}) {
						/cast "${PullSpell1}" item
						/goto :doneusingpullspell
						}
					}
				}
			/if (${PullSpellGem1.Equal[alt]}) {
				/if (${Me.AltAbilityReady[${PullSpell1}]}) {
					/casting "${PullSpell1}" alt
					/delay 005
					/goto :doneusingpullspell					
					}
				}
			/if (${PullSpellGem1.Equal[comb]}) {
				/if (${Me.CombatAbilityReady[${PullSpell1}]}) {
					/disc ${PullSpell1}
					/goto :doneusingpullspell
					}
				}				
			/if (${Spell[${PullSpell1}].RankName.ID}) {
				/if (${Me.SpellReady[${PullSpell1}]}) {
					/call Cast "${Spell[${PullSpell1}].RankName}" ${PullSpellGem1} 5s  SpellFiller 3
					/goto :doneusingpullspell
					}
				}
			:doneusingpullspell
			/delay 005
			}
		/if (${DoRanged}) {
			/if (${Target.Distance}>250) /goto :NavStuff
			/if (${Spawn[${GuardMob}].LineOfSight}) {
				/if (!${Me.AutoFire} && ${Target.Distance}<250 && ${Target.Distance}>30) {
					/face fast
					/autofire on
					/delay 3s ${Me.XTarget}
					/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "r" "/varset MATarget ${Target.ID}"
					/varset MATarget ${Target.ID}
					/autofire off
					/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar Pulled with range item, target closer then 250 and in line of sight
					/return
					}
				/if (${Target.Distance}>30) {
					/attack on
					/delay 3s ${Me.XTarget}
					/attack off
					/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar Pulling with melee, target closer then 30
					/return
					}
				}
			}
		/if (${Me.XTarget}) {
			/return
			}
:NavStuff	
		/if (${RDPause}) {
			/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar RDPause in NavStuff section
			/return
			}
		/if (${Bool[${Plugin[MQ2Nav]}]}) {
			/if (${Navigation.Active}) {
				/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar NavStuff section, Nav is active
				/return
				}
			/if (!${Navigation.MeshLoaded}) {
				/nav reload
				/delay 5s ${Navigation.MeshLoaded}
				/if (!${Navigation.MeshLoaded}) {
					/plugin MQ2Nav unload
					/call AnnounceMessage "2" "r" "Error" "y" "No mesh loaded for zone, unloading MQ2Nav plugin"
					/return
					}
				}
			/if (${DebugGuard}) /echo \am Entering Nav section
			/if (${GuardTimer}) {
				/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar Guard Timer, NavStuff section
				/return
				}
			|/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
			/if (${Navigation.MeshLoaded} && ${Spawn[${GuardMob}].Type.NotEqual[corpse]} && ${Spawn[${GuardMob}].Type.NotEqual[untargetable]} && !${Me.Moving}) {
				/if (${LOSOnly}) {
					/echo ${Spawn[${GuardMob}].LineOfSight} mob LOS
					/if (!${Spawn[${GuardMob}].LineOfSight}) {
						/next gl
						}
					}
				/if (!${Navigation.PathExists[id ${GuardMob}]}) {
					/next gl	
					}
				/if (${Navigation.PathExists[id ${GuardMob}]}) {
					:retarget
					/if (${Debug}) /echo \ag Entering \ao Navigation section of Guard
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						/if (${DebugGuard}) /echo pausing makecamp 1, status: ${MakeCamp.Status}
						/varset CampX ${MakeCamp.AnchorX}
						/varset CampY ${MakeCamp.AnchorY}
						/varset CampZ ${Me.Z}
						}
					/if (${MakeCamp.Status.Equal[OFF]} && !${Bool[${CampX}]})	{
						/varset CampX ${Me.X}
						/varset CampY ${Me.Y}
						/varset CampZ ${Me.Z}
						}
					:restartnav
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						/if (${DebugGuard}) /echo pausing makecamp 2, status: ${MakeCamp.Status}
						}
					/squelch /target targetable id ${GuardMob}
					/nav target
					/delay 1s
					/delay 5s ${Navigation.Active}
|--- Using pull spell 
					/if (${UsePullSpell}) {
						/delay 30s ${Spawn[${GuardMob}].Distance}<200
						/delay 60s ${Spawn[${GuardMob}].LineOfSight}
						/if (${Me.XTarget}) /goto :navreturn
						/if (${MakeCamp.Status.Equal[ON]}) {
							/if (${Navigation.Active} && !${Me.Moving}) {
								/echo Stuck, restarting Nav
								/makecamp pause
								/goto :restartnav
								}
							/if (!${Spawn[${GuardMob}].LineOfSight}) {
								/goto :restartnav
								}
							}
						/nav stop
						/delay 1s  
|--- PullSpell = Item section						
						/if (${PullSpellGem1.Equal[item]}) {
							/if (${FindItem[${PullSpell1}].ID}) {
								:itemretry
								/if (!${FindItem[${SelfBuff${i}}].Timer}) {
									/call Cast "${PullSpell1}" item 10s SpellFiller 3
									/goto :doneusingpullspell2
									}
								/if (${FindItem[${SelfBuff${i}}].Timer}) {
									/echo \ay Pull item  \ar ${PullSpell1} \ay not ready, pausing \ag ${FindItem[${SelfBuff${i}}].Timer}
									/delay ${FindItem[${SelfBuff${i}}].Timer}
									/goto :itemretry
									}
								}
							/if (!${FindItem[${PullSpell1}].ID}) {
								/echo \ay PullSpell \ag ${PullSpell1} \ay is marked as an item you do not appear to have, \ar turning UsePullSpell off.
|								/varset UsePullSpell FALSE
								}
							}
|--- PullSpell = ALT section							
						/if (${PullSpellGem1.Equal[alt]}) {
							:altretry
							/if (${Me.AltAbilityReady[${PullSpell1}]}) {
								/call Cast "${PullSpell1}" alt 10s SpellFiller 3
								/delay 005
								/goto :doneusingpullspell2								
								}
							/if (!${Me.AltAbilityReady[${PullSpell1}]}) {
								/echo \ay PullSpell \ag ${PullSpell1} \ay is not ready yet, pausing 5s
								/delay 5s ${Me.AltAbilityReady[${PullSpell1}]}
								/goto :altretry
								}
							}
|--- PullSpell = combat ability section							
						/if (${PullSpellGem1.Equal[comb]}) {
							:combretry
							/if (${Me.CombatAbilityReady[${PullSpell1}]}) {
								/disc ${PullSpell1}
								/goto :doneusingpullspell2
								}
							/if (!${Me.CombatAbilityReady[${PullSpell1}]}) {
								/echo \ay PullSpell \ag ${PullSpell1} \ay  as a combat ability is not ready yet, pausing 5s
								/delay 5s ${Me.CombatAbilityReady[${PullSpell1}]}
								/goto :combretry
								}
							}							
|--- PullSpell = Spell section							
						/if (${Bool[${Spell[${PullSpell1}].RankName.ID}]}) {
							:retrypullspell2
							/if (${Me.SpellReady[${Spell[${PullSpell1}].RankName}]}) {
								/call Cast "${Spell[${PullSpell1}].RankName}" ${PullSpellGem1} 10s SpellFiller 3
								/if (${castReturn.NotEqual[CAST_SUCCESS]}) {
									/goto :doneusingpullspell2
									}
								/echo \ar Error \ay casting pull spell \am "${Spell[${PullSpell1}].RankName}" \ay ${PullSpellGem1}
								/goto :retrypullspell2
								}
							/if (!${Me.SpellReady[${Spell[${PullSpell1}].RankName}]}) {
								/delay 1s
								/echo \ay Pull spell \am "${Spell[${PullSpell1}].RankName}" as an \ar SPELL \ay is not ready yet
								/goto :retrypullspell2
								}
							}
						:doneusingpullspell2
						/echo done using pull spell 2 call
						/delay 005
						/if (${Me.XTarget}) /goto :navreturn
						/if (!${Bool[${Me.XTarget}]}) /goto :retarget
						}	
|-- Using ranged weapon						
					/if (${DoRanged}) {
						/if (${DebugGuard}) {
							/echo Doing ranged navigation
							/echo ${MakeCamp.Status}
							}
|---Set distance to pull range							  
						/delay 30s ${Spawn[${GuardMob}].Distance}<200
						/delay 60s ${Spawn[${GuardMob}].LineOfSight}
						/if (${Me.XTarget}) /goto :navreturn
						/if (${MakeCamp.Status.Equal[ON]}) {
							/if (${Navigation.Active} && !${Me.Moving}) {
								/echo Stuck, restarting Nav
								/makecamp pause
								/goto :restartnav
								}
							/if (!${Spawn[${GuardMob}].LineOfSight}) {
								/goto :restartnav
								}
							}
						/nav stop
|---Set distance to pull range							  
						/if (${Spawn[${GuardMob}].Distance}>200 || !${Spawn[${GuardMob}].LineOfSight}) {
							/if (${DebugGuard}) {
								/echo \ag ${GuardMob} \ay is \ag ${Spawn[${GuardMob}].Distance}, \ay line of sight to mob = \ag {${Spawn[${GuardMob}].LineOfSight}
								}
							/goto :restartnav
							}
						/if (${Target.PctHPs}<100 || (${Target.AggroHolder.ID} && ${Target.AggroHolder.ID}!=${Me.ID})) {
							/if (${DebugGuard}) {
								/echo Someone else has target, returning....
								}								
							/target clear
							/goto :navreturn
							}
						/if (!${Me.AutoFire} && ${Target.Distance}<250 && ${Target.Distance}>30) {
							/if (${DebugGuard}) {
								/echo attacking with range item
								}
							/autofire on
							/delay 2s ${Me.XTarget}
							/autofire off
							/goto :navreturn
							}
						/if (${Target.Distance}<40) {
							/if (${DebugGuard}) {
								/echo attacking with melee
								}
							/if (${Me.AutoFire}) /autofire  off
							/attack
							/delay 2s ${Me.XTarget}
							/goto :navreturn
							}
						}
					/if (!${DoRanged}) {
						/if (${DebugGuard}) {
							/echo doing non-ranged navigation
							/echo MakeCamp status is ${MakeCamp.Status}
							}
						/delay 120s !${Navigation.Active} || ${Me.XTarget}
						/nav stop
						/if (${Spawn[${GuardMob}].Distance}>100) /goto :restartnav
						/squelch /target targetable id ${GuardMob}
						/if (${Target.PctHPs}<100 || (${Target.AggroHolder.ID} && ${Target.AggroHolder.ID}!=${Me.ID})) {
							/target clear
							/goto :navreturn
							}
						/if (${Me.Sitting}) /stand
						/delay 5s !${Me.Sitting}							
						/attack
						/if (${DebugGuard}) /echo attacking ${GuardMob}
						/delay 2s ${Me.XTarget}
						/if (${Me.XTarget}) /goto :navreturn
						/goto :retarget
						}
					:navreturn
					/if (${DebugGuard}) /ECHO NavReturn Call
					/if (${ReportEvents}) /bc /varset MATarget ${GuardMob}
					/if (${MakeCamp.CampDist}<30) {
						/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar NavReturn section, inside 30 of camp
						/if (${Me.XTarget}) /varset GuardPause 10s
						/return
						}
					/melee off
					/attack off
					/stick off
					/echo \ar RETURNING \ay loc \ag ${CampY} ${CampX} ${CampZ}
					:navreturnrestart
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						}
					/nav loc ${CampY} ${CampX} ${CampZ}
					/delay 1s
					/if (${Melee.Combat} && ${Navigation.Active} && ${Target.ID}!=${Me.ID}) {
						/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "y" " Nav Return target"
						/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "r" "/varset MATarget ${GuardMob}"
						/target ID ${Me.ID}
						/goto :navreturn
						}
					/delay 2s
					/delay 60s !${Navigation.Active}
					/if (${MakeCamp.Status.Equal[PAUSED]} && ${MakeCamp.CampDist}<30) {
						/makecamp unpause
						/goto :navreturn
						}
					/if (${Group.Members}>0 && ${MakeCamp.Status.Equal[OFF]}) {
						/if (${Bool[${Group.Member[2].ID}]}) {
							/if (${Group.Member[2].Distance}>75) {
								:navreturngroup
								/nav ID ${Group.Member[2].ID}
								/delay 1s
								/delay 60s ${Group.Member[2].Distance}<75
								/if (${Group.Member[2].Distance}>75) /goto :navreturngroup
								}
							}
						}
					/target ID ${MATarget}
					/melee on
					/squelch /face fast nolook
|------Timer between reusing guard to pull					
					/varset GuardTimer 3s
					/if (${DebugGuard}) /echo \ay EXITING \ag Guard Subroutine: \am NAV section
					/doevents
					/return
					}
				}
			}
		/if (!${RDPause} && !${GuardTimer} && !${Me.XTarget} && ${Spawn[${GuardMob}].LineOfSight} && ${Spawn[${GuardMob}].Type.NotEqual[corpse]} && ${Spawn[${GuardMob}].Type.NotEqual[untargetable]} && !${Me.Moving}) {
			/if (${DebugGuard}) /echo Targeting ${GuardMob} and line of sight is ${Spawn[${GuardMob}].LineOfSight}
			/squelch /target targetable id ${GuardMob}
			/if (${Target.ID} && ${Target.ID}==${GuardMob}) {
				/delay 5s ${Target.ID}==${GuardMob}
				/squelch /face fast nolook
				/if (${MATarget}!=${GuardMob}) /varset MATarget ${GuardMob}
				/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
				/if (${Group.MainTank.ID}==${Me.ID} && ${Spawn[${MATarget}].Named} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
				/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist} && ${Target.PctHPs}<=${EngageHPs}) {
					/face fast
					/autofire on
					/delay 10s ${Me.XTarget}
					/popup Killing ${Target.CleanName} by range
					/if (${Me.Class.ShortName.NotEqual[RNG]}) {
						/autofire off
						/delay 10s (!${Me.AutoFire})
						/if (${Me.Sitting}) /stand
						/delay 5s !${Me.Sitting}
						/killthis
						/delay 1s
						/killthis
						|/call DoMelee
						}
					} else /if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
					/popup Killing ${Target.CleanName} too close for range
					/delay 10s (${Target.Distance}<20)
					/if (${Me.Sitting}) /stand
					/delay 5s !${Me.Sitting}
					/killthis
					/delay 1s
					/killthis
					|/call DoMelee
					}
				/if (!${DoRanged} && ${Spawn[ID ${GuardMob}].PctHPs}<=${EngageHPs} && ${Target.Type.NotEqual[Mercenary]}) {
					/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
					/popup Killing ${Target.CleanName} Melee
					/delay 10s (${Target.Distance}<20)
					/if (${Me.Sitting}) /stand
					/delay 5s !${Me.Sitting}
					/stick ID ${Target.ID}
					/killthis
					/delay 1s
					/killthis
					|/call DoMelee
					}
				/if (${ReportEvents}) /${ChatChannel} /varset MATarget ${Target.ID}
				|/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "1" "y" "Guard function activated!" 
				/squelch /face fast nolook
				/delay 10s (${Target.Distance}<20)
|------Timer between reusing guard to pull				
				/varset GuardTimer 50
				/if (${DebugGuard}) /echo \ay EXITING \ag Guard Subroutine: \am Non-nav pulls
				/return
				}
			}
		/if (${gl}==${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
			/if (${DebugGuard}) /echo \ay Exiting \ag Guard sub routine because of \ar "${gl}==${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}"
			/return
			}
	/if (!${Bool[${gl}]}) {
		/echo Guard RETURN
		/return
		}
	/echo gl = ${gl} , ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}, bool = ${Bool[${gl}]}
	/if (${gl}>${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
		/echo Guard Return to prevent error
		/varset GuardTimer 3s
		/varset MATarget 999999
		/target clear
		/return
		}
	/varset GuardTimer 3s
	/next gl	
	/doevents
/echo \ay EXITING \ag Guard Subroutine: \am end of routine
	/return
	
Sub Status
|========================================
| Checks the Mana and Endurance of each group member
|	 change the minimul amounts you want the pause feature to engage at
|========================================
	/if (${GuardPause}>0) /return
	/declare i int local
	/if (${Me.Combat} || ${Me.XTarget}) /return
	/for i 5 downto 0
	/if (${Group.Member[${i}].ID} && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG,BST]} && ${Group.Member[${i}].PctMana}<50 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<40 || ${Group.Member[${i}].Type.Equal[corpse]})) {
		/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
		/delay 1s
		/varset GuardPause 60s
		/if (!${Me.Sitting}) /sit
		/delay 5s ${Me.Sitting}
		/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "4" "y" "Pausing" "w" "${Math.Calc[${GuardPause}/10]} seconds" "g" "for" "o" "${Target.CleanName}"
		}
	/next i	
	/if (${Target.ID}) /target clear
	/return

	
Sub GMChecks
	/if (${Spawn[gm].ID} && ${GMCheck}) {
		/beep
		/delay 5
		/echo GM in zome!
		/beep
		/delay 5
		/beep  
		/if (${Me.Combat} || ${Me.XTarget}) /return
		/echo Quitting
		/if (!${Me.Combat} || !${Me.XTarget}) /bcaa //q
		}
	/return
	
	
Sub HealOverTime
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (${RDPause}) /return
	/if (${Me.Casting.ID}) /return
	/if (!${Defined[HotTimer]}) {
		/call CreateTimer HotTimer 0
		}
	/if (${Select[${Spell[${HotSpell}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} && ${Me.Song[${HotSpell}].ID}) {
		/varset HotTimer ${Me.Song[${HotSpell}].Duration.TotalSeconds}s
		/return
		}
	/if (${HotTimer}<10) {
		/if (${Spawn[ID ${MainTankID}].Distance}<=${Spell[${HotSpell}].MyRange} && ${Spawn[ID ${MainTankID}].PctHPs}>=80 && ${UseTankHoT} && ${SpawnCount[npc los Range 5 110 radius 50 zradius 50 targetable]} && ${Me.CombatState.Equal[COMBAT]} && ${Me.PctMana}>10) {
			/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
			/call Cast "${HotSpell}" "${HotSpellGem}" "1s" "Check4Pad" 3
			/if (${Debug}) /echo casting ${HotSpell} from Gem ${HotSpellGem} on ${Target.CleanName}
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 g "Casting on->" m "${Target.CleanName}" g "<-with HoT" t "${HotSpell}"
			/if (${castReturn.Equal[CAST_SUCCESS]}) /varset HotTimer ${Spell[${Spell[${HotSpell}].RankName}].Duration.TotalSeconds}s
			/if (${Debug} && ${castReturn.Equal[CAST_SUCCESS]}) /echo Cast Successful
			|/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) /varset HotTimer 30s
			/varset HotTimer 30s
			/varset castReturn CAST_CANCELLED
			}
		}
	/return	

Sub HealXTarget
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/declare X int local 
	/declare i int local 1
|--------Loops Through extended target window For Pets and Players to heal.
	/for X 1 to ${Me.XTarget}
	/if (${Me.XTarget[${X}].ID} && ${Me.XTarget[${X}].Type.NotEqual[NPC]}) {
		/if (${Me.XTarget[${X}].PctHPs}<=${PetHealPct} && ${Me.XTarget[${X}].Distance}<=200 && ${Me.XTarget[${X}].Type.Equal[PET]} && ${HealPets}) /call DoHeal ${Me.XTarget[${X}].ID} Pet
		/if (${Me.XTarget[${X}].Type.NotEqual[Corpse]} && ${Me.XTarget[${X}].PctHPs}<=${TankHealPct} && ${Me.XTarget[${X}].Distance}<=${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.XTarget[${X}].Type.Equal[PC]} && ${Select[${Me.XTarget[${X}].Class.ShortName},WAR,PAL,SHD]}) /call DoHeal ${Me.XTarget[${X}].ID} Tank
		/if (${Me.XTarget[${X}].Type.NotEqual[Corpse]} && ${Me.XTarget[${X}].PctHPs}<=${HealPct} && ${Me.XTarget[${X}].Distance}<=${Int[${Spell[${FastHealID}].MyRange}]} && ${Me.XTarget[${X}].Type.Equal[PC]} && ${Select[${Me.XTarget[${X}].Class.ShortName},MNK,NEC,BRD,WIZ,ENC,CLR,DRU,MAG,SHM,ROG,BST,BER,RNG]}) /call DoHeal ${Me.XTarget[${X}].ID} Fast
		}
	/next X
	/return	
	
Sub HolyShit(MobName)
	/declare i int local
	/declare LastCastReturn string local ${castReturn}
	/for i 1 to ${TotalShit}
		/if (!${RDPause} && !${Me.Buff[${HolyShit${i}}].ID} && ${Me.PctHPs}<${HolyShitHp${i}} && (${Me.SpellReady[${Spell[${HolyShit${i}}].RankName}]} || ${Me.AltAbilityReady[${HolyShit${i}}]} || ${Me.CombatAbilityReady[${HolyShit${i}}]} || (${FindItem[${HolyShit${i}}].ID} && !${FindItem[${HolyShit${i}}].TimerReady}))) {
			/if (${HolyShitType${i}}==1 && ${Target.ID}!=${Me.ID}) /target targetable id ${Me.ID}
			/if (${HolyShitType${i}}==2 && ${Spawn[npc targetable ${MobName}].ID} && ${Target.ID}!=${Spawn[npc targetable ${MobName}].ID}) /target targetable ${MobName}
			/delay 10s !${Me.Casting.ID} || ${Me.Class.ShortName.Equal[BRD]}
			/if (${Me.CombatAbilityReady[${HolyShit${i}}]}) {
				/doability ${HolyShit${i}}
			 /	varset castReturn CAST_SUCCESS
			} else {
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Select[${HolyShitGem${i}},item,alt]} && ${Me.Gem[${HolyShit${i}}]}) {
					/squelch /twist once ${Me.Gem[${HolyShit${i}}]}
					/varset castReturn CAST_SUCCESS
					/delay ${Spell[${HolyShit${i}}].MyCastTime.TotalSeconds}s
					/delay 1s
					/call DoCastingEvents
				} else {
					/if (${Me.Class.ShortName.NotEqual[BRD]} || ${Select[${HolyShitGem${i}},item,alt]}) {
						/if (${Me.Class.ShortName.Equal[BRD]}) {
							/if (${Twist}) /squelch /twist off
							}
						/if (${Me.Casting.ID}) /call Interrupt
						/delay 5s !${Me.Casting.ID}        
						/call Cast "${HolyShit${i}}" ${HolyShitGem${i}} 10s SpellFiller 3
						/if (${Me.Class.ShortName.Equal[BRD]}) {
							/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
							}
					}
				}
			}
			/if (${HolyShitRUN${i}}) /call HolyShitRun "${MobName}"
			/if (${castReturn.Equal[CAST_SUCCESS]}) {
				/if (${LastCastReturn.NotEqual[CAST_SUCCESS]}) /varset castReturn CAST_CANCELLED
				/return
			}
		}
	/next i
	/if (${LastCastReturn.NotEqual[CAST_SUCCESS]}) /varset castReturn CAST_CANCELLED
	/return

Sub HolyShitRun(AggroMob)
	/declare i int local
	/for i 1 to 3
		/if (!${RDPause} && ${Spawn[${MA${i}}].ID}) {
		/squelch /face fast nolook id ${NearestSpawn[pc ${MA${i}}].ID}
			/keypress forward hold
			/delay 1s ${Spawn[npc targetable id ${AggroMob}].Distance}>${Spawn[npc targetable id ${AggroMob}].MaxRange}+10
			/keypress back
			/return
		}
	/next i
	/return	

Sub LoadVar(IniSection,IniVar,IniValue,MacroVar,MyIni,Function,VarType)
	/if (!${Defined[${MacroVar}]} && ${Defined[VarType]}) /declare ${MacroVar} ${VarType} outer
	/if (${Function.Equal[LOAD]}) {
		/declare IniString string local ${Ini[${MyIni},${IniSection},${IniVar},NOTFOUND]}
		/varset ${MacroVar} ${IniString}
	}
	/if (${Defined[IniString]}) {
		/if (${IniString.Equal["NOTFOUND"]} && ${Function.Equal[LOAD]}) {
			/varset ${MacroVar} ${IniValue}
			/ini ${MyIni} "${IniSection}" "${IniVar}" "${${MacroVar}}"
			}
		}
	/if (${Function.Equal[SAVE]}) {
		/ini ${MyIni} "${IniSection}" "${IniVar}" "${${MacroVar}}
		}
	/return

Sub LootCheck
	/declare j int local
	/if (${AdvLoot.SCount}>0) {
		/for j 0 to ${AdvLoot.SCount}
			/if (${AdvLoot.SList[${j}].AutoRoll}!=TRUE) /advloot shared ${j} autoroll
		/next j
		}
	/return
	
Sub MA1Dead
|========================================
|Idea based on Nytemyst's AFCleric
|========================================
	/if (!${Spawn[ID ${MainTankID}] || ${Spawn[ID ${MainTankID}].Type.Equal[Corpse]}) {
		/call AnnounceMessage "${ChatChannel}" 3 r "OH NO! ${MA1} is dead!" m "${MA2}" g "Time to step up!"
		/if (${ChangeTank}==TRUE && ${UseGroupMA}==FALSE && ${UseRaidMA}==FALSE) {
			/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${Spawn[${MA2}].CleanName}"
			/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "${Spawn[${MA3}].CleanName}"
            /if (${UseGroupTank}) {
                /call Event_ToggleVar Turning off GroupTank usage (/usegrouptank)!,UseGroupTank,GeneralStuff,UseGroupTank,
				}
			}
		}
	/return	
	
Sub MercStuff
	/if (!${RDPause} && ${DoMercStance} && ${Mercenary.State.Equal[ACTIVE]} && ${MercStanceTimer}<10) {
		/if (${Me.CombatState.NotEqual[COMBAT]} && ${Mercenary.Class.Name.NotEqual[Warrior]} && ${Mercenary.Stance.NotEqual[Balanced]}) /stance Balanced
		/if (${Mercenary.Stance.NotEqual[Balanced]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]}) && (${Spawn[${MATarget}].PctHPs}>95 || ${Group.Member[${Me.Mercenary.CleanName}].PctAggro}>65)) /stance Balanced
		/if ((${Target.Level}>=${Me.Level}+2 || ${Spawn[${MATarget}].Named} || ${Me.XTarget}>1) && ${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[PC]} && ${Mercenary.Stance.NotEqual[Reactive]} && ${Mercenary.Class.Name.Equal[Cleric]}) /stance reactive
		/if (${Mercenary.Stance.NotEqual[Burn]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]}) && ${Spawn[${MATarget}].PctHPs}<95 && ${Group.Member[${Me.Mercenary.CleanName}].PctAggro}<85 && ${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[PC]}) /stance Burn
		
		/if (${DoMercAssist} && ${Me.CombatState.Equal[COMBAT]} && ${Mercenary.Stance.NotEqual[Passive]} && ${Mercenary.Class.Name.NotEqual[Cleric]} && ${Spawn[${MATarget}].PctHPs}<${MercEngageHPs} && ${Spawn[${MATarget}].Distance}<${NPCRadius}) /mercassist
		/varset MercStanceTimer 6s
		}
	/if (${DoMercAssist}) {
		/if (!${Defined[MercAssistTimer]}) /call CreateTimer MercAssistTimer
		/if (${Window[MMGW_ManageWnd].Child[MMGW_AssistModeCheckbox].Checked}) /notify MMGW_ManageWnd MMGW_AssistModeCheckbox LeftMouseUp
		/if (${DoMercAssist} && ${Bool[!${MercAssistTimer}]} && ${Me.CombatState.Equal[COMBAT]} && ${Mercenary.Stance.NotEqual[Passive]} && ${Mercenary.Class.Name.NotEqual[Cleric]} && ${Spawn[${MATarget}].PctHPs}<${MercEngageHPs} && ${Spawn[${MATarget}].Distance}<${NPCRadius}) {
			/mercassist
			/varset MercAssistTimer 10s
			}
		}
	/if (!${RDPause} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) {
		/notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/delay 10s ${Mercenary.State.Equal[ACTIVE]}
		}
	/return		
	
Sub MoveStuff
	/call DoMelee
	/if (${FollowFlag} && ${Spawn[${FollowGuy}].ID} && ${Spawn[${FollowGuy}].Distance}>${LeashDistance} && !${Me.Moving} && !${Melee.Combat}) {
		/target targetable id ${FollowGuy}
		/delay 1s ${Target.ID}==${FollowGuy}
		/squelch /stick hold uw
		/delay 1s
		}
	/if (${Stick.Status.Equal[ON]} && ${FollowFlag} && ${TravelMode} && !${Me.Invis} && !${Me.CombatState.Equal[COMBAT]}) {
		/if ((${FindItem[${InvisibilitySpell}].ID} && ${InvisibilityGem.Equal[item]}) || (${InvisibilityGem.Equal[alt]} && ${Me.AltAbilityReady[${InvisibilitySpell}]})|| ${Me.Book[${InvisibilitySpell}]}) {
			/squelch /target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			/call Cast "${InvisibilitySpell}" ${InvisibilityGem} 5s Check4Pad
			} else {
			/squelch /stick off
			/varset FollowFlag FALSE
			/varset FollowGuy 0
			}
		}
	/if (${Stick.Status.Equal[ON]} && !${Me.Moving} && ${FollowFlag} && ${Spawn[${FollowGuy}].ID} && ${Target.ID}!=${Spawn[${MATarget}].ID} && ${Spawn[${FollowGuy}].Distance}<${LeashDistance}) /call AutoSit
	/return
	
Sub Named
	/call DoStuff Named
	/return	

Sub Nukeit
	/if (${RDPause}) /return
	/if (${Debug}) /echo \ag Entering \ao Nukeit sub
	/if (${Cursor.ID}) /autoinventory
	/declare i int local
	/for i 1 to ${NukeTotal}
		/if (!${Spawn[${MATarget}].ID} || ${MATarget}==999999) {
			/if (${Debug}) /echo \ar stopping Nukes, no target!!
			/break
			}
		/if (${Debug}) /echo \ay starting for loop with \ao ${Nuke${i}}
		/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${PetAssistTimer}) {
			/call PetAttackStuff
			/if (${Debug}) /echo \ay Return from pet attack is ${Macro.Return}
			}
		/if (${DoDebuffs} || ${DoDoTs} || ${DoManaTaps} || ${DoMez}) {
			/call DebuffIt
			/if (${Debug}) /echo \ay Return from Debuffit is ${Macro.Return}
			}
		/if (${HealGroup} && !${CheckGroupTimer}) {
			/call EvaluateGroup
			/if (${Debug}) /echo \ay Return from EvaluateGroup is ${Macro.Return}
			}
|-----Check to be sure your toon has the Nuke spell, item, or AA		
		/if (!${Select[${NukeGem${i}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${Nuke${i}}].RankName}]}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} not in spellbook.
			/goto :nukeend
			}
		/if (${NukeGem${i}.Equal[item]} && !${FindItem[${Nuke${i}}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} is marked as an item and not in inventory.
			/goto :nukeend
			}
		/if (${NukeGem${i}.Equal[alt]} && !${Me.AltAbility[${Nuke${i}}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} is marked as an AA, you don't appear to have.
			/goto :nukeend
			}
|-----
		/if (${Debug}) /echo \ay Passed spell/alt/item check
		/if (!${Select[${NukeGem${i}},alt,item,comb]} && !${Me.Gem[${Nuke${i}}]}) {
			/memorize "${Nuke${i}}" ${NukeGem${i}.Right[-3]}
			}
		/if (${Target.ID}!=${MATarget} && ${Spawn[id ${MATarget}].ID} && ${Spawn[${MATarget}].Type.NotEqual[corpse]}) {
			/target targetable id ${MATarget}
			/delay 5s ${Target.ID}==${MATarget}
			/if (${Debug}) /echo \ay targeting ${Spawn[${MATarget}].CleanName}
			}
		/call EvaluateCondition "${NukeCondition${i}}"
		/if (${Debug}) /echo \ay evaluating condition ${Macro.Return}
|		/if (!${RDPause} && ${Macro.Return} && (${NukeSpellSet${i}}==${WhichNuke} || !${NukeSpellSet${i}}) && ((${Me.SpellReady[${Nuke${i}}]} || (!${Me.Gem[${Nuke${i}}]} && ${Me.Book[${Nuke${i}}]})) || ${Me.AltAbilityReady[${Nuke${i}}]} || ${NukeGem${i}.Equal[item]}) && ${Target.PctHPs}>${NukeStopHPs${i}} && ${Target.PctHPs}<${NukeStartHPs${i}} && ${Me.PctMana}<=${NukeMaxMana${i}} && ${Me.PctMana}>=${NukeMinMana${i}} && (!${SitTimer} || ${Me.Gem[${Nuke${i}}]} || ${Me.Mount.ID}) && ${Target.ID}==${MATarget} && ${Target.LineOfSight} && ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]} && ${Target.Type.Equal[NPC]}) {
		/if (${Debug}) /echo \ag Entering \ao Nuke cast call checks
		/if (!${RDPause} && ${Macro.Return}) {
			/if (${Debug}) /echo \ay The nuke is listed as spell set \ag ${NukeSpellSet${i}} \ay we are using \ag ${WhichNuke}
			/if (${NukeSpellSet${i}}==${WhichNuke} || !${NukeSpellSet${i}}) {
				/if (${Debug} && !${Select[${NukeGem${i}},alt,item,comb]}) /echo \ay is the spell ready? \ao ${Me.SpellReady[${Nuke${i}}]}
				/if (${Debug} && ${NukeGem${i}.Equal[alt]}) /echo \ay is the AA ready ${Me.AltAbilityReady[${Nuke${i}}]}
				/if (${Debug} && ${NukeGem${i}.Equal[item]}) /echo \ay is an item an timer is ${FindItem[${Nuke${i}}].TimerReady}
				/if (${Me.SpellReady[${Nuke${i}}]} || ${Me.AltAbilityReady[${Nuke${i}}]} || (${NukeGem${i}.Equal[item]} && !${FindItem[${Nuke${i}}].TimerReady})) {
					/if (${Debug}) /echo \ay Passed ready check
					/if (${Target.PctHPs}>${NukeStopHPs${i}}) {
						/if (${Debug}) /echo \ay  Target HPs to nuke stop HPs \ao ${Target.PctHPs}>${NukeStopHPs${i}}
						/if (${Target.PctHPs}<${NukeStartHPs${i}}) {
							/if (${Debug}) /echo \ay Target HPs to Nuke Start HPs \ao ${Target.PctHPs}<${NukeStartHPs${i}}
							/if (${Me.PctMana}<=${NukeMaxMana${i}}) {
								/if (${Debug}) /echo \ay My mana to Nuke Max Mana \ao ${Me.PctMana}<=${NukeMaxMana${i}}
								/if (${Me.PctMana}>=${NukeMinMana${i}}) {
									/if (${Debug}) /echo \ay My mana to Nuke min mana \ao ${Me.PctMana}>=${NukeMinMana${i}}
									/if (!${SitTimer} || ${Me.Gem[${Nuke${i}}]} || ${Me.Mount.ID}) {
										/if (${Debug}) /echo \ay Sit Timer \ao ${SitTimer} \ay || Nuke is loaded in gem \ag ${Me.Gem[${Nuke${i}}]} \ao || My mount ID is  \ao ${Me.Mount.ID}
										/if (${Target.ID}==${MATarget}) {
											/if (${Debug}) /echo \ay my target ID compared to MATarget ID is \ao ${Target.ID}==${MATarget}
											/if (${Target.LineOfSight} && ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]}) {
												/if (${Debug}) /echo \ay Target line of sight is \ao ${Target.LineOfSight} \ao and Target distance compared to spell range \ao ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]}
												/if (${Target.Type.Equal[NPC]}) {
													/if (${Debug}) /echo \ay is target a NPC? \ao ${Target.Type.Equal[NPC]}
													/if (${Debug}) /echo \ay  Ready to cast \ao ${Nuke${i}}
													/call Cast "${Nuke${i}}" ${NukeGem${i}} 5s Check4Pad 3
													/if (${Debug}) /echo \ay called for cast of \ao ${Nuke${i}} \ag ${NukeGem${i}}
													/if (${castReturn.Equal[CAST_SUCCESS]} && ${DoConcussion}) {
														/if ((!${SitTimer} || ${Me.Gem[${ConcussionSpell}]} || ${Me.Mount.ID}) || ${Select[${ConcussionGem},item,alt]}) /call Cast "${ConcussionSpell}" ${ConcussionGem} 5s Check4Pad
														}
													/if (${Debug}) /echo \ay cast return = \ao ${castReturn}
													/varset NukeTimer ${NukeDelay}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	/if (${Debug}) /echo \ay ending for loop of Nuke \ao ${i} ${Nuke${i}}
	:nukeend	
	/next i
	/call MoveStuff
	/if (${Debug}) /echo \am Exiting \ao Nuke sub
	/return


Sub ParseMessage(Replace,NewText)
	/declare Lefttext  string local
	/declare Righttext string local
	/if (!${Parse.Find[${Replace}]}) /return
	:Recheck
	/if (${Parse.Find[${Replace}]}) {
		/if (${Parse.Find[${Replace}]}>1) /varset Lefttext ${Parse.Left[${Math.Calc[${Parse.Find[${Replace}]}-1]}]}
		/if (${Parse.Find[${Replace}]}<${Math.Calc[${Parse.Length}-(${Replace.Length}+1)]}) /varset Righttext ${Parse.Right[${Math.Calc[${Parse.Length}-(${Parse.Find[${Replace}]}+${Replace.Length})]}]}
		/varset Parse ${Lefttext}${NewText}
		/varset Lefttext ${Parse} ${Righttext}
		/varset Parse ${Lefttext}
		/goto :Recheck
	}
	/return
	
Sub PetAttackStuff
	/if (!${Me.Pet.ID}) /return
	/if (${MATarget}!=999999 && ${Target.ID}==${Spawn[${MATarget}].ID} && !${RDPause} && !${Me.Pet.Combat} && ${Target.PctHPs}<(${EngageHPs}-1)) {
		/pet attack
		/delay 050
		/if (${SpawnCount[pet radius ${NPCRadChk} zradius 50]}<1) {
			/pet qswarm
			}
		}
	/varset PetAssistTimer ${AssistDelay}
	/if (${Mercenary.State.Equal[ACTIVE]}) /call MercStuff
	/return 1


Sub PetStuff
	/declare SusMinion 		bool 	local FALSE
	/declare SwapItemBack 	int    	local 0
	/declare OldItemName  	string 	local NOTFOUND
	/declare SlotName     	string 	local NOTFOUND
	/if (${Debug}) /echo \ag Entering \ao PetStuff
	/if (!${RDPause} && ${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]}) {
		/if (${DebugPet}) {
			/echo I am number \ag ${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]} \ao in accepted pet list
			/echo UsePet is \ay ${UsePet} ${If[${Me.Pet.ID},\ao I have a pet,\ay I do not have a pet]}
			}
		/if (${UsePet} && (!${Me.Pet.ID} && !${KillFlappy}) || (${KillFlappy} && !(${Me.Buff[${PetSpell}].ID} || ${Me.Buff[Familiar: ${PetSpell}].ID}))) {
			/if (${Debug}) /echo pet ID ${Me.Pet.ID} , if NULL we proceed
			/if (${Me.Combat} && ${Me.ID}==${Group.MainTank.ID}) /return
			| See if we have a suspended pet
	|		/if (${Me.AltAbilityReady[suspended minion]}) /call Cast "suspended minion" alt 3s SpellFiller 3
	|		/delay 5s ${Me.Pet.ID}
			/if (${Me.Pet.ID}) /return
			/if (${FindItem[${PetFocus}].InvSlot}>21) {
				/varset SwapItemBack int    local 1
				/varset OldItemName  string local ${InvSlot[${FindItem[${PetFocus}].WornSlot[1].ID}].Item.Name}
				/varset SlotName     string local ${FindItem[${PetFocus}].WornSlot[1].Name}
				/call SwapItem "${PetFocus}" ${SlotName}
				}
			/if (${Debug}) /echo Casting pet spell ${PetSpell}
			/if (!${Me.Book[${Me.Book[${Spell[${PetSpell}].RankName}]}].ID}) {
				/call AnnounceMessage ${ChatChannel} 3 r "ERROR casting pet spell" y "${PetSpell}" r "not in spellbook"
				/return
				}
			/call Cast "${PetSpell}" ${PetGem} 35s Check4Pad
			/if (${SwapItemBack}) /call SwapItem "${OldItemName}" ${SlotName}
			/delay 2s ${Me.Pet.ID}
			}
		/if (${Me.Pet.ID}) {
			/if (${PetShrink} && ${Me.Pet.Height}>1.5) {
				/if (${Target.ID}!=${Me.Pet.ID}) /squelch /target targetable id ${Me.Pet.ID}
				/delay 1s ${Target.ID}==${Me.Pet.ID}
				/if ((!${Me.Book[${Me.Book[${Spell[${PetShrinkSpell}].RankName}]}].ID} && ${PetShrinkGem.NotEqual[item]}) || (!${FindItem[${PetShrinkSpell}].ID} && ${PetShrinkGem.Equal[item]})) {
					/if (${PetShrinkGem.NotEqual[item]}) /call AnnounceMessage ${ChatChannel} 3 r ERROR! m "${PetShrinkSpell}" y "marked as SPELL and not in spellbook"
					/if (${PetShrinkGem.Equal[item]}) /call AnnounceMessage ${ChatChannel} 3 r ERROR! m "${PetShrinkSpell}" y "marked as ITEM and not in inventory"
					/goto :skippetshrink
					}
				/call Cast "${PetShrinkSpell}" ${PetShrinkGem} 6s Check4Pad
				/call Cast "${PetShrinkSpell}" ${PetShrinkGem} 6s Check4Pad	
				}
			:skippetshrink
			/if (${Me.Class.ShortName.Equal[MAG]}) {
				/if (${DoPetToys} && !${Me.Pet.Primary}) /call PetToys ${Me.Pet.ID}	
				}
			}
		}
	/if (!${RDPause} && ${DoPetBuffs} && ${Me.Pet.ID}) {
		/if (${Debug}) /echo  \ag Entering \ao Pet Buff, \ay PetBuffTotal = \ag ${PetBuffTotal}
		/declare i int local
		/for i 1 to ${PetBuffTotal}
			/if (${Debug}) /echo Checking pet buff ${i} : \ag ${PetBuff${i}}
			/if (${Me.PctMana}<${PetMana} && !${Select[${PetBuffGem${i}},alt,item]}) {
				/if (${Debug}) /echo \ar mana = ${Me.PctMana}<${PetMana} , buff is a spell
				/return
				}
			/if (${Me.Pet.Buff[${PetBuffIcon${i}}]}) {
				/continue
				}
			/if (!${RestrictedList.Find[|${PetBuffID[${i}]}|]} && (${Me.Pet.Distance}<${Int[${Spell[${PetBuffID[${i}]}].MyRange}]} || ${Me.Pet.Distance}<${Spell[${PetBuffID[${i}]}].AERange}) && ${Spell[${PetBuffIcon${i}}].StacksPet[0]} && ((!${SitTimer} || ${Me.Gem[${PetBuff${i}}]} || ${Me.Mount.ID}) && (!${Me.Gem[${PetBuff${i}}]} || ${Me.SpellReady[${Spell[${PetBuff${i}}].RankName}]}) || (${PetBuffGem${i}.Equal[item]} && !${FindItem[${PetBuff${i}}].Timer}) || (${PetBuffGem${i}.Equal[alt]} && ${Me.AltAbilityReady[${PetBuff${i}}]}))) {
				/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
				/if (${Target.ID}!=${Me.Pet.ID}) /squelch /target targetable id ${Me.Pet.ID}
				/delay 1s ${Target.ID}==${Me.Pet.ID}
				/if (${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Buffing" m "${Me.Pet.CleanName}" g "with" o "${PetBuff${i}}"
				/doevents flush Restricted
				/if (${Debug}) /echo  CASTING \ay ${PetBuff${i}} \ao from \ay ${PetBuffGem${i}}
				/call Cast "${PetBuff${i}}" ${PetBuffGem${i}} 10s Check4Pad
				/call DoRestrictedEvents ${PetBuffID[${i}]}
				/return
			}
		/next i
		/varset PetBuffTimer ${PetBuffRecheck}
	}
	/if (${KillFlappy} && ${Me.Pet.ID}) /pet get lost
	/call MoveStuff
	/if (${Debug}) /echo \am Exiting pet buff
	/return


Sub PetToys(int ThePetID)
	/if (${Me.CombatState.Equal[COMBAT]}) {
		/call AnnounceMessage "${ChatChannel}" 2 r error y "I'm in a fight, can't give pet toys..."
		/return
		}
	/if (${DebugPet}) /echo \ag Entering \ao Sub PetToys \ao pet name \ay ${Spawn[ThePetID].CleanName}
	/if (!${DoPetToys}) /return
	/if (${Spawn[${ThePetID}].Distance3D}>250) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "is to far away"
		/goto :SkipPetToy
		}
	/if (!${Spawn[${ThePetID}].LineOfSight}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "can't be seen from here"		
		/goto :SkipPetToy
		}
	/if (!${Spawn[${ThePetID}].ID}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "doesn't appear to exist"		
		/goto :SkipPetToy
		}
	/if (${Spawn[${ThePetID}].Type.NotEqual[pet]}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "doesn't appear to be a pet"		
		/goto :SkipPetToy
		}		
	/declare PT1 int local 1
	/declare PT2 int local 1
	/declare GrabItem int local 0
	/declare PetToySpell string local 0
	/declare FullText string local
	/declare 2ndPart string local
	/declare 3rdPart string local
	/declare PetToysTemp string local ${PetToysGave}
	/call OpenInvSlot
	/if (${BagNum}==0) {
		/call AnnounceMessage ${ChatChannel} 2 r "Error," y "You must have an empty Top Inventory slot for Pet Toys to work."
		/varset DoPetToys 0
		/return
        }
	/if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
		/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 y "Inventory is" r "FULL"
		/varset DoPetToys 0
		/return
        }
	/for PT1 1 to ${PetToys.Size}
		/if (${DebugPet}) {
			/echo PetToys.Size = ${PetToys.Size}
			/echo 1: ${PetToys${PT1}}
			/echo 2: ${PetToysTemp}
			/echo 3: ${PetToys${PT1}.Equal[Null]} || ${PetToysTemp.Find[${Me.Pet.CleanName}]} && ${PetToysTemp.Find[${PetToys${PT1}}]})
			}
		/if (${PetToys${PT1}.Equal[Null]} || ${PetToysTemp.Find[${Me.Pet.CleanName}]} && ${PetToysTemp.Find[${PetToys${PT1}}]}) /continue
		/if (${ThePetID}==${Me.Pet.ID} && ${PT1}!=1) {
			/continue
			}
		|========================================
		| Are we handing weapons to the pet
		|========================================
		/if (${PetToys${PT1}.Arg[2,|].Length}) {
			/varset FullText ${PetToys${PT1}}
			/varset PetToySpell ${PetToys${PT1}.Arg[1,|]}
			/varset 2ndPart ${PetToys${PT1}.Arg[2,|]}
			/varset 3rdPart ${PetToys${PT1}.Arg[3,|]}
			} else {
			/varset PetToySpell ${PetToys${PT1}}
			}
|		/if (${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]} || ${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]}) /continue
		|========================================
		| Check for pet toy spells in book to prevent double casting of items
		|========================================
		/if (!${Me.Book[${Me.Book[${Spell[${PetToySpell}].RankName}]}].ID} && ${PetToySpell.NotEqual[NULL]}) {
			/call AnnounceMessage "${ChatChannel}" 2 y "${PetToySpell}" r "NOT IN SPELLBOOK!!"
			/continue
			}
		/if (${Spell[${PetToySpell}].RankName.ID}) {
			/target ${Me}
			/delay 50
			/call Cast "${PetToySpell}" ${BuffGem} 5 SpellFiller 3
			/if (!${PetToysTemp.Find[${Me.Pet.CleanName}]}) {
				/ini "${RDIni}" "Pet" "PetToysGave" "${Me.Pet.CleanName}"
				/varset PetToysTemp ${Ini[${RDIni},Pet,PetToysGave]}
				}
			/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 g "Summoning pet toy " o "${PetToySpell}"
			/delay 5s ${Cursor.ID}
			/if (${Bool[${Cursor.Name.Find[visor]}]} || ${Bool[${Cursor.Name.Find[muzzle]}]}) {
				/call GiveTo "${Cursor}" ${ThePetID}
				}
			/if (!${Cursor.ID}) /return
		|========================================
		| Check if spell has summoned a bag or folded pack
		|========================================
			/if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
		|========================================
		| If item is in Inv Slot exchange it with bag on cursor
		|========================================
				/if (${InvSlot[pack${PT1}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
		:Unfolded
				/delay 2s ${Cursor.ID}
		|========================================
		| Drop exchanged item into inventory
		|========================================
				/autoinventory
				/delay 1s
		|========================================
		| If folded pack right click to convert to phantom satchel
		|========================================
				/if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
					/nomodkey /itemnotify pack${BagNum} rightmouseup
					/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 g "Opening" o "${InvSlot[pack${BagNum}].Item.Name}"
					/delay 3s
		|========================================
		| Return to top to drop bag into inventory
		|========================================
					/goto :Unfolded
					}
				}
			/if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
		| Open the bag
				/nomodkey /itemnotify pack${BagNum} rightmouseup
				/delay 10
				/if (${Debug}) /echo ${PT1} ${PetToySpell} ${2ndPart} ${3rdPart}
				/if (${2ndPart.Length} && ${FindItemCount[${2ndPart}]} && !${PetToysTemp.Find[${2ndPart}1]}) {
					/call GiveTo "${2ndPart}" ${ThePetID}
					/varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
					/ini "${RDIni}" "Pet" "PetToysGave" "${PetToysTemp}"
					}
				/if (${3rdPart.Length} && ${FindItemCount[${3rdPart}]} && !${PetToysTemp.Find[${3rdPart}2]}) {
					/call GiveTo "${3rdPart}" ${ThePetID}
					/varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
					/ini "${RDIni}" "Pet" "PetToysGave" "${PetToysTemp}"
					}
				/if (!${2ndPart.Length}) {
					/for PT2 0 to ${InvSlot[pack${BagNum}].Item.Container}
					/if (${InvSlot[pack${BagNum}].Item.Item[${PT2}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${PT2}].Name.Length}) {
						/call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${PT2}].Name}" ${ThePetID}
						}
					/delay 10
					/next PT2
					/if (${PT2}>=8 && !${PetToysTemp.Find[${PetToySpell}]}) {
						/varset PetToysTemp ${PetToysTemp}|${PetToySpell}
						/ini "${RDIni}" "Pet" "PetToysGave" "${PetToysTemp}"
						}
					}
				}
			/if (${Cursor.Name.Find[Summoned:]}) {
				/call GiveTo "${Cursor.Name}" ${ThePetID}
				/varset PetToysTemp ${PetToysTemp}|${PetToySpell}
				/ini "${RDIni}" "Pet" "PetToysGave" "${PetToysTemp}"
				}
			/if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
			/if (${Window[InventoryWindow].Open}) /keypress inventory
			/goto :SkipPetToy
			}
:SkipPetToy
    |========================================
    | Reset spell vars
    |========================================
		/if (${FullText.Arg[2,|].Length}) {
			/varset FullText
			/varset 2ndPart
			/varset 3rdPart
			}
		/next PT1
	/if (${Window[InventoryWindow].Open}) /keypress inventory
	/varset PetToysDone 1
	/doevents flush
	/if (${Debug}) /echo \ar Exiting \ao Sub PetToys
	/return	

Sub OpenInvSlot
	|========================================	
	| Must have at least 2 inv slots open in order to swap bags and items
	|========================================
	/if (${BagNum}) /return
	/declare i int local
	/varset BagNum 0
	/for i 1 to 10
	/if (${InvSlot[pack${i}].Item.Container}) /goto :NextSlot
	/if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
		/if (${Me.FreeInventory}>=2) /varset BagNum ${i}
		|/if (${InvSlot[pack${i}].Item.ID}==0) /varset BagNum ${i}
		}    
	/if (${BagNum}) {
		/echo Inventory slot ${i} is empty using that one.
		/call AnnounceMessage "${ChatChannel}" 1 y "Inventory slot ${BagNum} is open!"
		/delay .5
		/return
		}
	:NextSlot
        /next i
	/return	

 Sub GiveTo(string GItem, int GTarget)
	/if (${DebugPet}) /echo \ag Entering \ao Sub Sub GiveTo
        /declare ItemSummoned int local 0
        /if (${Target.ID}!=${GTarget}) {
            /target id ${GTarget}
            /delay 2s ${Target.ID}==${GTarget}
			}
:GiveToDistanceRestart			
        /if (${Target.Distance}>5 && ${Target.Distance}<=100) {
            /moveto id ${Target.ID} mdist 5
            /delay 50 ${MoveTo.Stopped}
			}
       /if (${Target.Distance}>5) {
			/echo Error, pet ${Spawn[${GTarget}].CleanName}to far away, trying to /moveto again
			/goto :GiveToDistanceRestart
			}			
        /if (!${Cursor.ID} && ${FindItemCount[=${GItem}]}>0) {
            /shift /itemnotify "${GItem}" leftmouseup
            /delay 20 ${Cursor.ID}
			}
        /while (${Cursor.ID} && ${Cursor.NoRent}) {
            /if (${Cursor.ID}==${FindItem[=${GItem}].ID}) {
                /varset ItemSummoned 1
                /nomodkey /click left target
				}
            /delay 1s
			}
        /delay 30 ${Window[GiveWnd].Open}
        /if (${ItemSummoned} && ${Window[GiveWnd].Open}) {
            /notify GiveWnd GVW_Give_Button leftmouseup
            /echo Giving ${GItem} to ${Target.CleanName}
			} else {
            /echo Item is NOT SUMMONED canceling trade
            /notify GiveWnd GVW_Cancel_Button leftmouseup
			}
        /delay 15 
	| New pet patch gives back item if pet has equipped. Delete item from cursor.
        /if (${Cursor.ID} && (${Cursor.NoRent} || ${Cursor.Name.Find[muzzle]} || ${Cursor.Name.Find[visor]} || ${Cursor.Name.Find[belt]}) && ${Cursor.ID}==${FindItem[=${GItem}].ID}) {
            /while (${Cursor.ID}) {
                /destroy
                /delay 10
				}
			}
        /delay 200 !${Window[GiveWnd].Open} 
	/if (${DebugPet}) /echo \ag Exiting \ao Sub GiveTo
	/return
	
Sub PopulateNPCs
	/varset LastSpawnCount ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}
	/if (${Me.Pet.ID} && ${PetID}!=${Me.Pet.ID}) /varset PetID ${Me.Pet.ID}
	/if (!${Spawn[${PetID}].ID} || ${Spawn[${PetID}].Type.Equal[corpse]}) /varset PetID 0
	/call RemoveNPCs
	/varset VarOldNPCCount ${VarNPCCount}
	/declare NPCID       int local
	/declare a           int local
	/declare b           int local
	/declare Compare     int local
	/declare NPCsInRange int local ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}
	/for b 1 to ${NPCsInRange}
		/if (${VarNPCCount}>=${MaxMobs}) /return
		/varset NPCID 0
		/varset NPCID ${NearestSpawn[${b},npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4].ID}
		/if (${NPCID} && !${Spawn[${NPCID}].Master.Type.Equal[PC]} && ${Spawn[${NPCID}].Type.NotEqual[corpse]} && (${Spawn[${NPCID}].ConColor.NotEqual[GREEN]} || ${DebuffGreens})) {
			/varset Compare 0
			/for a 1 to ${MaxMobs}
				/if (${NPCID}==${MobList[${a}]}) /varset Compare 1
			/next a
			/if (!${Compare}) /call AddToMobList ${NPCID}
		}
	/next b
	/return
	


Sub PortUs(Line)
|--------------
|  Credit demonstar55
|--------------
/declare PortSpell string local
    /if (${Me.Class.ShortName.Equal[DRU]}) {
        /if (${Line.Equal[alra]}) /varset PortSpell Circle of Alra
        /if (${Line.Equal[arcstone]}) /varset PortSpell Circle of Arcstone
        /if (${Line.Equal[barindu]}) /varset PortSpell Circle of Barindu
        /if (${Line.Equal[blightfire]}) /varset PortSpell Circle of Blightfire Moors
        /if (${Line.Equal[brell]}) /varset PortSpell Circle of Brell's Rest
        /if (${Line.Equal[buriedsea]} || ${Line.Equal[buried]}) /varset PortSpell Circle of Buried Sea		
        /if (${Line.Equal[butcher]}) /varset PortSpell Circle of Butcher
        /if (${Line.Equal[cobalt]}) /varset PortSpell Circle of Cobalt Scar
        /if (${Line.Equal[commons]}) /varset PortSpell Circle of Commons
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset PortSpell Circle of the Combines		
        /if (${Line.Equal[dawnshroud]}) /varset PortSpell Circle of Dawnshroud
        /if (${Line.Equal[direwind]}) /varset PortSpell Circle of Direwind
        /if (${Line.Equal[domain]}) /varset PortSpell Circle of the Domain
		/if (${Line.Equal[east]} || ${Line.Equal[ekarana]}) /varset PortSpell Succor: East
        /if (${Line.Equal[feerrott]}) /varset PortSpell Circle of Feerrott
        /if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset PortSpell Circle of Great Divide
        /if (${Line.Equal[grimling]}) /varset PortSpell Circle of Grimling
        /if (${Line.Equal[grounds]}) /varset PortSpell Circle of the Grounds
        /if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset PortSpell Circle of Karana
        /if (${Line.Equal[iceclad]}) /varset PortSpell Circle of Iceclad		
        /if (${Line.Equal[lavastorm]}) /varset PortSpell Circle of Lavastorm
		/if (${Line.Equal[Lceanium]}) /varset PortSpell Circle of Lceanium 
        /if (${Line.Equal[loping]}) /varset PortSpell Circle of Loping Plains
        /if (${Line.Equal[misty]}) /varset PortSpell Circle of Misty
        /if (${Line.Equal[moors]}) /varset PortSpell Circle of Blightfire Moors		
        /if (${Line.Equal[natimbi]}) /varset PortSpell Circle of Natimbi		
        /if (${Line.Equal[nexus]}) /varset PortSpell Circle of the Nexus
        /if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset PortSpell Circle of Knowledge		
        /if (${Line.Equal[ro]} || ${Line.Equal[sro]}) /varset PortSpell Circle of Ro
        /if (${Line.Equal[shards]}) /varset PortSpell Circle of the Landing
        /if (${Line.Equal[skyfire]}) /varset PortSpell Wind of the North
		/if (${Line.Equal[slaughter]} || ${Line.Equal[wall of slaughter]}) /varset PortSpell Circle of Slaughter
        /if (${Line.Equal[south]} || ${Line.Equal[ej]} || ${Line.Equal[emerald]}) /varset PortSpell Wind of the South
        /if (${Line.Equal[steamfont]}) /varset PortSpell Circle of Steamfont
        /if (${Line.Equal[steppes]}) /varset PortSpell Circle of The Steppes
        /if (${Line.Equal[stonebrunt]}) /varset PortSpell Circle of Stonebrunt
        /if (${Line.Equal[succor]} || ${Line.Equal[evac]}) /varset PortSpell succor
        /if (${Line.Equal[surefall]}) /varset PortSpell Circle of Surefall Glade
        /if (${Line.Equal[tempest]}) /varset PortSpell Circle of the Tempest
        /if (${Line.Equal[time]}) /varset PortSpell Circle of Plane of Time
        /if (${Line.Equal[tox]}) /varset PortSpell Circle of Toxxulia
        /if (${Line.Equal[twilight]}) /varset PortSpell Circle of Twilight
        /if (${Line.Equal[undershore]}) /varset PortSpell Circle of Undershore
        /if (${Line.Equal[wakening]}) /varset PortSpell Circle of Wakening Lands
		/if (${Line.Equal[bind]}) /varset PortSpell Teleport Bind
		/if (${Line.Equal[hall]}) /varset PortSpell Teleport to Guild Hall Anchor
		/if (${Line.Equal[succor]} || ${Line.Equal[evac]}) {
			/if (${Me.AltAbilityReady[Exodus]}) {
				/varset PortSpell Succor
				} else {
				/if (${Me.Level}>=57) {
					/varset PortSpell Succor
				} else { 
					/varset PortSpell Lesser Succor
					}
				}
			}
		}
	/if (${Me.Class.ShortName.Equal[WIZ]}) {
		/if (${Line.Equal[alra]}) /varset PortSpell Alra Portal
		/if (${Line.Equal[arcstone]}) /varset PortSpell Arcstone Portal
        /if (${Line.Equal[barindu]}) /varset PortSpell Barindu Portal
		/if (${Line.Equal[blightfire]} || ${Line.Equal[moors]}) /varset PortSpell Blightfire Moors Portal
		/if (${Line.Equal[bloodfields]}) /varset PortSpell Bloodfields Portal
		/if (${Line.Equal[brell]}) /varset PortSpell Brell's Rest Portal		
        /if (${Line.Equal[cazic]}) /varset PortSpell Cazic Portal
        /if (${Line.Equal[cobalt]}) /varset PortSpell Cobalt Scar Portal
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset PortSpell Combine Portal
		/if (${Line.Equal[commons]}) /varset PortSpell Common Portal
        /if (${Line.Equal[dawnshroud]}) /varset PortSpell Dawnshroud Portal
		/if (${Line.Equal[dragonscale]}) /varset PortSpell Dragonscale Hills Portal		
		/if (${Line.Equal[ej]} || ${Line.Equal[emerald]}) /varset PortSpell Markar's Relocation		
		/if (${Line.Equal[gfay]}) /varset PortSpell Fay Portal
		/if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset PortSpell Great Divide Portal
		/if (${Line.Equal[grimling]}) /varset PortSpell Grimling Portal
        /if (${Line.Equal[grounds]}) /varset PortSpell Grounds Portal		
		/if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset PortSpell North Portal
        /if (${Line.Equal[katta]}) /varset PortSpell Katta Castrum Portal        
		/if (${Line.Equal[iceclad]}) /varset PortSpell Iceclad Portal
		/if (${Line.Equal[icefall]}) /varset PortSpell Icefall Glacier Portal
		/if (${Line.Equal[lceanium]}) /varset PortSpell Blightfire Lceanium Portal		
        /if (${Line.Equal[natimbi]}) /varset PortSpell Natimbi Portal		
		/if (${Line.Equal[nek]}) /varset PortSpell Nek Portal
		/if (${Line.Equal[nexus]}) /varset PortSpell Nexus Portal
		/if (${Line.Equal[nro]}) /varset PortSpell Ro Portal		
		/if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset PortSpell Knowledge Portal		
		/if (${Line.Equal[sarith]}) /varset PortSpell Sarith Portal
		/if (${Line.Equal[skyfire]}) /varset PortSpell Tishan's Relocation
		/if (${Line.Equal[shards]}) /varset PortSpell Shard's Landing Portal
        /if (${Line.Equal[slaughter]}) /varset PortSpell Slaughter Portal
		/if (${Line.Equal[sro]} || ${Line.Equal[ro]} || ${Line.Equal[nro]}) /varset PortSpell Evacuate Ro
        /if (${Line.Equal[sunderock]}) /varset PortSpell Sunderock Springs Portal		
		/if (${Line.Equal[tempest]} || ${Line.Equal[temple]} || ${Line.Equal[tempesttemple]}) /varset PortSpell Tempest Temple Portal
		/if (${Line.Equal[time]}) /varset PortSpell Plane of Time Portal
		/if (${Line.Equal[tox]}) /varset PortSpell Tox Portal
        /if (${Line.Equal[twilight]}) /varset PortSpell Twilight Portal
		/if (${Line.Equal[twk]} || ${Line.Equal[westkarana]}) /varset PortSpell West Karana Portal
		/if (${Line.Equal[undershore]}) /varset PortSpell Undershore Portal
		/if (${Line.Equal[wakening]}) /varset PortSpell Wakening Lands Portal
        /if (${Line.Equal[wkarana]}) /varset PortSpell West Portal
		/if (${Line.Equal[primary]} || ${Line.Equal[panchor]} || ${Line.Equal[primaryanchor]}) /varset PortSpell Primary Anchor Portal
		/if (${Line.Equal[secondary]} || ${Line.Equal[sanchor]} || ${Line.Equal[secondaryanchor]}) /varset PortSpell Secondary Anchor Portal
        /if (${Line.Equal[succor]} || ${Line.Equal[evac]}) {
            /if (${Me.Level}>=57) {
                /varset PortSpell Evacuate
            } else { 
                /varset PortSpell Lesser Evacuate
            }
        }
    }
	/if (!${Me.Book[${PortSpell}]} && !${Me.AltAbilityReady[${PortSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		/return
		}
    /if (${Me.Book[${PortSpell}]} || ${Me.AltAbilityReady[${PortSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 g "Porting with" o "${PortSpell}"
        /target id ${Me.ID}
		/if (${Me.AltAbilityReady[${PortSpell}]}) {
			/call Cast "${PortSpell}" ALT 25s SpellFiller 3
			/return
			}
		/if (${Cursor.ID}) /autoinventory
        /call Cast "${PortSpell}" ${PortGem} 25s SpellFiller 3
		} else {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		}
	/return
	
Sub SendUs(Line,Client)
|--------------
|  Credit: Based on code from demonstar55
|--------------
/declare SendSpell string local
    /if (${Me.Class.ShortName.Equal[DRU]}) {
        /if (${Line.Equal[alra]}) /varset SendSpell Zephyr: Pillars of Alra
        /if (${Line.Equal[arcstone]}) /varset SendSpell Zephyr: Arcstone
        /if (${Line.Equal[barindu]}) /varset SendSpell Zephyr: Barindu
        /if (${Line.Equal[blightfire]}) /varset SendSpell Zephyr: Blightfire Moors
		/if (${Line.Equal[bloodfields]} || ${Line.Equal[bloodfield]}) /varset SendSpell Zephyr: Bloodfields
        /if (${Line.Equal[brell]}) /varset SendSpell Zephyr: Brell's Rest
        /if (${Line.Equal[buriedsea]} || ${Line.Equal[buried]}) /varset SendSpell Zephyr: Buried Sea		
        /if (${Line.Equal[butcher]}) /varset SendSpell Zephyr: Butcherblock
        /if (${Line.Equal[cobalt]}) /varset SendSpell Zephyr: Cobalt Scar
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset SendSpell Zephyr: the Combines
        /if (${Line.Equal[commons]}) /varset SendSpell Zephyr: Commonlands
		/if (${Line.Equal[dawnshroud]}) /varset SendSpell Zephyr: Dawnshroud
        /if (${Line.Equal[direwind]}) /varset SendSpell Zephyr: Direwind
        /if (${Line.Equal[domain]} || ${Line.Equal[beasts domain]} || ${Line.Equal[beast]} || ) /varset SendSpell Zephyr: Beasts' Domain
        /if (${Line.Equal[feerrott]}) /varset SendSpell Zephyr: Feerrott
        /if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset SendSpell Zephyr: Great Divide
        /if (${Line.Equal[grimling]}) /varset SendSpell Zephyr: Grimling
        /if (${Line.Equal[grounds]}) /varset SendSpell Zephyr: the Grounds
        /if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset SendSpell Zephyr: Karana
        /if (${Line.Equal[iceclad]}) /varset SendSpell Zephyr: Iceclad		
        /if (${Line.Equal[lavastorm]}) /varset SendSpell Zephyr: Lavastorm
        /if (${Line.Equal[loping]}) /varset SendSpell Zephyr: Loping Plains
        /if (${Line.Equal[misty]}) /varset SendSpell Zephyr: Misty
        /if (${Line.Equal[moors]}) /varset SendSpell Zephyr: Blightfire Moors		
        /if (${Line.Equal[natimbi]}) /varset SendSpell Zephyr: Natimbi		
        /if (${Line.Equal[nexus]}) /varset SendSpell Zephyr: the Nexus
        /if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset SendSpell Zephyr: Knowledge		
        /if (${Line.Equal[ro]} || ${Line.Equal[sro]}) /varset SendSpell Zephyr: Ro
        /if (${Line.Equal[shards]}) /varset SendSpell Zephyr: Shard's Landing
        /if (${Line.Equal[steamfont]}) /varset SendSpell Zephyr: Steamfont
		/if (${Line.Equal[slaughter]} || ${Line.Equal[wos]}) /varset SendSpell Zephyr: Slaughter
        /if (${Line.Equal[steppes]}) /varset SendSpell Zephyr: The Steppes
        /if (${Line.Equal[stonebrunt]}) /varset SendSpell Zephyr: Stonebrunt
        /if (${Line.Equal[surefall]}) /varset SendSpell Zephyr: Surefall Glade
        /if (${Line.Equal[tempest]}) /varset SendSpell Zephyr: Tempest Temple
        /if (${Line.Equal[time]}) /varset SendSpell Zephyr: Plane of Time
        /if (${Line.Equal[tox]}) /varset SendSpell Zephyr: Toxxulia
        /if (${Line.Equal[twilight]}) /varset SendSpell Zephyr: Twilight
        /if (${Line.Equal[undershore]}) /varset SendSpell Zephyr: Undershore
        /if (${Line.Equal[wakening]}) /varset SendSpell Zephyr: Wakening Lands
		/if (${Line.Equal[twk]} || ${Line.Equal[wkarana]}) /varset SendSpell Zephyr: West Karana
		} 
	/if (${Me.Class.ShortName.Equal[WIZ]}) {
		/if (${Line.Equal[arcstone]}) /varset SendSpell Translocate Arcstone 
        /if (${Line.Equal[barindu]}) /varset SendSpell Translocate Barindu 
		/if (${Line.Equal[bind]} || ${Line.Equal[translocate]}) /varset SendSpell Translocate
		/if (${Line.Equal[bloodfields]}) /varset SendSpell Translocate Bloodfields 
		/if (${Line.Equal[brell]}) /varset SendSpell Translocate Brell's Rest 		
        /if (${Line.Equal[cazic]}) /varset SendSpell Translocate Cazic 
        /if (${Line.Equal[cobalt]}) /varset SendSpell Translocate Cobalt Scar 
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset SendSpell Translocate Combine 
		/if (${Line.Equal[commons]}) /varset SendSpell Translocate Common 		
        /if (${Line.Equal[dawnshroud]}) /varset SendSpell Translocate Dawnshroud 
		/if (${Line.Equal[dragonscale]}) /varset SendSpell Translocate Dragonscale Hills
		/if (${Line.Equal[gfay]}) /varset SendSpell Translocate Fay 
		/if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset SendSpell Translocate Great Divide 
		/if (${Line.Equal[grimling]}) /varset SendSpell Translocate Grimling 
        /if (${Line.Equal[grounds]}) /varset SendSpell Translocate the Grounds 		
        /if (${Line.Equal[katta]}) /varset SendSpell Translocate Katta Castrum         
		/if (${Line.Equal[iceclad]}) /varset SendSpell Translocate Iceclad 
		/if (${Line.Equal[icefall]}) /varset SendSpell Translocate Icefall Glacier 
		/if (${Line.Equal[moors]}) /varset SendSpell Translocate Blightfire Moors 		
        /if (${Line.Equal[natimbi]}) /varset SendSpell Translocate Natimbi 		
		/if (${Line.Equal[nek]}) /varset SendSpell Translocate Nek 
		/if (${Line.Equal[nexus]}) /varset SendSpell Translocate Nexus 
		/if (${Line.Equal[nro]}) /varset SendSpell Translocate Ro 
		/if (${Line.Equal[alra]} || ${Line.Equal[pillars]}) /varset SendSpell Translocate Pillars of Alra		
		/if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset SendSpell Translocate Knowledge
        /if (${Line.Equal[panchor]} || ${Line.Equal[primary]}) /varset SendSpell Translocate Primary Anchor
		/if (${Line.Equal[sanchor]} || ${Line.Equal[secondary]}) /varset SendSpell Translocate Primary Anchor
		/if (${Line.Equal[ro]} || ${Line.Equal[nro]}) /varset SendSpell Translocate Ro
		/if (${Line.Equal[sarith]}) /varset SendSpell Translocate Sarith 
		/if (${Line.Equal[shards]}) /varset SendSpell Translocate Shard's Landing 
        /if (${Line.Equal[slaughter]}) /varset SendSpell Translocate Slaughter 
		/if (${Line.Equal[stonebrunt]}) /varset SendSpell Translocate Stonebrunt
        /if (${Line.Equal[sunderock]}) /varset SendSpell Translocate Sunderock Springs 
		/if (${Line.Equal[tempest]} || ${Ling.Equal[temple]}) /varset SendSpell Translocate Tempest Temple
		/if (${Line.Equal[time]}) /varset SendSpell Translocate Plane of Time 
		/if (${Line.Equal[tox]}) /varset SendSpell Translocate Tox 
        /if (${Line.Equal[twilight]}) /varset SendSpell Translocate Twilight 
		/if (${Line.Equal[twk]} || ${Line.Equal[west karana]} || ${Line.Equal[wkarana]}) /varset SendSpell Translocate West Karana 
		/if (${Line.Equal[undershore]}) /varset SendSpell Translocate Undershore 
		/if (${Line.Equal[wakening]}) /varset SendSpell Translocate Wakening Lands
		}
	/if (!${Me.Book[${SendSpell}]} && !${Me.AltAbilityReady[${SendSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		/return
		}
    /if (${Me.Book[${SendSpell}]} || ${Me.AltAbilityReady[${SendSpell}]}) {
		/if (${Spawn[${Spawn[${Client}].Pet.ID}].Distance3D}>100) {
			/call AnnounceMessage "${ChatChannel}" 3 m "${Client}" g "is to far away to cast" o "${SendSpell}"
			/return
			}
		/invoke ${Spawn[${Client}].DoTarget}
		/call AnnounceMessage "${ChatChannel}" 2 g "Porting with" o "${SendSpell}"
        /if (${Cursor.ID}) /autoinventory
        /if (${Me.AltAbilityReady[${SendSpell}]}) {
			/call Cast "${SendSpell}" ALT 25s SpellFiller 3
			/return
			}
		/call Cast "${SendSpell}" ${PortGem} 25s SpellFiller 3
		} else {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		}
	/return	

Sub QuietMiracle
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]} && ${Group} && ${Me.AltAbilityReady[Quiet Miracle]}) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance} < 100 && ${Group.Member[${i}].CurrentMana} <40 && ${Group.Member[${i}].Class.CanCast}) {
				/target targetable id ${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Quiet Miracle!" g "on" m "${Target.CleanName}"
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for QM"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
                	/if (${Target.Buff[Shroud of the Miracle].ID}) {
                        /call CreateTimer QM${Target.ID} 1m
						/return
						}
                    /call Cast "Quiet Miracle" alt 0 SpellFiller 3
					/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Quiet Miracle"
					/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Quiet Miracle"
					}
				}
		/next i
		}
	/return	

Sub ParagonOfSpirit
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (${Me.Song[Paragon of Spirit].ID} || ${Me.Song[Focused Paragon of Spirits].ID}) /return
	/if (${Debug}) /echo \ag Entering \ao Paragon sub
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]} && ${Group} && (${Me.AltAbilityReady[Paragon of Spirit]} || ${Me.AltAbilityReady[Focused Paragon of Spirits]})) {
		 /if (${Debug}) /echo \ag Checking group
		 /for i 0 to ${Group}
			/if (${Debug}) /echo \ag Checking ${Group.Member[${i}]}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance} < 100 && ${Group.Member[${i}].CurrentMana} <80 && ${Group.Member[${i}].Class.CanCast}) {
				/target targetable id ${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Paragon of Spirit!" g "on" m "${Target.CleanName}"
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for Paragon of Spirit"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Me.AltAbilityReady[Paragon of Spirit]}) {
						/call Cast "Paragon of Spirit" alt 0 SpellFiller 3
						/if (${castReturn.Equal[CAST_SUCCESS]}) {
							/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Paragon of Spirit"
							/return
							}
						/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Paragon of Spirit"
						/if (${Debug}) /echo \ag end casting PoS
						}
					/if (${Me.AltAbilityReady[Focused Paragon of Spirits]} && !${Me.Song[Paragon of spirit].ID} && !${Me.AltAbilityReady[Paragon of Spirit]}) {
						/call Cast "Focused Paragon of Spirits" alt 0 SpellFiller 3
						/if (${castReturn.Equal[CAST_SUCCESS]}) {
							/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Focused Paragon of Spirits"
							/return
							}
						/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Focused Paragon of Spirits"						
						/if (${Debug}) /echo \ag End casting FPoS
						}
					}
				}
			/if (${Debug}) /echo \ag End checking ${Group.Member[${i}]}
		/next i
		}
	/if (${Debug}) /echo \ag Leaving Paragon sub.
	/return		

Sub PetHealing
	/if (!${Me.Pet.ID}) /return
	/if (${SelfPetHealing}) {
		/if (!${Me.Book[${Me.Book[${Spell[${SelfPetHeal}].RankName}]}].ID}) {
			/call AnnounceMessage ${ChatChannel} 2 m "${{SelfPetHeal}" r "not in spellbook"
			/varset SelfPetHealing FALSE
			/return
			}
		/if (!${Me.Gem[${SelfPetHeal}]}) {
			/memorize "${Spell[${SelfPetHeal}].RankName}" ${SelfPetHealGem}
			/delay 5s ${Me.SpellReady[${Spell[${SelfPetHeal}].RankName}]}
			}
		/if (${Me.Pet.PctHPs}<${SelfPetHealPct}) {
			/if (${Me.SpellReady[${Spell[${SelfPetHeal}].RankName}]}) {
				/call Cast "${Spell[${SelfPetHeal}].RankName}" ${SelfPetHealGem} 10s Check4Pad 3	
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfully healed ->" m "${Me.Pet.CleanName}" g with o "${Spell[${SelfPetHeal}].RankName}"
					/if (!${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 1 r "Problem trying to heal pet!"
					}
				}
			}
		}
	/doevents
	/return

Sub PetDelayedHealing	
	/if (!${Me.Pet.ID}) /return
	/if (${PetDelayedHealing}) {
		/if (!${Me.Book[${Me.Book[${Spell[${PetDelayedHeal}].RankName}]}].ID}) {
			/call AnnounceMessage ${ChatChannel} 2 m "${PetDelayedHeal}" r "not in spellbook"
			/varset PetDelayedHealing FALSE
			/return
			}
		/if (!${Me.Gem[${PetDelayedHeal}]}) {
				/memorize "${Spell[${PetDelayedHeal}].RankName}" ${PetDelayedHealGem}
				/delay 5s ${Me.SpellReady[${Spell[PetDelayedHeal].RankName}]}
				}
		/if (${Me.Pet.PctHPs}<${PetDelayedHealPct}) {
			/if (${Me.SpellReady[${Spell[${PetDelayedHeal}].RankName}]}) {
				/call Cast "${Spell[${PetDelayedHeal}].RankName}" ${PetDelayedHealGem} 10s Check4Pad 3	
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Me.Pet.CleanName}" g has o "${Spell[${PetDelayedHeal}].RankName}"
					/if (!${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 2 o "${Spell[${PetDelayedHeal}].RankName}" r "wont take hold!!"
					}
				}
			}
		}
	/doevents
	/return	
	
Sub SpellFiller
	/return
	
Sub RallyingCall
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.NotEqual[COMBAT]} && ${Group} && ${Me.AltAbilityReady[Rallying Call]}) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<100 && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG]} && ${Group.Member[${i}].CurrentMana}<30 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<30)) {
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Rallying Call!" g "on" m "${Group.Member[${i}].CleanName}"
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for RC"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Twist.Twisting}) /squelch /twist stop	
                    /call Cast "Rallying Call" alt 0 SpellFiller 3
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is renewed with a" o "Rallying Call"
					/if (${castReturn.NotEqual[CAST_SUCCESS]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Rallying Call"
					/squelch /twist start
					}
				}
		/next i
		}
	/return	
	
Sub RezCheck
	/if (${Me.Class.ShortName.NotEqual[CLR]}) /return
	/declare i int local
	/if (!${RDPause} && ${Group} && ${Me.AltAbilityReady[Blessing of Reserrection]}) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.Equal[corpse]} && ${Group.Member[${i}].Distance}<100) {
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Rez!" g "on" m "${Group.Member[${i}].CleanName}"
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for RC"
					/target clear
					/return
					}
				}
		/next i
		}
	/return	

Sub DichotomicPsalm
	/declare i int local
	/if (!${RDPause} && ${Group} && ${Cast.Ready[Dichotomic Psalm]} && ${Me.PctEndurance}>10) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<100 && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG,BST]} && ${Group.Member[${i}].CurrentMana}<50 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<50)) {
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "DoDichotomic!" g "on" m "${Group.Member[${i}].CleanName}"
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for Dichiotomic Psalm"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Twist.Twisting}) /squelch /twist stop
                    /squelch /twist once ${Me.Gem[Dichotomic Psalm]}
					/delay 7s !${Cast.Timing}
					/if (!${Cast.Ready[Dichotomic Psalm]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is renewed with a" o "Dichotomic Psalm"
					/if (${Cast.Ready[Dichotomic Psalm]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Dichotomic Psalm"
					/squelch /twist start
					}
				}
		/next i
		}
	/return	
	
	
Sub RefreshAlerts
	/declare i int local
	/call LoadVar IgnoreNPCList ${Zone.ShortName} | IgnoreNPCList RDCommon.ini LOAD string
	/call LoadVar IgnoreNPCList AllZones | IgnoreNPCListCommon RDCommon.ini LOAD string
	/echo ${IgnoreNPCListCommon}
	/alert clear 1
	/declare alertlistlen int local ${Math.Calc[${IgnoreNPCList.Count[|]}-1].Int}
	/declare alertlistlen2 int local ${Math.Calc[${IgnoreNPCListCommon.Count[|]}-1].Int}
	/echo NPC Ignore List for : ${Zone.Name} ( Total NPC: ${alertlistlen} )
	/if (${alertlistlen} > 0) {
		/for i 1 to ${alertlistlen}
			/alert add 1 ${IgnoreNPCList.Arg[${i},|]}
		/next i
	} else {
		/echo No npcs are ignored in ${Zone.Name}, use /ignorenpc <Name> to add NPCs
	}
	/echo NPC Ignore List for : Common ( Total NPC: ${alertlistlen2} )
	/if (${alertlistlen2} > 0) {
		/for i 1 to ${alertlistlen2}
			/alert add 1 ${IgnoreNPCListCommon.Arg[${i},|]}
		/next i
	} else {
		/echo No npcs are ignored in Common, use /ignorenpc <Name> to add NPCs
	}
	/return
		

Sub RemoveFromQueue(int Buffee,int BuffNumber)
	/if (${Debug}) /echo \ag Entering: \ao Remove from que Start \am ${Spawn[${Buffee}].CleanName} \ao Buff number \ay ${BuffNumber} \ao Queue Count = \ag ${QueueCount}
	/doevents IRC
	/doevents Chat
	/declare m int local
	/for m 1 to 25
		/if (((!${Spawn[${DoBuffQueue[${m},1]}].ID}) || ((${DoBuffQueue[${m},1]}==${Buffee} || (!${Buffee} && (${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].CleanName}].Index} || ${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].Master}].Index} )) || ${Select[${Spell[${DoBuffID[${DoBuffQueue[${m},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) && (${DoBuffID[${DoBuffQueue[${m},2]}]}==${BuffNumber} || ${DoBuffQueue[${m},2]}==${BuffNumber}))) && ${DoBuffQueue[${m},1]}) {
			/if (${Debug}) {
				/echo First remove from que check good, removing ${DoBuffQueue[${m},1]} and ${DoBuffQueue[${m},2]}
				/echo (((!${Spawn[${DoBuffQueue[${m},1]}].ID}) || ((${DoBuffQueue[${m},1]}==${Buffee} || (!${Buffee} && (${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].CleanName}].Index} || ${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].Master}].Index} )) || ${Select[${Spell[${DoBuffID[${DoBuffQueue[${m},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) && (${DoBuffID[${DoBuffQueue[${m},2]}]}==${BuffNumber} || ${DoBuffQueue[${m},2]}==${BuffNumber}))) && ${DoBuffQueue[${m},1]})
				}
			/varset DoBuffQueue[${m},1] 0
			/varset DoBuffQueue[${m},2] 0
|			/echo  \ag DoBuffque 1 = \ay ${DoBuffQueue[${m},1]} \ag and  DoBuffque 2 = \ay ${DoBuffQueue[${m},2]} \ag Bufee = \ay ${Buffee} and \ag BuffNumber = \ay ${BuffNumber}
			/if (${QueueCount}>0)  {
				/varcalc QueueCount ${QueueCount}-1
				}
		}
		/if (${Defined[RezBuff${DoBuffQueue[${m},2]}]}) {
			/if (!(${Spawn[${DoBuffQueue[${m},1]}].Type.Equal[Corpse]} ^^ ${RezBuff${DoBuffQueue[${m},2]}})) {
				/if (${Debug}) /echo second REZ heck good, removing ${DoBuffQueue[${m},1]} and ${DoBuffQueue[${m},2]}
				/varset DoBuffQueue[${m},1] 0
				/varset DoBuffQueue[${m},2] 0
				/if (${QueueCount}>0)  {
					/varcalc QueueCount ${QueueCount}-1
					}
				}
			}
	/next m
	/if (${Debug}) /echo \am Exiting: Remove From Que \ao Queue count = \af ${QueueCount}
	/return
	
Sub RemoveNPCs
	/declare a int local
	/declare b int local
	/for a 1 to ${MaxMobs}
		/if ((${Spawn[${MobList[${a}]}].Type.Equal[Corpse]} || ${Spawn[${MobList[${a}]}].Master.Type.Equal[PC]} || !${Spawn[${MobList[${a}]}].ID} || ${Spawn[${MobList[${a}]}].Distance}>${NPCRadius}) && ${MobList[${a}]}) {
			/varset MobList[${a}] 0
			/for b 1 to ${DebuffTotal}
				/varset DebuffArray[${a},${b}] 0
			/next b
			/if (${VarNPCCount}) /varcalc VarNPCCount ${VarNPCCount}-1
		}
	/next a
	/return
	
Sub Retort
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[RetortTimer]}) /call CreateTimer RetortTimer
	/if (${Me.SpellReady[${Spell[${RetortSpell}].RankName}]}) {
		/if (!${RetortTimer}) {
			/if (${Spawn[ID ${MainTankID}].Distance}<=200) {
				/if (${MainTankID}) {
					/if (!${Target.Buff[${Spell[${RetortSpell}].RankName}].ID}) {
						/if (${Me.PctMana}>10) {
							/if (${DebugHeal}) /echo casting ${RetortSpell} from Gem ${RetortSpellGem} at ${Target.CleanName}
							/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
							/call Cast "${Spell[${RetortSpell}].RankName}" "${RetortSpellGem}" "1s" "Check4Pad"
							/delay 5s !${Me.Casting.ID}
							/if (${castReturn.Equal[CAST_SUCCESS]}) {
								/varset RetortTimer ${Spell[${Spell[${RetortSpell}].RankName}].Duration.TotalSeconds}
								/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 t "RETORT to ->" m "${Target.CleanName}" g "<- using" o "${Spell[${RetortSpell}].RankName}"
								}
							}
						}
					}
				}
			}
		/if (${DebugHeal} && ${castReturn.Equal[CAST_SUCCESS]}) /echo Casting successful
		/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
			/varset RetortTimer 30s	
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 r "Failed!->" m "${Target.CleanName}" y "<- has something blocking" o "${Spell[${RetortSpell}].RankName}"
			}
		}
	/return	

Sub Ward
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[WardTimer]}) /call CreateTimer WardTimer
	/if (${Me.SpellReady[${Spell[${WardSpell}].RankName}]} && !${WardTimer} && ${Spawn[ID ${MainTankID}].Distance} <= 200 && ${MainTankID} && ${DoWard} && ${Me.CombatState.Equal[COMBAT]} && !${Target.Buff[${Spell[${WardSpell}].RankName}].ID} && ${Me.PctMana}>10) {
		/if (${Debug}) /echo casting ${WardSpell} from Gem ${WardSpellGem} at ${Target.CleanName}
		/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
		/call Cast "${Spell[${WardSpell}].RankName}" "${WardSpellGem}" "1s" "Check4Pad" 3
		/if (${castReturn.Equal[CAST_SUCCESS]}) {
			/varset WardTimer 180s
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 t "Warding ->" o "${Target.CleanName}" g "<- with" o "${Spell[${WardSpell}].RankName}"
			}
		/if (${Debug} && ${castReturn.Equal[CAST_SUCCESS]}) /echo \ao Casting successful
		/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
			/varset WardTimer 30s	
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 r "FAILED! ->" m "${Target.CleanName}" y "<-has something blocking" o "${Spell[${WardSpell}].RankName}"
			}
		}
	/return	

Sub ShouldIHeal
	/if (!${RDPause} && ${HealFD} && ${Target.State.NotEqual["FEIGN"]} && ${Select[${Target.Class.ShortName},MNK,NEC,SHD]}) /return
	/if (!${RDPause} && ${Target.Type.NotEqual[NPC]} && ${Target.PctHPs}<${HealPct} && ${Target.Distance}<${Int[${Spell[${FastHealID}].MyRange}]}) /call DoHeal ${Target.ID} Fast
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
	/return

Sub ShrinkStuff
	/declare i int local
    /if (${ShrinkSelfOnly} && ${Me.Height}>1.89) {
        /target ${Me}
        /call Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
        /call Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
		} else {
        /for i 0 to ${Math.Calc[${Group.GroupSize}-1]}
            /if (${Group.Member[${i}].Height}>1.89 && ${Group.Member[${i}].Distance}<50) {
                /target ${Group.Member[${i}]}
                /call Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
                /call Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
				}
			/next i
		}
	/return	
	
Sub SingSongs(bool NewTwist)
	/if (!${RDPause} && ${Me.Standing}) {
		/if (${Twist} && ((!${Melee.Combat} && ${RestTwist.Equal[None]}) || (${Melee.Combat} && ${CombatTwist.Equal[None]}) || (${SpawnCount[npc targetable radius ${AutoRestRadius} zradius 50 noalert 1]} && ${AutoRestOff} && !${Melee.Combat} && !${SpawnCount[npc radius ${NPCRadChk} zradius 50 noalert 1]}))) {
			/squelch /twist stop
			/return
		}
		/if (!${Melee.Combat} && !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && (!${Twist} || ${Twist.List.NotEqual[${RestTwist} ]} || ${NewTwist}) && (!${SpawnCount[npc targetable radius ${AutoRestRadius} zradius 50 noalert 1]} || !${AutoRestOff})) /squelch /twist ${RestTwist}
		/if ((${Melee.Combat} || ${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) && (!${Twist} || ${Twist.List.NotEqual[${CombatTwist} ]} || ${NewTwist})) /squelch /twist ${CombatTwist}
	}
	/varset TwistTimer 33
	/return
	
Sub SummonStuff
   |I am not paused
   |I am a mage
   |I do not have a rod in inventory
   |I do not have something on cursor
   |Summon a rod
	/if (!${RDPause} && ${Me.Class.ShortName.Equal[MAG]} && !${Cursor.ID} && ${Me.Level}>43) {
		/call CheckForRod
		/if (${NeedRod}) {
			/if (${Me.Book[${Me.Book[${Spell[${RodSpell}].RankName}]}].ID}) {
				/target myself
				/call Cast "${Spell[${RodSpell}].RankName}" ${RodGem} 5s SpellFiller 3
				/delay 10s ${Cursor.ID}
				/autoinv
				} else {
				/call DefaultSummonRod
				}
			}
		/if (!${Bool[${FindItem[Summoned: Radiant Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Glowing Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Giant Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Large Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Medium Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Small Modulation Shard].ID}]} && ${Me.AltAbility[Summon Modulation Shard].ID}) {
			/call Cast "Summon Modulation Shard" ALT 10s SpellFiller 3
			/delay 10s ${Cursor.ID}			
			/autoinv
			}
		}
	/if (${UseAmmoClicky}) {
			/if (!${FindItem[${AmmoItem}].ID} && ${FindItem[${AmmoClicky}].TimerReady}==0 && ${Me.FreeInventory}>1) {
			/call Cast "${AmmoClicky}" ${AmmoGem} 7s Check4Pad
			/delay 20s !${Me.Casting.ID}
			/if (${castReturn.Equal[CAST_SUCCESS]}) /autoinv
			}
		}
	/return

	
Sub DefaultSummonRod

	/if (!${FindItem[Wand of Restless Modulation].ItemSlot} && ${Me.Level}<111 && ${Me.Book[${Me.Book[${Spell[Wand of Restless Modulation].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Restless Modulation].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Wand of Arcronite Modulation].ItemSlot} && ${Me.Level}<106 && ${Me.Book[${Me.Book[${Spell[Wand of Burning Modulation].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Burning Modulation].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Wand of Pelagic Modulation].ItemSlot} && ${Me.Level}<101 && ${Me.Book[${Me.Book[${Spell[Wand of Dark Modulation].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Dark Modulation].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Wand of Phantasmal Modulation].ItemSlot} && ${Me.Level}<96 && ${Me.Book[${Me.Book[${Spell[Wand of Phantasmal Modulation].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Phantasmal Modulation].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}	
	/if (!${FindItem[Rod of Arcane Transvergence].ItemSlot} && ${Me.Level}<91 && ${Me.Book[${Me.Book[${Spell[Wand of Arcane Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Arcane Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Rod of Spectral Transvergence].ItemSlot} && ${Me.Level}<86 && ${Me.Book[${Me.Book[${Spell[Wand of Spectral Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Spectral Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Wand of Temporal Mastery].ItemSlot} && ${Me.Level}<81 && ${Me.Book[${Me.Book[${Spell[Summon Wand of Temporal Mastery].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Summon Wand of Temporal Mastery].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Rod of Ethereal Transvergence].ItemSlot} && ${Me.Level}<81 && ${Me.Book[${Me.Book[${Spell[Wand of Ethereal Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Ethereal Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Rod of Prime Transvergence].ItemSlot} && ${Me.Level}<76 && ${Me.Book[${Me.Book[${Spell[Wand of Prime Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Prime Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Wand of Elemental Transvergence].ItemSlot} && ${Me.Level}<71 && ${Me.Book[${Me.Book[${Spell[Wand of Elemental Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Wand of Elemental Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Rod of Mystical Transvergence].ItemSlot} && ${Me.Level}<55 && ${Me.Book[${Me.Book[${Spell[Rod of Mystical Transvergence].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Rod of Mystical Transvergence].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/if (!${FindItem[Summoned: Modulating Rod].ItemSlot} && ${Me.Level}<43 && ${Me.Book[${Me.Book[${Spell[Modulating Rod].RankName}]}].ID}) {
		/target myself
		/call Cast "${Spell[Modulating Rod].RankName}" ${RodGem} 5s SpellFiller 3
		/delay 10s ${Cursor.ID}
		/autoinv
		/return
		}
	/return	
	
Sub CheckForRod
	/varset NeedRod 0
	/if (${FindItem[=Wand of Restless Modulation].ID} || ${FindItem[=Wand of Arcronite Modulation].ID} || ${FindItem[=Wand of Pelagic Modulation].ID} || ${FindItem[=Wand of Pelagic Transvergence].ID} || ${FindItem[=Wand of Phantasmal Modulation].ID} || ${FindItem[=Wand of Phantasmal Transvergence].ID} || ${FindItem[=Rod of Arcane Transvergence].ID} || ${FindItem[=Rod of Spectral Transvergence].ID} || ${FindItem[=Rod of Ethereal Transvergence].ID} || ${FindItem[=Rod of Prime Transvergence].ID} || ${FindItem[=Wand of Elemental Transvergence].ID} || ${FindItem[=Rod of Mystical Transvergence].ID} || ${FindItem[=Rod of Mechamagical Mastery].ID} || ${FindItem[=Wand of Temporal Mastery].ID} || ${FindItem[=Summoned: Modulating Rod].ID}) {
		/varset NeedRod 0	
		} else {
		/varset NeedRod 1
		}
	/return
	
	
Sub Trader
	/if (!${Bool[${Plugin[MQ2AutoLogin]}]}) {
		/call AnnounceMessage ${ChatChannel} 1 r "You need MQ2AutoLogin to switch to trader"
		}
	/if (${TraderName.Equal[NULL]} || ${TraderName.Equal[Put the name of your Trader here]}) {
		/if (${Me.Class.ShortName.Equal[BRD]}) {
			/if (${Twist.Twisting}) /squelch /twist off
			/delay 5s ${Twist.Twisting}
			}
		/camp desktop
		/end
		}
	/if (${TraderName.NotEqual[NULL]}) {
		/if (${Twist.Twisting}) /squelch /twist off
		/switchchar ${TraderName}
		/return
		}
	/return

Sub XPCommon
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
	/if (${ReportMana} && ${Me.PctMana}<${ReportManaPct}) {
		/call AnnounceMessage "${ChatChannel}" 2 g "Medding, " T "${Me.PctMana}m"
		/varset ReportFM TRUE
		}
	/if (${DebuffTotal}) /call PopulateNPCs
	/varset AssistTimer 0
	/varset MATarget 999999
	/call MoveStuff
	:CampCheck
	/if (${MakeCamp.Status.Equal[ON]} && ${Me.XTarget}<1) /makecamp return
	/if (${MakeCamp.Status.Equal[ON]} && ${MakeCamp.CampDist}>10 && ${Me.XTarget}<1) /goto :CampCheck
|	/if (${FollowFlag} && !${Me.Moving} && !${Melee.Combat} && ${Spawn[${FollowGuy}].Distance}<${LeashDistance} ) /target clear
	/call MercStuff
	/return
|---------------
|	EVENTS
|---------------

	
Sub Event_AddAlert(line,MobName)
	/if (!(${IgnoreNPCList.Find[${MobName}]})) {
		/alert add 1 ${MobName}
		/varset IgnoreNPCList ${IgnoreNPCList}${MobName}|
		/ini RDCommon.ini IgnoreNPCList ${Zone.ShortName} "${IgnoreNPCList}"
|		/call RefreshAlerts
	} else {
		/echo The NPC ( ${MobName} ) is already on the /ignorenpc List
	}
	/return

Sub Event_AddAlertCommon(line,MobName)
	/if (!(${IgnoreNPCListCommon.Find[${MobName}]})) {
		/alert add 1 ${MobName}
		/varset IgnoreNPCListCommon ${IgnoreNPCListCommon}${MobName}|
		/ini RDCommon.ini IgnoreNPCList AllZones "${IgnoreNPCListCommon}"
		/call RefreshAlerts
	} else {
		/echo The NPC ( ${MobName} ) is already on the /ignorenpccommon List
	}
	/return	

Sub Event_Campout
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist off
	/echo You forgot to end the macro, DOH!
	/end
	/return	

Sub Event_CanNotSee
|	/if (${Guard} && ${MakeCamp.Status.Equal[ON]}) {
|		/target clear
|		/varset MATarget NULL
|		}		
	/if (${Target.ID} && ${MakeCamp.Status.Equal[ON]}) {
		/squelch /face fast nolook
		}
	/if (${Melee.Combat}) /squelch /face fast nolook
	/return
	
Sub Event_ChangeTank(Line,NewTank)
|========================================
|Idea based on Nytemyst's AFCleric
|========================================
	/if (${ChangeTank}==TRUE && ${UseGroupMA}==FALSE && ${UseRaidMA}==FALSE) {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${NewTank}"
		/call AnnounceMessage "${ChatChannel}" 2 y "Changing tank to" m "${NewTank}"
		}
	/return
	
Sub Event_Chat(ChatType,Sender,ChatText)
	/if (${ChatType.Equal[tell]} && ${Sender.Left[1].Compare[ ]}<0) /varset Sender ${Sender.Right[-2].Left[-1]}
	/if (${ChatType.Equal[tell]} && ${RelayTells} && (${Spawn[${Sender}].Type.Equal[PC]} || !${Spawn[${Sender}].ID})) /call AnnounceMessage "${ChatChannel}" 3 m "${Sender}" g "told me" w "${ChatText}" "--"
	/if (${ChatText.Find[has been updated.]}) /call AnnounceMessage "${ChatChannel}" 2 o "Task" y "Updated!"
	/if (${Defined[UseFranticHeal]}) {
		/if (${ChatText.Find[Frantic Heal Now!]} && ${UseFranticHeal} && ${Spawn[${Sender}].ID}==${MainTankID}) /call FranticHeal
		}
	/if (${ChatText.Find[change tank]} && ${Spawn[pc ${ChatText.Arg[3]}].ID} && ${Raid.Members}) /varset MA1 ${ChatText.Arg[3]}
	/if (${DoBuffTotal} && ${DoBuffs} && ${Sender.NotEqual[${Me.CleanName}]} && (${Spawn[pc ${Sender}].ID} || ${Spawn[corpse ${Sender}].ID})) /call CheckDoBuffs "${Sender}" "${ChatText}"
	/if (${Defined[DoPetToys]}) {
		/if (${ChatText.Find[pet toys]} && ${DoPetToys} && ${Me.Class.ShortName.Equal[MAG]}) {
			/if (${DebugPet}) {
				/echo  Pet Toys call from " ${Sender} " whose pet is ${Spawn[${Sender}].Pet.ID} or ${Spawn[${ChatText.Arg[3]}].CleanName}
				}
			/if (${Bool[${Spawn[${Sender}].Pet.ID}]}) {
				/if (${DebugPet}) {
					/echo calling Sub PetToys with pet ID of ${Spawn[${Sender}].Pet.ID}, first try
					}
				/call PetToys ${Spawn[${Sender}].Pet.ID}
				/goto :pettoysend
				}
			/if (!${Spawn[${Sender}].Pet.ID}) {
				/if (${DebugPet}) {
					/echo Pet ID failed 
					}
				/if (${Spawn[${ChatText.Arg[3]}].ID} && ${Spawn[${ChatText.Arg[3]}].Type.Equal[pet]}) {
					/if (${DebugPet}) {
						/echo Calling Sub PetToys using chat argument, pet ID ${Spawn[${ChatText.Arg[3]}].ID}
						}
					/call PetToys ${Spawn[${ChatText.Arg[3]}].ID}
					/goto :pettoysend
					}
				} 
			/if (!${Spawn[${Sender}].Pet.ID} && (!${Spawn[${ChatText.Arg[3]}].ID} || ${Spawn[${ChatText.Arg[3]}].Type.NotEqual[pet]})) {
				/call AnnounceMessage "${ChatChannel}" 3 r error m "${Sender}" y "has no pet"
				}
			}
		:pettoysend						
		}		
	/if (${Defined[DoPorts]}) {
		/if (${ChatText.Find[send me to]} && ${DoPorts} && ${Select[${Me.Class.ShortName},DRU,WIZ]}) {
			/call SendUs ${ChatText.Arg[4]} ${Sender}
			/return
			}
		}
	/if (${ChatText.Find[open door]} || ${ChatText.Find[click door]}) {
		/doortarget
		/delay 1s
		/face door
		/if (${DoorTarget.Distance}>20) {
			/call AnnounceMessage ${ChatChannel} 2 r ERROR y "Door to far away"
			} else {
			/click left door
			}
		}
	/if (${MasterList.Find[${Sender}]} || ${MasterList2.Find[${Sender}]} || ${MasterList3.Find[${Sender}]} || ${MasterList4.Find[${Sender}]} || ${MasterList5.Find[${Sender}]}) {
		/if (${ChatText.Find[check ini]}) /call INICheck1
		/if (${ChatText.Find[Add to Masterlist]}) /call AddMaster ${ChatText.Arg[4]}
		/if (${ChatText.Find[mount up]} && !${Me.Mount.ID} && !${Me.Invis} && !${RDPause} && !${Me.FeetWet} && !${RestrictedList.Find[|NoMount|]}) /call Cast "${MountItem}" item 10s Check4Pad
		/if (${Defined[DoPorts]}) {
			/if (${ChatText.Find[portto]} && ${DoPorts} && ${Select[${Me.Class.ShortName},DRU,WIZ]}) {
				/call PortUs ${ChatText.Arg[2]}
				/return
				}
			}
		/if (${ChatText.Left[1].Equal[/]}) /docommand ${ChatText}
		/if ((${ChatText.Find[move up]} || ${ChatText.Find[camp here]} || ${ChatText.Find[follow me]}) && !${Me.Standing}) /stand
		/if (${ChatText.Find[move up]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${MakeCamp.Status.Equal[ON]}) /makecamp loc ${Spawn[pc ${Sender}].Y} ${Spawn[pc ${Sender}].X} radius 15 leash 50
            /delay ${Math.Rand[30]}
			/moveto loc ${Math.Calc[${Spawn[pc ${Sender}].Y}-${MoveUpJitter}+${Math.Rand[${MoveUpJitter}*2]}]} ${Math.Calc[${Spawn[pc ${Sender}].X}-${MoveUpJitter}+${Math.Rand[${MoveUpJitter}*2]}]} loose
            /delay 10
            /face id ${Spawn[pc ${Sender}].ID}
			}
		/if (${ChatText.Find[camp here]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${MakeCamp.Status.Equal[ON]}) /makecamp off
			/makecamp loc ${Spawn[${Sender}].Y} ${Spawn[${Sender}].X} radius 15 leash 50
			/varset CampX ${Spawn[${Sender}].X}
			/varset CampY ${Spawn[${Sender}].Y}
			}
		/if (${ChatText.Find[follow me]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${ChatText.Arg[3].Length} && ${Spawn[pc ${ChatText.Arg[3]}].ID}) /varset FollowGuy ${Spawn[pc ${ChatText.Arg[3]}].ID}
			/if ((!${ChatText.Arg[3].Length} || !${Spawn[pc ${ChatText.Arg[3]}].ID}) && ${Spawn[pc ${Sender}].ID}) /varset FollowGuy ${Spawn[pc ${Sender}].ID}
			/target targetable id ${FollowGuy}
			/if (${MakeCamp.Status.Equal[ON]}) {
				/makecamp off ${MakeCamp.Status.Equal[OFF]}
				/delay 10s 
				}
			/delay 1s ${Target.ID}==${FollowGuy}
			/squelch /stick hold uw
			/varset FollowFlag TRUE
			/varset TravelMode ${ChatText.Find[travel]}
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 2 g Following m ${Target.CleanName}
			}
		/if (${ChatText.Find[stop]}) {
			/squelch /stick off
			/varset FollowFlag FALSE
			/varset FollowGuy 0
			}
		/if (${ChatText.Find[Current mana]} && ${Me.MaxMana}) /call AnnounceMessage "${ChatChannel}" 2 g "Mana: " w "${Me.PctMana}%" "--" "--"
		/if (${ChatText.Find[medtime]} && ${Me.PctMana}<100 && ${Me.MaxMana}) /call AnnounceMessage "${ChatChannel}" 2 g "FM in:" w "${Int[${Math.Calc[(${Me.MaxMana}-${Me.CurrentMana})/(${Me.ManaRegen}|1)/10]}]}m${Int[${Math.Calc[(${Me.MaxMana}-${Me.CurrentMana})/(${Me.ManaRegen}|1)%10*6]}]}s" "--" "--"
		/if (${ChatText.Find[buffqueue]} && ${QueueCount}) /call AnnounceMessage "${ChatChannel}" 3 g "I have" y "${QueueCount}" g "waiting to be served." "--"
		/if (${ChatText.Find[break]}) /call BreakInvis
		/if (${ChatText.Find[calm them]}) {
			/declare Puller int local 0
			/if (${ChatText.Arg[2].Length} && ${Spawn[pc ${ChatText.Arg[2]}].ID}) /varset Puller ${Spawn[pc ${ChatText.Arg[2]}].ID}
			/if ((!${ChatText.Arg[2].Length} || !${Spawn[pc ${ChatText.Arg[2]}].ID}) && ${Spawn[pc ${Sender}].ID}) /varset Puller ${Spawn[pc ${Sender}].ID}
			/call CalmGroup ${Puller}
			}
		/if (${ChatText.Find[create a campfire]}) /call CreateCampfire
		/if (${ChatText.Find[go to campfire]}) /call GoToCampfire
		/if (${ChatText.Find[campfire click]}) /call GoToCampfire
		/if (${ChatText.Find[go to trader]}) /call Trader
		/if (${ChatText.Find[guard here]} && ${Guard}) {
			/makecamp on
			/delay 1s
			/makecamp radius 15 leash 50
			/call AnnounceMessage "${ChatChannel}" 1 g "Guarding HERE Mastah!" 
			/varset CampX ${Me.X}
			/varset CampY ${Me.Y}
			/varset CampZ ${Me.Z}
			}
		/if (${ChatText.Find[use keyword]}) {
			/if (${Debug}) /echo ${ChatText.Arg[3]} ${ChatText.Arg[4]}
			/if (!${Spawn[${ChatText.Arg[4]}].ID}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR m "${ChatText.Arg[4]}" y not in zone
:distancecheck1		
			/if (${Spawn[${ChatText.Arg[4]}].ID} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>20) {
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR m "${ChatText.Arg[4]}" y "is ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance} far away, moving closer..."
				/if (!${Me.Moving} && !${Target.ID} && ${Bool[${Plugin[MQ2AdvPath]}]}) {
					/afollow spawn ${Spawn[${ChatText.Arg[4]}].ID}
					/delay 30s !{Me.Moving}
					/goto :distancecheck1
					}
				/stick id ${Spawn[${ChatText.Arg[4]}].ID} hold
				/delay 30s ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>21
				/if (!${Me.Moving} && ${Target.ID} && ${Stick.Active} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>21) {
					/target clear
					/delay 10s !${Target.ID}
					/goto :distancecheck1
					}		
				}
			/target ID ${Spawn[${ChatText.Arg[4]}].ID}
			/delay 5s ${Target.ID}==${Spawn[${ChatText.Arg[4]}].ID}
			/if (${Target.ID}!=${Spawn[${ChatText.Arg[4]}].ID}) {
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR y targeting m "${ChatText.Arg[4]}"
				}				
			/if (${Target.ID}==${Spawn[${ChatText.Arg[4]}].ID} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}<20) {
				/if (${Me.Invis}) {
					/squelch /makemevisible
					/delay 5s !${Me.Invis}
					}
				/face 
				/say ${ChatText.Arg[3]}
				}
			}
		}
	/if (${ChatText.Find[rez me]} && ${Spawn[${Sender}].Type.Find[Corpse]} && ${Spawn[${Sender}].ID}!=${Me.ID} && ${Select[${Me.Class.ShortName},CLR,SHM,DRU]} && !${RDPause}) {
		/if (${DoBuffTells} && !${SpamTimer}) /tell ${Sender} Rezz inc!
		/squelch /target ${Sender}'s Corpse
		/if (${Target.ID} && ${Target.Distance}>20) /corpse
		/if (${Target.ID} && ${Target.Distance}>150) /return
		/if (!${Target.ID} && ${ReportHeals}) /call AnnounceMessage "${HealChannel}" 2 y "I can't target" o "${Sender}'s corpse"
		/if (!${Target.ID} && ${DoBuffTells} && !${SpamTimer}) /tell ${Sender} I can't target your corpse
		/if (${Target.Type.Equal[Corpse]} ${ReportHeals}) /call AnnounceMessage "${HealChannel}" 2 y "I am attempting to Rez" o "${Sender}"
		/if (${Me.Class.ShortName.Equal[CLR]}) {
			/if (${Me.AltAbility[Blessing of Resurrection]} && ${Me.AltAbilityReady[Blessing of Resurrection]}) {
				/call Cast "Blessing of Resurrection" alt 10s SpellFiller 3
				} else /if (${FindItem[Water Sprinkler of Nem Ankh].ID}) {
				/call Cast "Water Sprinkler of Nem Ankh" item 6s SpellFiller 3
				} else {
				/call Cast "Reviviscence" ${BuffGem} 3s SpellFiller 3
				} else /call AnnounceMessage "${HealChannel}" 1 r "I have no way to rez?!?"
				/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
				/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]}) /call AnnounceMessage ${HealChannel} 1 r "Rez failed!"
			}
		/if ((${Me.Class.ShortName.Equal[DRU]} || ${Me.Class.ShortName.Equal[SHM]}) && !${SpawnCount[PC Group Cleric Radius 50]}) {
			/if (${Me.AltAbility[Rejuvenation of Spirit]}) {
:RezDelay
				/if (${Me.CombatState.Equal[COOLDOWN]}) {
					/delay 5s ${Me.CombatState.Equal[RESTING]}
					/if (${Me.CombatState.Equal[COMBAT]}) /return
					}
				/if (${Me.AltAbilityTimer[Rejuvenation of Spirit]} && ${Me.CombatState.Equal[RESTING]}) {
					/delay ${Me.AltAbilityTimer[Rejuvenation of Spirit]} ${Me.AltAbilityReady[Rejuvenation of Spirit]}
					/call Cast "Rejuvenation of Spirit" alt 10s SpellFiller 3
					/if (${castReturn.Equal[CAST_NOTREADY]}) {
						/call AnnounceMessage ${HealChannel} 1 y "Rez not ready yet, waiting..."
						/goto RezDelay
						}
					/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
					/return
					}
				}
			/if (${Me.Book[${Me.Book[Incarnate Anew]}].ID})	/call Cast "Incarnate Anew" ${BuffGem} 10s SpellFiller 3
			/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
			/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]}) /call AnnounceMessage ${HealChannel} 1 r "Rez failed!"
			}
		/return
		}
	/if (${Defined[RofGem]} && ${Defined[RodSpell]}) {
		/if ((${ChatText.Find[mod rod please]} || ${ChatText.Find[mod rod pls]}) && !${RDPause} && ${Me.Class.ShortName.Equal[MAG]} && ${DoBuffs} && (${RodGem.Equal[alt]} && ${Me.AltAbilityReady[${RodSpell}]} || ${RodGem.NotEqual[alt]} && ${Me.SpellReady[${Spell[${RodSpell}].RankName}]})) {
			/invoke ${Spawn[${Sender}].DoTarget}
			/call Cast "${RodSpell}" ${RodGem} 5s SpellFiller 3
			/delay 10s !${Me.Casting.ID}
			/call AnnounceMessage ${If[${castReturn.Equal[CAST_SUCCESS]} "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ has a new" o "${RodSpell}",/call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "${RodSpell}"]}
			}
		}
	/if (${ChatText.Find[who has]}) /call  check_who_has ${Sender} "${ChatText.Right[-8]}"
	/return	
	
Sub Event_Dead
	/delay 3s
	/call AnnounceMessage "${ChatChannel}" 1 y "rez me please"
	/call Wait4Rez
	/delay 2s
	/call Event_NewZone
	/doevents flush Dead
	/return
	
Sub Event_Experience
	/if (!${RDPause} && ${DoMercStance} && ${Mercenary.State.Equal[ACTIVE]} && ${Mercenary.Stance.NotEqual[Balanced]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]} || ${Mercenary.Class.Name.Equal[Cleric]})) /stance Balanced
	/if (!${RDPause} && ${AutoNinja}) /call LootMobs
	/if (${Group.MasterLooter.ID}==${Me.ID} || ${Group.Leader.ID}==${Me.ID}) /call LootCheck
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
	/delay 5s !${Me.Casting.ID}
	/delay 1s
	/if (${MakeCamp.Status.Equal[ON]}) /makecamp return
|	/if (${Bool[${Plugin[MQ2AAPurchase]}]}) /aapurchase now
	/call XPCommon
	/return	
	
Sub Event_Faded
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${Twist}) /squelch /twist off
		}
	/if (${Melee.Combat}) /squelch /target clear
	/call XPCommon
	/return
	
Sub Event_ImHit(Line, MobName)
	/if (!${Defined[MobName]}) {
		/if (${Me.XTarget}) /declare MobName string local ${Me.XTarget[1]}
		/if (!${Me.XTarget}) /declare MobName string local Bob
		}
	/if (!${RDPause} && ${UseDiscs}) /call DiscStuff 0
	/if (${DoHolyShit}) /call HolyShit "${MobName}"
	/if (${ReportEvents} && !${Select[${Me.Class.ShortName},WAR,PAL,SHD,BER,RNG,MNK]}) /docommand /bc [+r+]I'm being attacked!!
	/if (!${RDPause} && ${Target.Type.Equal[corpse]}) /target clear
	/if (${Me.ID}==${Spawn[${MA1}].ID} && !${RDPause} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]} && !${Melee.Combat} && ${Target.Type.NotEqual[Mercenary]}) /killthis
	/varset SitTimer 10s
	/doevents flush ImHit
	/return

Sub Event_Invite(Line,Inviter)
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${Twist}) /squelch /twist off
		}
	/if (${Me.Casting.ID}) /delay 10s !${Me.Casting.ID}
	/if (${MasterList.Find[${Inviter}]} || ${MasterList2.Find[${Inviter}]} || ${MasterList3.Find[${Inviter}]} || ${MasterList4.Find[${Inviter}]} || ${MasterList5.Find[${Inviter}]}) {
		/if (${Window[ConfirmationDialogBox].Open}) /notify ConfirmationDialogBox CD_Yes_Button leftmouseup
		/invite
		/delay 1s
		}
	/return

Sub Event_IRC(IRCSay,IRCSender,IRCCommand)
	/if (${IRCCommand.Left[1].Equal[/]} && (${MasterList.Find[${IRCSender}]} || ${MasterList2.Find[${IRCSender}]} || ${MasterList3.Find[${IRCSender}]} || ${MasterList4.Find[${IRCSender}]} || ${MasterList5.Find[${IRCSender}]})) {
		/docommand ${IRCCommand}
		} else {
		/if (!${IRCCommand.Find[told me]} && !${IRCCommand.Find[debuffed with]} && !${IRCCommand.Find[@]} && ${IRCCommand.Left[4].NotEqual[I am]} && ${IRCCommand.Left[7].NotEqual[Buffing]}) /call Event_Chat "irc" "${IRCSender}" "${IRCCommand}"
		}
	/return

Sub Event_IRCNoChan
	/if (${IRCConnect}>0) /return
	/if (${UseIRC}==TRUE && ${Irc}==FALSE) {
		/i quit
		/call Connect
	}
	/return	

Sub Event_ListSpells
	/declare a int local
	/for a 1 to ${SpellSetTotal}
		/if (${ReportToggles}) /call AnnounceMessage "${ChatChannel}" 2 y "${a}." o "${SpellSet${a}}"
	/next a
	/return	

Sub Event_LoadAlert
	/call RefreshAlerts
	/return
	
Sub Event_LoadIni(Line,LineArg)
	/call LoadIni "RD1_${Me.CleanName}${LineArg}.ini" LOAD
	/return	

Sub Event_Lootall
	/call LootMobs
	/return	
	
Sub Event_MakeStuff(Line,Stuff1,Stuff2)
	/if (${SummonFood}==TRUE) {
	   /declare i int local
	   /for i 1 to 2
		/if (${Me.FreeInventory}>=2 && !${RDPause} && ((${Me.Gem[${${Stuff${i}}Spell}]} || (!${SitTimer} && ${Spell[${${Stuff${i}}Spell}].RankName.ID})) || (${${Stuff${i}}Gem.Equal[alt]} && ${Me.AltAbilityReady[${${Stuff${i}}Gem}]}) || ${${Stuff${i}}Gem.Equal[item]}) && !${SpawnCount[npc targetable radius 25 noalert 1]}) {
			/call Cast "${${Stuff${i}}Spell}" ${${Stuff${i}}Gem} 5s Check4Pad
			/call ClearCursor
		}
	   /next i
	}
	/return

Sub Event_MezBroke(meztext,mezmob,mezbreaker)
	/if (${Spawn[id ${MATarget}].ID}!=${Spawn[id ${mezmob}].ID} && ${Mezbroke}) /call AnnounceMessage "${ChatChannel}" 4 m "-->" o "${mezbreaker}" r "has awakened" Y "** ${mezmob} **" ""
	/return	
	
Sub Event_MezIt(Line,MobName)
	/if (${RDPause}) /return
	/declare i int local
	/declare oldTarget int local 0
	/if (!${RDPause} && ${DoMez} && ${Spawn[${MobName}].Type.Equal[npc]}) {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==2 && ${Me.Casting.ID}!=${DebuffID[${i}]}) {
				/if (!${Me.Class.ShortName.Equal[BRD]} && ${Me.Casting.ID}) {
					/bc Mezit Interrupt 1
					}
				/varset oldTarget ${Target.ID}
				/if (${Target.ID}!=${NearestSpawn[npc targetable ${MobName} noalert 1].ID}) {
					/target targetable id ${NearestSpawn[npc targetable ${MobName} noalert 1].ID}
					}
				/delay 1s ${Target.ID}==${NearestSpawn[npc targetable ${MobName} noalert 1].ID}
				/if (${Bool[${Target.Mezzed.ID}]}) {
					/if (${Target.Mezzed.Duration.TotalSeconds}>20) {
						/return
						}
					}
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${DebuffGem${i}},item,alt]} && ${Me.Gem[${DebuffSpell${i}}]}) {
					/squelch /twist once ${Me.Gem[${DebuffSpell${i}}]}
					/varset castReturn CAST_SUCCESS
					/delay ${Spell[${DebuffSpell${i}}].MyCastTime.TotalSeconds}s
					/delay 1s
					/call DoCastingEvents
				} else /call Cast "${DebuffSpell${i}}" ${DebuffGem${i}} 5s SpellFiller 3
				/if (${ReportMez} && ${castReturn.Equal[CAST_SUCCESS]} && ${Target.ID}) {
					/call AnnounceMessage "${ChatChannel}" 2 y "Interupted" O "${Target.CleanName"
					}
				/varset castReturn CAST_CANCELLED
			}
		/next i
	}
	/if (${oldTarget}) /target targetable id ${oldTarget}
	/return

Sub Event_NeedStuff(Line,Need)
	/if (!${Defined[NeedStuffTimer]}) /call CreateTimer NeedStuffTimer
	/if (${ReportEvents} && !${Need.Find[stick]} && !${NeedStuffTimer}) {
		/call AnnounceMessage "${ChatChannel}" "2" "g" "I am" "y" "${Need}"
		}
	/varset NeedStuffTimer 3s
	/return

Sub Event_NewZone
	/declare i int local
	/declare a int local
	| Filter out false zone event matches
	/if (${Zone.Name.Equal[${ZoneName}]}) /return
	/echo Zone detected: Entering ${Zone.Name}...Loading NPC ignore list...
	/delay 120s ${Me.ID}
	/delay 5s
	/if ((${Zone.ShortName.Equal[guildlobby]} || ${Select[${Zone.ID},345,344,202,203,279]}) && !${RDPause}) {
		/varset RDPause on
		}
	/if (${ChatChannel.Equal[BC]}) /call AnnounceMessage "${ChatChannel}" 1 g "Ready boss!"
	/squelch /stick off
	/squelch /stick off
	/if (${MakeCamp.Status.Equal[ON]}) /makecamp off
	/keypress forward
	/keypress back
	/keypress left
	/keypress right
	/if (${DebuffTotal}) {
		/for i 1 to ${MaxMobs}
			/varset MobList[${i}] 0
			/for a 1 to ${DebuffTotal}
				/varset DebuffArray[${i},${a}] 0
				/next a
			/next i
		/varset VarNPCCount 0
		/for i 1 to ${DebuffTotal}
			/call LoadVar ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune | ${DebuffID[${i}]}Immune RDCommon.ini LOAD string
		/next i
	}
	/if (${DoBuffTotal}) {
		/for i 1 to 25
			/varset DoBuffQueue[${i},1] 0
			/varset DoBuffQueue[${i},2] 0
		/next i
		/varset QueueCount 0
	}
	/varset MATarget 999999
	/varset FollowGuy 999999
	/varset FollowFlag FALSE
	/varset PetID 0
	/call LoadVar RestrictedList ${Zone.ShortName} | RestrictedList RDCommon.ini LOAD string
	/varset ZoneName ${Zone.Name}
	/call RefreshAlerts
	/doevents flush
	/return

Sub Event_NoLuclin
	/varset UseMount 0
	/return

Sub Event_NoMount
	/if (${UseMount}) {
		/varset RestrictedList ${RestrictedList}NoMount|
		/ini RDCommon.ini RestrictedList ${Zone.ShortName} "NoMount|"
	}
	/return	

Sub Event_RaidExperience
	/call XPCommon
	/return

Sub Event_Rampage
	/if (!${RDPause} && ${DoRamp}) {
		/if (${Me.CurrentMana}>${Spell[${FastHealID}].Mana}) {
			/target targetable pc ${RampTank}
			/delay 5
			/if (${Target.ID}==${Spawn[pc ${RampTank}].ID} && ${Target.PctHPs}<${CancelPct} && ${Target.Distance}<${Int[${Spell[${FastHealID}].MyRange}]}) {
				/delay 10s !${Me.Casting.ID}
				/if (${ReportHeals} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Rampage Healing ->" m "${Target.CleanName}" g "<- with" t "${Spell[${FastHeal}].RankName}"
				/call Cast "${FastHeal}" ${FastHealGem} 3s CheckHP SpellFiller 3
			}
			/if (${Target.ID}!=${MATarget}) /call assistMA1
		}
	}
	/return


Sub Event_Recovered
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (!${RecoveredTimer} ${Twist}) /twist off
		}
	/delay 5s !${Me.Casting.ID}
	/doevents flush Recovered
	/varset RecoveredTimer 5s
	/return	

Sub Event_RemoveAura
	/if (${Me.Aura[1].ID}) /removeaura ${Me.Aura[1]}
	/delay 1s
	/if (${Me.Aura[2].ID}) /removeaura ${Me.Aura[2]}
	/return	

	
Sub Event_Restricted
	/if (${LastCast.NotEqual[BLAH]} && ${LastCast.Length}) {
		/varset RestrictedList ${RestrictedList}${LastCast}|
		/ini RDCommon.ini RestrictedList ${Zone.ShortName} "${RestrictedList}"
	}
	/return

Sub Event_SaveIni(Line,LineArg)
	/if (!${Defined[${LineArg}]}) /varset LineArg ${RDIni}
	/call LoadIni ${LineArg} SAVE
	/return

Sub Event_SetBuff(Line,LineArg)
	/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID} || (${Line.Arg[3].Equal[${FindItem[${Line.Arg[3]}]}]} && ${FindItem[${Line.Arg[3]}].ID}) || ${Me.AltAbilityReady[${Line.Arg[3]}]}) {
		/if (${Line.Arg[4].Equal[group]}) {
			/declare i int local
			/for i ${Group} downto 0 
				/target targetable id ${Group.Member[${i}].ID}
				/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /next i
				/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
				/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
				/if (${FindItem[${Line.Arg[3]}].ID}) /call Cast "${Line.Arg[3]}" item 10s SpellFiller 3
				/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
			/next i
			/return
			}
			/if (${Line.Arg[4].Equal[raid]}) {
				/declare i int local
				/for i ${Raid.Members} downto 1
					/if (${i}==0) /return
					/if (!${Raid.Member[${i}].GroupLeader}) /continue
					/target targetable id ${Raid.Member[${i}].ID}
					/delay 1s ${Target.ID}==${Raid.Member[${i}].ID}
					/if (${Target.ID}!=${Raid.Member[${i}].ID}) /continue
					/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
					/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
					/if (${FindItem[${Line.Arg[3]}].ID}) /call Cast "${Line.Arg[3]}" item 10s SpellFiller 3
					/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
				/next i
				/return
			}
			/if (${Spawn[pc ${Line.Arg[4]}].ID}) {
				/target targetable id ${Spawn[pc ${Line.Arg[4]}].ID}
				/delay 1s ${Target.ID}==${Spawn[pc ${Line.Arg[4]}].ID}
			} else {
				/if (${Spawn[${Line.Arg[4]}].ID}) {
				/target targetable id ${Spawn[${Line.Arg[4]}].ID}
				/delay 1s ${Target.ID}==${Spawn[${Line.Arg[4]}].ID}
			}
		}
		/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
		/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
		/if (${FindItem[${Line.Arg[3]}].ID}) /call Cast "${Line.Arg[3]}" item 10s SpellFiller 3
		/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
		/if (${Me.Class.ShortName.Equal[BRD]}) {
			/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
			}
		/return
	}
	/if (${Line.Arg[4].Equal[group]}) {
		/declare i int local
		/for i ${Group} downto 0
			/call CheckDoBuffs "${Group.Member[${i}].Name}" "${Line.Arg[3]}"
		/next i
		/return
		}
	/if (${Line.Arg[4].Equal[raid]}) {
		/declare i int local
		/for i ${Raid.Members} downto 1
			/if (${i}==0) /return
			/if (!${Raid.Member[${i}].GroupLeader}) /continue
			/call CheckDoBuffs "${Raid.Member[${i}].Name}" "${Line.Arg[3]}"
		/next i
		/return
		}
	/if (${Line.Arg[4].Length} && ${Spawn[pc ${Line.Arg[4]}].ID}) /call CheckDoBuffs "${Spawn[pc ${Line.Arg[4]}].CleanName}" "${Line.Arg[3]}"
	/if (${Line.Arg[4].Length} && ${Spawn[${Line.Arg[4]}].Type.NotEqual[npc]} && ${Spawn[${Line.Arg[4]}].ID}) /call CheckDoBuffs "${Spawn[${Line.Arg[4]}].CleanName}" "${Line.Arg[3]}"
	/return
	
Sub Event_SetMA1(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "NULL"
		}
	/return

Sub Event_SetMA2(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "NULL"
		}
	/return

Sub Event_SetMA3(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #3" "MA3" "GeneralStuff" "MA3" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #3" "MA3" "GeneralStuff" "MA3" "NULL"
		}
	/return

Sub Event_SetRampTank(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Rampage Tank" "RampTank" "HealStuff" "RampTank" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Rampage Tank" "RampTank" "HealStuff" "RampTank" "NULL"
		}
	/return	
	
Sub Event_ShowDebuffs(line,NPCID)
	/if (!${DebuffTotal}) /return
	/declare a           int local
	/declare b           int local
	/for a 1 to ${MaxMobs}
		/if (${NPCID}==${MobList[${a}]}) {
			/for b 1 to ${DebuffTotal}
				/if (1) /${DebuffChannel} Spell ${DebuffSpell${b}}: ${Math.Calc[${DebuffArray[${a},${b}]}-${Macro.RunTime}]}s
			/next b
			/return 
		}
	/next a
	/if (1) /${DebuffChannel} ${Spawn[${NPCID}]} is not on MobList (${VarNPCCount} / ${MaxMobs}), calling PopulateNPCs
	/call PopulateNPCs
	/return 

	
Sub Event_Stand
	/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
	/return	

Sub Event_ToggleAABuy
	/echo ToggleVar Auto AABuy,AABuy,Settings,AABuy,
	/if (${AABuy})	/call AAInit
	/return

Sub Event_ToggleString(Stuff,TempMessage,TempVar,IniSection,IniEntry,Line)
	/if (${Defined[${TempVar}]}) {
		/if (${Line.Length}) {
			/varset ${TempVar} ${Line}
			/ini "${RDIni}" ${IniSection} ${IniEntry} "${${TempVar}}"
			}
		/if (${ReportToggles}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" y "${${TempVar}}"
		}
	/return

Sub Event_ToggleVar(Stuff,TempMessage,TempVar,IniSection,IniEntry,Line)
	/if (${Defined[${TempVar}]}) {
		/if (!${Line.Length}) {
			/if (${${TempVar}}) {
				/varset ${TempVar} 0
			} else {
				/varset ${TempVar} 1
			}
		}
		/if (${Line.Arg[1].Equal[ON]} || ${Line.Arg[1].Equal[TRUE]} || ${Line.Arg[1].Equal[1]}) /varset ${TempVar} 1
		/if (${Line.Arg[1].Equal[OFF]} || ${Line.Arg[1].Equal[FALSE]} || ${Line.Arg[1].Equal[0]}) /varset ${TempVar} 0
		/if (${ReportToggles} && ${${TempVar}}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" Y "ON"
		/if (${ReportToggles} && !${${TempVar}}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" Y "OFF"
		/if (${IniSection.NotEqual[NULL]} && ${IniEntry.NotEqual[NULL]}) /ini "${RDIni}" ${IniSection} ${IniEntry} ${${TempVar}}
	}
	/if (${RDPause} && ${Me.Class.ShortName.Equal[BRD]}) {
		/if (${Twist}) /squelch /twist off
		}
	/return

Sub Event_TooClose
	/if (${Me.AutoFire}) /autofire off
	/face
	/delay 5s (!${Me.AutoFire})
	/if (${Target.ID}==${MATarget} && !${Me.Moving} && ${DoMelee} && ${Target.Type.NotEqual[Mercenary]}) /killthis
	/return

Sub Event_TooFar
	/if (${Target.ID}==${MATarget} && !${Me.Moving} && ${DoMelee}) {
		/if (${Target.Distance}<10 && ${Target.Distance}>100) {
			/if (${Stick.Status.Equal[ON]}) {
				/squelch /stick off
				/squelch /melee reset
				/delay 005
				}
			/if (${Stick.Status.Equal[OFF]}) {
				/stick ID ${MATarget}
				}				
			}

		/if (${Target.Distance}<${NPCRadChk} && ${Guard} && ${MakeCamp.Status.Equal[ON]}) {
			/target clear
			/varset MATarget NULL
			}
		}
	/doevents flush TooFar
	/return

Sub Event_WornOff(Line,SpellName,Dude)
	/declare i int local
	/declare j int local
	/if (${DoBuffTotal} && ${RefreshBuffs} && ${Select[${Spawn[${Dude}].Type},PC,Pet,Mercenary]}) {
		/for i 1 to ${DoBuffTotal}
			/if (${SpellName.Equal[${Spell[${DoBuffID[${i}]}].Name}]} && ${DoBuffRefresh${i}}) {
				/for j 1 to ${SpawnCount[${Dude}]}
				/if (${NearestSpawn[${j}, ${Dude}].CleanName.Equal[${Dude}]}) /call AddToQueue ${NearestSpawn[${j}, ${Dude}].ID} ${i}
                /next j
				}
			/next i
		}
	/return	

	
	
Sub LoadIni(MyIni,Function)
	/declare i int local
	/declare j int local
	/call LoadVar RestrictedList ${Zone.ShortName} | RestrictedList RDCommon.ini ${Function} string
	/call LoadVar IgnoreNPCList ${Zone.ShortName} | IgnoreNPCList RDCommon.ini ${Function} string
	/call RefreshAlerts
	
	/call LoadVar GeneralStuff ChatChannel echo ChatChannel "${MyIni}" ${Function} string
	/call LoadVar Settings MasterList "Put your list of master bots here" MasterList "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList2 "Put your list of master bots here" MasterList2 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList3 "Put your list of master bots here" MasterList3 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList4 "Put your list of master bots here" MasterList4 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList5 "Put your list of master bots here" MasterList5 "RDCommon.ini" ${Function} string
	/call LoadVar GeneralStuff AssistMA FALSE AssistMA "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff TargetLock FALSE TargetLock "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff AssistDelay 5s AssistDelay "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA1 "Main Assist 1" MA1 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA2 "Main Assist 2" MA2 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA3 "Main Assist 3" MA3 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff ChangeTank FALSE ChangeTank "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff EngageHPs 98 EngageHPs "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff StopHPs 10 StopHPs "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff UseEpic 1 UseEpic "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff Epic "Put the name of your epic here" Epic "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff InvisibilitySpell "Put the name of your invis spell or item here" InvisibilitySpell "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff InvisibilityGem "Put gem# for spells, or item for items" InvisibilityGem "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff CalmSpell "Put the name of your calm spell or item here" CalmSpell "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff CalmGem "Put gem# for spells, or item for items" CalmGem "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff Mezbroke FALSE Mezbroke "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff MaxMezLvl 93 MaxMezLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff MaxCharmLvl 89 MaxCharmLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff MaxCalmLvl 90 MaxCalmLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff ReportEvents FALSE ReportEvents "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff ReportToggles FALSE ReportToggles "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff RelayTells FALSE RelayTells "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff UseGroupMA TRUE UseGroupMA "${MyIni}" ${Function} bool
    /call LoadVar GeneralStuff UseGroupTank FALSE UseGroupTank "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff UseRaidMA FALSE UseRaidMA "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff TraderName "Put the name of your Trader here" TraderName "${MyIni}" ${Function} string
	/if (${Select[${Me.Class.ShortName},DRU,WIZ]}) {
		/call LoadVar GeneralStuff DoPorts FALSE DoPorts "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff PortGem "gem12, change for your tastes" PortGem "${MyIni}" ${Function} string
	}
	/if (!${Defined[ASRadius]}) /declare ASRadius int outer 20
	/if (!${Defined[PetAssistTimer]}) /declare PetAssistTimer  timer outer ${AssistDelay}																					  
	/if (!${Defined[ASZRadius]}) /declare ASZRadius int outer 50
	/call LoadVar Settings LeashLength 25 LeashDistance "${MyIni}" ${Function} int
	/call LoadVar Settings NPCRadius 75 NPCRadius "${MyIni}" ${Function} int
	/call LoadVar Settings NPCzradius 50 NPCZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings PCRadius 200 PCRadius "${MyIni}" ${Function} int
	/call LoadVar Settings PCzradius 50 PCZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings AutoNinja FALSE AutoNinja "${MyIni}" ${Function} bool
	/call LoadVar Settings AABuy "FALSE" AABuy "${MyIni}" ${Function} bool
	/call LoadVar Settings UseIRC "FALSE" UseIRC "${MyIni}" ${Function} bool
	/call LoadVar Settings IRCAddress "IRC Server URL" IRCAddress "${MyIni}" ${Function} string
	/call LoadVar Settings IRCPort "6667" IRCPort "${MyIni}" ${Function} int
	/call LoadVar Settings IRCChannel "#Name of Chat with Pound sign" IRCChannel "${MyIni}" ${Function} string
	/call LoadVar Settings AutoSit FALSE AutoSit "${MyIni}" ${Function} bool
	/call LoadVar Settings ASRadius 20 ASRaidus "${MyIni}" ${Function} int
	/call LoadVar Settings ASZRadius 50 AZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings SitDelay 3s SitDelay "${MyIni}" ${Function} string
	/call LoadVar Settings EndMedPct 80 EndMedPct "${MyIni}" ${Function} int
	/call LoadVar Settings UseMount FALSE UseMount "${MyIni}" ${Function} bool
	/call LoadVar Settings MountItem "Put the name of your mount summoning item here" MountItem "${MyIni}" ${Function} string
	/call LoadVar Settings DoShrink FALSE DoShrink "${MyIni}" ${Function} bool
	/call LoadVar Settings ShrinkSpell "Put the name of your shrink spell or item here" ShrinkSpell "${MyIni}" ${Function} string
	/call LoadVar Settings ShrinkGem "item or gemNumber or alt" ShrinkGem "${MyIni}" ${Function} string
    /call LoadVar Settings ShrinkSelfOnly TRUE ShrinkSelfOnly "${MyIni}" ${Function} bool
    /call LoadVar Settings MoveUpJitter 10 MoveUpJitter "${MyIni}" ${Function} int
|---Pull Spell Section
    /call LoadVar Settings UsePullSpell FALSE UsePullSpell "${MyIni}" ${Function} bool
    /call LoadVar Settings PullSpell1 "Put Pull-Spell name here" PullSpell1 "${MyIni}" ${Function} string
    /call LoadVar Settings PullSpellGem1 "Put Pull Gem#, Alt, or Item here" PullSpellGem1 "${MyIni}" ${Function} string
	/call LoadVar SummonStuff SummonFood "FALSE" SummonFood "${MyIni}" ${Function} bool
	/call LoadVar SummonStuff FoodSpell "Put the name of your food summoning spell/item here" foodSpell "${MyIni}" ${Function} string
	/call LoadVar SummonStuff FoodGem "Put gem# for spells, or item for items" foodGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff DrinkSpell "Put the name of your drink summoning spell/item here" drinkSpell "${MyIni}" ${Function} string
	/call LoadVar SummonStuff DrinkGem "Put gem# for spells, or item for items" drinkGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff UseAmmoClicky "FALSE" UseAmmoClicky "${MyIni}" ${Function} bool
	/call LoadVar SummonStuff AmmoGem "item, alt, or gemX" AmmoGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff AmmoClicky "Put the name of your Ammo Clicky here" AmmoClicky "${MyIni}" ${Function} string
	/call LoadVar SummonStuff AmmoItem "Put the name of the item to summon here" AmmoItem "${MyIni}" ${Function} string
	/call LoadVar MeleeStuff DoDefense FALSE DoDefense "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff DoMelee FALSE DoMelee "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff DoRanged FALSE DoRanged "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff RangeDist 30 RangeDist "${MyIni}" ${Function} int
	/call LoadVar MeleeStuff DoMercStance FALSE DoMercStance "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff MercEngageHPs 98 MercEngageHPs "${MyIni}" ${Function} int 
	/call LoadVar MeleeStuff DoMercAssist TRUE DoMercAssist "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff Guard FALSE Guard "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff LOSOnly FALSE LOSOnly "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff Status TRUE Status "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff ReportDefense FALSE ReportDefense "${MyIni}" ${Function} bool
	/if (${Select[${Me.Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]}) {
		/call LoadVar MeleeStuff DiscTotal 1 DiscTotal ${MyIni} ${Function} int
		/if (${DiscTotal}) {
			/call LoadVar MeleeStuff UseDiscs FALSE UseDiscs ${MyIni} ${Function} bool
			/for i 1 to ${DiscTotal}
				/call LoadVar MeleeStuff DiscName${i} "Put the name of Discipline #${i} here" DiscName${i} ${MyIni} ${Function} string
				/call LoadVar MeleeStuff DiscType${i} 0 DiscType${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscEndurance${i} 100 DiscEndurance${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscMinHPs${i} 0 DiscMinHPs${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscMaxHPs${i} 0 DiscMaxHPs${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscSpawnCount${i} 1 DiscSpawnCount${i} ${MyIni} ${Function} int
			 /next i
			}
		}

	/call LoadVar HealStuff BegFrantic FALSE BegFrantic "${MyIni}" ${Function} bool
	/call Loadvar HealStuff BegFranticPct 35 BegFranticPct "${MyIni}" ${Function} int
	/call LoadVar HealStuff BegFranticChannel "bc" BegFranticChannel "${MyIni}" ${Function} string
	/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) {
		/if (!${Defined[DAArray]})         /declare DAArray[6,2]    int    outer
		/if (!${Defined[StartHPs]})        /declare StartHPs        int    outer
		/if (!${Defined[TankLastPct]})     /declare TankLastPct     int    outer
		/if (!${Defined[TankPPS]})         /declare TankPPS         int    outer
		/if (!${Defined[TankTTL]})         /declare TankTTL         int    outer
		/if (!${Defined[TotalTankHits]})   /declare TotalTankHits   int    outer
		/if (!${Defined[TotalTankTime]})   /declare TotalTankTime   int    outer
		/if (!${Defined[TankTimeArray]})   /declare TankTimeArray[30]  int    outer
		/if (!${Defined[TankHitsArray]})   /declare TankHitsArray[30]  int    outer
		/if (!${Defined[TankHitsIndex]})   /declare TankHitsIndex   int   outer 1
		/if (!${Defined[WorstHPs]})        /declare WorstHPs        int    outer 100
		/if (!${Defined[WorstID]})         /declare WorstID         int    outer
		/if (!${Defined[WorstMember]})     /declare WorstMember     int    outer
		/if (!${Defined[GroupHurtCount]})  /declare GroupHurtCount  int    outer
		/if (!${Defined[TankPPSTimer]})    /declare TankPPSTimer    timer  outer
		/call LoadVar HealStuff ReportHeals FALSE ReportHeals "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealMessage "%Spell @ %Target" HealMessage "${MyIni}" ${Function} string
		/call LoadVar HealStuff ReportInterrupts FALSE ReportInterrupts "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealChannel echo HealChannel "${MyIni}" ${Function} string
		/call LoadVar HealStuff StayOnHeal 5s StayOnHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff HealMeFirst FALSE HealMeFirst "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealFD FALSE HealFD "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealXTarget FALSE HealXTarget "${MyIni}" ${Function} bool
		/call LoadVar HealStuff GroupHealing FALSE HealGroup "${MyIni}" ${Function} bool
		/call LoadVar HealStuff CheckGroupInterval 5 CheckGroupInterval "${MyIni}" ${Function} string
		/call LoadVar HealStuff AutoInterrupt FALSE Stop4Pad "${MyIni}" ${Function} bool
		/call LoadVar HealStuff RampHealing FALSE DoRamp "${MyIni}" ${Function} bool
		/call LoadVar HealStuff RampTank "Rampage Tank" RampTank "${MyIni}" ${Function} string
		/call LoadVar HealStuff AEHealing FALSE AEHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff AssistHealing FALSE AssistHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealPct 70 HealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff CancelPct 90 CancelPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff WaitToCancel FALSE WaitToCancel "${MyIni}" ${Function} bool
		/call LoadVar HealStuff DelayedHeal "Put the name of your delayed heal spell here" DelayedHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff DelayedHealGem "Put the spell gem you want to cast your delayed heal from here" DelayedHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff DelayedHealPct 90 DelayedHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseDelayedHeal TRUE UseDelayedHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff UseCH FALSE UseCH "${MyIni}" ${Function} bool
		/call LoadVar HealStuff TankHealPct 70 TankHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff TankHeal "Put the name of your tank heal spell here" TankHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff TankHealGem "Put the spell gem you want to cast your tank heal from here" TankHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff PetHealing FALSE HealPets "${MyIni}" ${Function} bool
		/call LoadVar HealStuff PetHealPct 50 PetHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff PetHeal "Put the name of your pet heal spell here" PetHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff PetHealGem "Put the spell gem you want to cast your pet heal from here" PetHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff FastHeal "Put the name of your fast heal spell here" FastHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff FastHealGem "Put the spell gem you want to cast your fast heal from here" FastHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHeal "Put the name of your group heal spell here" GroupHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHealGem "Put the spell gem you want to cast your group heal from here" GroupHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHealCount 3 GroupHealCount "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseFranticHeal FALSE UseFranticHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff FranticHeal "Put the name of your Frantic emergancy heal here" FranticHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff FranticHealGem "Put the spell gem that FranticHeal is cast from here" FrantHealGem "${MyIni}" ${Function} string
		/if (!${Defined[FastHealID]})     /declare FastHealID    int outer ${Me.Book[${Me.Book[${Spell[${FastHeal}].RankName}]}].ID}
		/if (!${Defined[GroupHealID]})    /declare GroupHealID   int outer ${Me.Book[${Me.Book[${Spell[${GroupHeal}].RankName}]}].ID}
		/if (!${Defined[TankHealID]})     /declare TankHealID    int outer ${Me.Book[${Me.Book[${Spell[${TankHeal}].RankName}]}].ID}
		/if (!${Defined[PetHealID]})      /declare PetHealID     int outer ${Me.Book[${Me.Book[${Spell[${PetHeal}].RankName}]}].ID}
		/if (!${Defined[DelayedHealID]})  /declare DelayedHealID int outer ${Me.Book[${Me.Book[${Spell[${DelayedHeal}].RankName}]}].ID}
		/if (!${Defined[FranticHealGem]}) /declare FranticHealGem string outer Gem8
		}
	/call LoadVar CureStuff CureTotal 1 CureTotal "${MyIni}" ${Function} int
	/call LoadVar SelfBuffStuff SelfBuffTotal 1 SelfBuffTotal "${MyIni}" ${Function} int
	/call LoadVar DoBuffStuff DoBuffTotal 1 DoBuffTotal "${MyIni}" ${Function} int
	/call LoadVar DebuffStuff DebuffTotal 1 DebuffTotal "${MyIni}" ${Function} int
	/call LoadVar RestStuff RestTotal 1 RestTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/if (!${Defined[RestStuffTimer]}) /declare RestStuffTimer timer  outer
		/call LoadVar RestStuff DoRestStuff FALSE DoRestStuff "${MyIni}" ${Function} bool
		/call LoadVar RestStuff RestStuffRecheck 10s RestStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${RestTotal}
			/call LoadVar RestStuff RestCommand${i} "Insert the command to execute" RestCommand${i} "${MyIni}" ${Function} string
			/call LoadVar RestStuff RestCondition${i} "Insert the condition to execute the command" RestCondition${i} "${MyIni}" ${Function} string
		/next i	
		}
	/call LoadVar CombatStuff CombatTotal 1 CombatTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/call LoadVar CombatStuff DoCombatStuff FALSE DoCombatStuff "${MyIni}" ${Function} bool
		/call LoadVar CombatStuff CombatStuffRecheck 10s CombatStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${CombatTotal}
			/call LoadVar CombatStuff CombatCommand${i} "Insert the command to execute" CombatCommand${i} "${MyIni}" ${Function} string
			/call LoadVar CombatStuff CombatCondition${i} "Insert the condition to execute the command" CombatCondition${i} "${MyIni}" ${Function} string
		/next i	
		}
	/call LoadVar NamedStuff NamedTotal 1 NamedTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/if (!${Defined[NamedStuffTimer]}) /declare NamedStuffTimer timer  outer
		/call LoadVar NamedStuff DoNamedStuff FALSE DoNamedStuff "${MyIni}" ${Function} bool
		/call LoadVar NamedStuff NamedStuffRecheck 10s NamedStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${NamedTotal}
			/call LoadVar NamedStuff NamedCommand${i} "Insert the command to execute" NamedCommand${i} "${MyIni}" ${Function} string
			/call LoadVar NamedStuff NamedCondition${i} "Insert the condition to execute the command" NamedCondition${i} "${MyIni}" ${Function} string
		/next i	
		}	
	/if (${CureTotal}) {
		/if (!${Defined[DoCures]}) /declare DoCures bool outer FALSE
		/call LoadVar CureStuff DoCures FALSE DoCures "${MyIni}" ${Function} bool
		/call LoadVar CureStuff ReportCures FALSE ReportCures "${MyIni}" ${Function} bool
		/for i 1 to ${CureTotal}
			/call LoadVar CureStuff CureSpell${i} "Cure Item/Spell #${i}" CureSpell${i} "${MyIni}" ${Function} string
			/call LoadVar CureStuff CureGem${i} "Cure #${i} Gem, or put Item if an item, or ALT if an AA" CureGem${i} "${MyIni}" ${Function} string
			/call LoadVar CureStuff CurseCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" CurseCounters${i} "${MyIni}" ${Function} int
			/call LoadVar CureStuff DiseaseCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" DiseaseCounters${i} "${MyIni}" ${Function} int
			/call LoadVar CureStuff PoisonCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" PoisonCounters${i} "${MyIni}" ${Function} int
            /call LoadVar CureStuff CorruptionCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" CorruptionCounters${i} "${MyIni}" ${Function} int
			/if (${CureGem${i}.NotEqual[item]} && ${CureGem${i}.NotEqual[alt]}) /varset CureSpell${i} ${Spell[${CureSpell${i}}].RankName}
		/next i
		}
	/if (${SelfBuffTotal}) {
		/if (!${Defined[SelfBuffID]})      /declare SelfBuffID[${SelfBuffTotal}]      int    outer
		/if (!${Defined[SelfBuffTimer]})   /declare SelfBuffTimer                     timer  outer
		/if (!${Defined[SelfBuff]})        /declare SelfBuff[${SelfBuffTotal}]        int    outer																					
		/call LoadVar SelfBuffStuff SelfBuffs FALSE SelfBuffs "${MyIni}" ${Function} bool
		/call LoadVar SelfBuffStuff ReportSelfBuffs FALSE ReportSelfBuffs "${MyIni}" ${Function} bool
		/call LoadVar SelfBuffStuff SelfBuffRecheck 10s SelfBuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${SelfBuffTotal}
			/call LoadVar SelfBuffStuff SelfBuff${i} "Self Buff Item/Spell #${i}" SelfBuff${i} "${MyIni}" ${Function} string
			/call LoadVar SelfBuffStuff SelfBuffGem${i} "Self Buff #${i} Gem, or put ITEM if an item, or COMB if it is a disc, or put ALT if it is an AA" SelfBuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar SelfBuffStuff SelfBuffCount${i} 30 SelfBuffCount${i} "${MyIni}" ${Function} int
			/call LoadVar SelfBuffStuff SelfBuffAura${i} FALSE SelfBuffAura${i} "${MyIni}" ${Function} bool
			/call LoadVar SelfBuffStuff SelfBuffIcon${i} NOTFOUND SelfBuffIcon${i} "${MyIni}" ${Function} string
			/if (${SelfBuffGem${i}.Equal[ALT]} && ${Me.AltAbility[${SelfBuff${i}}]}) /varset SelfBuffID[${i}] ${Me.AltAbility[${SelfBuff${i}}]}
			/if (${SelfBuffGem${i}.Equal[ITEM]} && ${FindItem[${SelfBuff${i}}].ID}) /varset SelfBuffID[${i}] ${FindItem[${SelfBuff${i}}].ID}
			/if (${SelfBuffGem${i}.NotEqual[ALT]}  && ${SelfBuffGem${i}.NotEqual[item]} && ${SelfBuffGem${i}.NotEqual[comb]} && ${Spell[${SelfBuff${i}}].RankName.ID} && !${SelfBuffAura${i}}) {
				/varset SelfBuff${i} ${Spell[${SelfBuff${i}}].RankName}
				/varset SelfBuffID[${i}] ${Spell[${SelfBuff${i}}].RankName.ID}
				/varset SelfBuffIcon${i} ${Spell[${SelfBuffIcon${i}}].RankName}
				}
			/if (${SelfBuffGem${i}.Equal[COMB]} && ${Me.CombatAbility[${SelfBuff${i}}]}) /varset SelfBuffID[${i}] ${Spell[${SelfBuff${i}}].ID}
|			/if (!${SelfBuffAura${i}}) {
|				/if (${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset SelfBuffID[${i}] ${Spell[${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND]}].ID}
|			}
			/if (${SelfBuffAura${i}} && ${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND].Equal[NOTFOUND]}) /varset SelfBuffIcon${i} ${SelfBuff${i}}
		/next i
		}
	/if (${DoBuffTotal}) {
		/if (!${Defined[RezBuff]}) 		  /declare RezBuff[${DoBuffTotal}]  int   outer	
		/if (!${Defined[DoBuffID]})       /declare DoBuffID[${DoBuffTotal}] int   outer
		/call LoadVar DoBuffStuff DoBuffs FALSE DoBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff ReportDoBuffs FALSE ReportDoBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff DoBuffTells FALSE DoBuffTells "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff RefreshBuffs FALSE RefreshBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff DoBuffMana 0 DoBuffMana "${MyIni}" ${Function} int
		/for i 1 to ${DoBuffTotal}
			/call LoadVar DoBuffStuff DoBuff${i} "Do Buff Item/Spell #${i}" DoBuff${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffGem${i} "Do Buff #${i} Gem or put Item if an item" DoBuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffMana${i} 0 DoBuffMana${i} "${MyIni}" ${Function} int
			/call LoadVar DoBuffStuff DoBuffAliases${i} "Put the keywords you want to respond to for this buff" DoBuffAliases${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffRefresh${i} FALSE DoBuffRefresh${i} "${MyIni}" ${Function} bool
			/call LoadVar DoBuffStuff BattleBuff${i} 0 BattleBuff${i} "${MyIni}" ${Function} int
			/call LoadVar DoBuffStuff RezBuff${i} FALSE RezBuff${i} "${MyIni}" ${Function} bool
			/if (${DoBuffGem${i}.Equal[alt]} && ${Me.AltAbility[${DoBuff${i}}].Spell.ID}) /varset DoBuffID[${i}] ${Me.AltAbility[${DoBuff${i}}].Spell.ID}
			/if (${DoBuffGem${i}.Equal[ITEM]} && ${FindItem[${DoBuff${i}}].ID}) /varset DoBuffID[${i}] ${FindItem[${DoBuff${i}}].ID}
			/if (${DoBuffGem${i}.NotEqual[alt]} && ${DoBuffGem${i}.NotEqual[item]} && ${Spell[${DoBuff${i}}].RankName.ID}) {
				/varset DoBuff${i} ${Spell[${DoBuff${i}}].RankName}
				/varset DoBuffID[${i}] ${Spell[${DoBuff${i}}].RankName.ID}
				}
|			/if (${Ini[${RDIni},DoBuffStuff,DoBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset DoBuffID[${i}] ${Spell[${Ini[${RDIni},DoBuffStuff,DoBuffIcon${i},NOTFOUND]}].ID}
			/if (${BattleBuff${i}} && !${Defined[BattleBuffFlag]}) /declare BattleBuffFlag bool outer TRUE
			/if (${DoBuffLowest}>${DoBuffMana${i}}) /varset DoBuffLowest ${DoBuffMana${i}}
		/next i
		}
	/if (${DebuffTotal}) {
		/if (!${Defined[DebuffID]})       /declare DebuffID[${DebuffTotal}] int  outer
		/if (!${Defined[LastSpawnCount]}) /declare LastSpawnCount           int  outer
		/if (!${Defined[VarNPCCount]})    /declare VarNPCCount              int  outer
		/if (!${Defined[VarOldNPCCount]}) /declare VarOldNPCCount           int  outer
		/if (!${Defined[DebuffLowest]})   /declare DebuffLowest             int  outer 100
		/if (!${Defined[MADebuffed]})     /declare MADebuffed               bool outer
		/if (!${Defined[MADebuffOnly]})   /declare MADebuffOnly             bool outer TRUE
		/if (!${Defined[ProcessResist]})  /declare ProcessResist            bool outer TRUE
		/if (!${Defined[DoCharm]}) /declare DoCharm bool outer FALSE
		/if (!${Defined[DoDebuffs]}) /declare DoDebuffs bool outer FALSE
		/call LoadVar DebuffStuff DoDebuffs FALSE DoDebuffs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoDoTs FALSE DoDoTs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoMez FALSE DoMez "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoAEMez FALSE DoAEMez "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoCharm FALSE DoCharm "${MyIni}" ${Function} bool
		/if (${Select[${Me.Class.ShortName},ENC,NEC,SHD]}) /call LoadVar DebuffStuff DoManaTaps FALSE DoManaTaps "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportDebuffs FALSE ReportDebuffs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportDoTs FALSE ReportDoTs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportMez FALSE ReportMez "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffChannel echo DebuffChannel "${MyIni}" ${Function} string
		/call LoadVar DebuffStuff UseHoTT FALSE UseHoTT "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff MaxMobs 5 MaxMobs "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff AllDebuffsFirst TRUE AllDebuffsFirst "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffMAFirst TRUE DebuffMAFirst "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffGreens FALSE DebuffGreens "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoTDurFocus 26 DoTDurFocus "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff DoTDurAASecs 0 DoTDurAASecs "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff MezDurAASecs 0 MezDurAASecs "${MyIni}" ${Function} int
		/for i 1 to ${DebuffTotal}
			/call LoadVar DebuffStuff DebuffSpell${i} "Debuff Item/Spell #${i}" DebuffSpell${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff DebuffGem${i} "Debuff #${i} Spell Gem or put Item if an item" DebuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff DebuffMana${i} 0 DebuffMana${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffHPs${i} 100 DebuffHPs${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffStopHPs${i} 0 DebuffStopHPs${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffRecast${i} 0 DebuffRecast${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffSpellSet${i} 0 DebuffSpellSet${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffMAOnly${i} TRUE DebuffMAOnly${i} "${MyIni}" ${Function} bool
			/call LoadVar DebuffStuff DebuffCondition${i} TRUE DebuffCondition${i} "${MyIni}" ${Function} string
			/if (!${DebuffMAOnly${i}}) /varset MADebuffOnly ${DebuffMAOnly${i}}
			/call LoadVar DebuffStuff DebuffNamedOnly${i} FALSE DebuffNamedOnly${i} "${MyIni}" ${Function} bool
			/call LoadVar DebuffStuff DebuffMessage${i} "%Target Debuffed by %Spell" DebuffMessage${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff SpellType${i} 0 SpellType${i} "${MyIni}" ${Function} int
			/if (${DebuffGem${i}.Equal[alt]} && ${Me.AltAbility[${DebuffSpell${i}}].Spell.ID}) /varset DebuffID[${i}] ${Me.AltAbility[${DebuffSpell${i}}].Spell.ID}
			/if (${DebuffGem${i}.Equal[item]} && ${FindItem[${DebuffSpell${i}}].ID}) /varset DebuffID[${i}] ${FindItem[${DebuffSpell${i}}].ID}
			/if (${DebuffGem${i}.NotEqual[alt]} && ${DebuffGem${i}.NotEqual[item]} && ${Spell[${DebuffSpell${i}}].RankName.ID}) {
				/varset DebuffSpell${i} ${Spell[${DebuffSpell${i}}].RankName}
				/varset DebuffID[${i}] ${Spell[${DebuffSpell${i}}].RankName.ID}
				}
			/if (${DebuffLowest}>${DebuffMana${i}}) /varset DebuffLowest ${DebuffMana${i}}
			/call LoadVar ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune | ${DebuffID[${i}]}Immune RDCommon.ini ${Function} string
		/next i
		/if (!${Defined[DebuffArray]}) /declare DebuffArray[${MaxMobs},${DebuffTotal}] int outer
		/if (!${Defined[MobList]})     /declare MobList[${MaxMobs}]                    int outer
		}
	/call LoadVar Settings AutoSit FALSE AutoSit "${MyIni}" ${Function} bool
	/call LoadVar Settings ASRadius 20 ASRaidus "${MyIni}" ${Function} int
	/call LoadVar Settings ASZRadius 50 AZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings SitDelay 3s SitDelay "${MyIni}" ${Function} string
	/call LoadVar Settings EndMedPct 80 EndMedPct "${MyIni}" ${Function} int

	/if (!${Select[${Me.Class.ShortName},MNK,WAR,BER,ROG]}) {
		/if (!${Defined[ReportFM]})   /declare ReportFM bool outer
		/call LoadVar DoBuffStuff BuffGem "Buff Gem you would like to cast /buff requests from" BuffGem "${MyIni}" ${Function} string
		/call LoadVar Settings MedPct 80 MedPct "${MyIni}" ${Function} int
		/call LoadVar Settings UseRods FALSE UseRods "${MyIni}" ${Function} bool
		/call LoadVar Settings RodMana 80 RodMana "${MyIni}" ${Function} int
		/call LoadVar GeneralStuff ReportMana FALSE ReportMana "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff ReportManaPct 50 ReportManaPct "${MyIni}" ${Function} int
		/call LoadVar GeneralStuff SpellSetTotal 1 SpellSetTotal "${MyIni}" ${Function} int
		/if (${SpellSetTotal}) {
			/for i 1 to ${SpellSetTotal}
				/call LoadVar GeneralStuff SpellSet${i} "Put the name of the Spell Set you want to memorize when you die while using this spell set here" SpellSet${i} "${MyIni}" ${Function} string
			/next i
		}
		/call LoadVar NukeStuff NukeTotal 1 NukeTotal "${MyIni}" ${Function} int
		/if (${NukeTotal}) {
			/if (!${Defined[NukeID]})     /declare NukeID[${NukeTotal}] int   outer
			/if (!${Defined[NukeLowest]}) /declare NukeLowest           int   outer 100
			/if (!${Defined[NukeTimer]})  /declare NukeTimer            timer outer
			/call LoadVar NukeStuff DoNukes FALSE DoNukes "${MyIni}" ${Function} bool
			/call LoadVar NukeStuff NukeDelay 0 NukeDelay "${MyIni}" ${Function} string
			/call LoadVar NukeStuff WhichNuke 1 WhichNuke "${MyIni}" ${Function} int
			/if (${Me.Class.ShortName.Equal[WIZ]}) {
				/call LoadVar NukeStuff DoMancy TRUE DoMancy "${MyIni}" ${Function} bool
				}
			/for i 1 to ${NukeTotal}
				/call LoadVar NukeStuff Nuke${i} "Put the name of nuke #${i} here" Nuke${i} "${MyIni}" ${Function} string
				/call LoadVar NukeStuff NukeGem${i} "Put the spell gem you want to cast nuke #${i} from here" NukeGem${i} "${MyIni}" ${Function} string
				/call LoadVar NukeStuff NukeSpellSet${i} 1 NukeSpellSet${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeStartHPs${i} 90 NukeStartHPs${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeStopHPs${i} 40 NukeStopHPs${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeMaxMana${i} 100 NukeMaxMana${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeMinMana${i} 30 NukeMinMana${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff GoMNuke${i} FALSE GoMNuke${i} "${MyIni}" ${Function} bool
				/call LoadVar NukeStuff NukeCondition${i} TRUE NukeCondition${i} "${MyIni}" ${Function} string
				/if (${NukeGem${i}.Equal[alt]} && ${Me.AltAbility[${Nuke${i}}].Spell.ID}) /varset NukeID[${i}] ${Me.AltAbility[${Nuke${i}}].Spell.ID}
				/if (${NukeGem${i}.Equal[ITEM]} && ${FindItem[${Nuke${i}}].ID}) /varset NukeID[${i}] ${FindItem[${Nuke${i}}].Spell.ID}
				/if (${NukeGem${i}.NotEqual[alt]} && ${NukeGem${i}.NotEqual[item]} && ${Spell[${Nuke${i}}].RankName.ID}) /varset Nuke${i} ${Spell[${Nuke${i}}].RankName}
				/if (${NukeGem${i}.NotEqual[alt]} && ${NukeGem${i}.NotEqual[item]} && ${Spell[${Nuke${i}}].RankName.ID}) /varset NukeID[${i}] ${Spell[${Nuke${i}}].RankName.ID}
				/if (${NukeMinMana${i}}<${NukeLowest}) /varset NukeLowest ${NukeMinMana${i}}
			/next i
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/call LoadVar SummonStuff RodSpell "Put the Name of the spell or item you use to cast mod rods here" RodSpell "${MyIni}" ${Function} string
		/call LoadVar SummonStuff RodGem "Put the spell gem number or put item if its an item you want to cast mod rods from here" RodGem "${MyIni}" ${Function} string
		/call LoadVar SummonStuff DoPetToys FALSE DoPetToys "${MyIni}" ${Function} bool
		/call LoadVar SummonStuff ReportPetToys FALSE ReportPetToys "${MyIni}" ${Function} bool
		/call LoadVar SummonStuff PetToysChannel echo PetToysChannel "${MyIni}" ${Function} string
		/call LoadVar SummonStuff PetToysTotal 1 PetToysTotal "${MyIni}" ${Function} int
|		/call LoadVar SummonStuff PetToysAdvice Place only pet weapons in Pet Toys 1, rest will be skipped for Mage's own pet."${MyIni}" ${Function} string
		/if (${PetToysTotal}) {
			/for i 1 to ${PetToysTotal}
			/call LoadVar SummonStuff PetToys${i} "PetToys Summon spell here|With Individual items here (omit for give all)" PetToys${i} "${MyIni}" ${Function} string
			/next i
			/call LoadVar SummonStuff PetToysGave "PetToysGiven" PetToysGave "${MyIni} ${Function} string
			}
		/if (!${Defined[PetToysGave]}) /declare PetToysGave string outer PetToysGiven
		}
	/if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,BST]}) {
		/call LoadVar HealStuff DoSotW FALSE DoSotW "${MyIni}" ${Function} bool
		/call LoadVar HealStuff ReportSotW FALSE ReportSotW "${MyIni}" ${Function} bool
		/call LoadVar HealStuff SotWAA "Put the name of your AE Healing AA here" SotWAA "${MyIni}" ${Function} string
		/call LoadVar HealStuff SotWPct 75 SotWPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff QM FALSE QM "${MyIni}" ${Function} bool
		}
	/if (${Select[${Me.Class.ShortName},WIZ,SHM,NEC,MAG,ENC,CLR,BST]}) {
		/call LoadVar GeneralStuff CanniTotal 1 CanniTotal "${MyIni}" ${Function} int
		/if (${CanniTotal}<1) /varset CanniTotal 1
		/if (${CanniTotal}) {
			/call LoadVar GeneralStuff DoCanni FALSE DoCanni "${MyIni}" ${Function} bool
			/for i 1 to ${CanniTotal}
				/call LoadVar GeneralStuff CanniSpell${i} "Put the name of your Cannibalization Spell or Item here" CanniSpell${i} "${MyIni}" ${Function} string
				/call LoadVar GeneralStuff CanniGem${i} "Put the Gem you want to cast your Cannibalization Spell from here, or put item if its an item, or alt if it's an AA" CanniGem${i} "${MyIni}" ${Function} string
				/call LoadVar GeneralStuff CanniHPs${i} 0 CanniHPs${i} "${MyIni}" ${Function} int
				/call LoadVar GeneralStuff CanniMana${i} 70 CanniMana${i} "${MyIni}" ${Function} int
			/next i
			/call LoadVar GeneralStuff DoCanniHeal "Heal after using Canni?" CanniHeal "${MyIni}" ${Function} bool
			/call LoadVar GeneralStuff CanniHealSpell "Put the name of your Cannibalization Heal Spell or Item here" CanniHealSpell "${MyIni}" ${Function} string
			/call LoadVar GeneralStuff CanniHealGem "Put the Spell Gem you want to cast your Cannibalization Heal Spell from here, or put item if its an item, or alt if it's an AA" CanniHealGem "${MyIni}" ${Function} string
			/call LoadVar GeneralStuff CanniHealHPs 60 CanniHealHPs "${MyIni}" ${Function} int
			}
		}
	/if (${Me.Class.ShortName.Equal[DRU]}) {
		/call LoadVar GeneralStuff DoWoW FALSE DoWoW "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff ReportWoW FALSE ReportWoW "${MyIni}" ${Function} bool
		}
	/if (${Select[${Me.Class.ShortName},CLR,PAL]}) {
		/call LoadVar GeneralStuff DoYaulp FALSE DoYaulp "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff YaulpSpell "Put the name of your Yaulp Spell here" YaulpSpell "${MyIni}" ${Function} string
		/call LoadVar GeneralStuff YaulpGem "Put the Spell Gem you want to cast your Yaulp Spell from here" YaulpGem "${MyIni}" ${Function} string
		}
	/if (${Select[${Me.Class.ShortName},CLR,SHM]}) {
		/call LoadVar HealStuff UseDivArb FALSE UseDivArb "${MyIni}" ${Function} bool
		/call LoadVar HealStuff DivArbHPs 20 DivArbHPs "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseTankHoT FALSE UseTankHoT "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HotSpell "Put the name of your Heal over Time Spell here" HotSpell "${MyIni}" ${Function} string
		/call LoadVar HealStuff HotSpellGem "Put the Spell Gem you want to cast your Heal over Time Spell from here" HotSpellGem "${MyIni}" ${Function} string
		/varset HotSpell ${Spell[${HotSpell}].RankName}
		/if (!${Defined[HotSpellID]})  /declare HotSpellID int outer ${Spell[${HotSpell}].RankName.ID}
		/if (!${Defined[HotGem]}) /declare HotGem string outer ${HotSpellGem}
		}
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/call LoadVar HealStuff DoRetort 		FALSE 							DoRetort 		"${MyIni}" ${Function} bool
		/call LoadVar HealStuff RetortSpell 	"Retort Spell here" 			RetortSpell 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff RetortSpellGem 	"Spell Gem for Retort Spell" 	RetortSpellGem 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbSpell 	"Divine Arbitration" 			DivArbSpell 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbGem 		alt 							DivArbGem 		"${MyIni}" ${Function} string
		/call LoadVar HealStuff DoWard 			FALSE 							DoWard 			"${MyIni}" ${Function} bool		
		/call LoadVar HealStuff WardSpell 		"Ward Spell here" 				WardSpell 		"${MyIni}" ${Function} string
		/call LoadVar HealStuff WardSpellGem 	"Spell Gem for Ward Spell" 		WardSpellGem 	"${MyIni}" ${Function} string
		/varset DivArbSpellID ${Me.Book[${Me.Book[${Spell[${DivArbSpell}].RankName}]}].ID}
		}
	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/call LoadVar HealStuff DivArbSpell "Put the name of your divine arbitration spell or item" DivArbSpell "${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbGem "Put the Spell Gem you want to cast your Pet Spell from here" DivArbGem "${MyIni}" ${Function} string
		/varset DivArbTimer timer  outer
		/varset DivArbSpellID int outer ${Me.Book[${Me.Book[${Spell[${DivArbSpell}].RankName}]}].ID}
		}
	/if (${Me.Class.ShortName.Equal[CLR]}) /call LoadVar HealStuff UseBDA FALSE UseBDA "${MyIni}" ${Function} bool
	/if (${Me.Class.ShortName.Equal[ENC]}) /call LoadVar Settings GatherPct 10 GatherPct "${MyIni}" ${Function} int
|--- Search Debuff for SpellType 2 (Mez) or 4 (AEMez) spells
	/if (${Select[${Me.Class.ShortName},ENC,BRD]}) {
		/if (${DoMez}) {
			/if (${Me.Class.ShortName.Equal[ENC]}) {
				/declare MezSpellID 		int outer 0
				/declare MezSpellDebuffID 	int outer 0
				}
			/if (${Me.Class.ShortName.Equal[BRD]}) {
				/declare MezSongID 			int outer 0
				/declare MezSongDebuffID 	int outer 0
				}
			/declare LookForMezSpell 	int local 1
			/for LookForMezSpell 1 to ${DebuffTotal}
				/if (${SpellType${LookForMezSpell}}!=2) /continue
				/if (${SpellType${LookForMezSpell}}==2) {
					/if (${Me.Class.ShortName.Equal[ENC]}) {
						/varset MezSpellID ${DebuffID[${LookForMezSpell}]}
						/varset MezSpellDebuffID ${LookForMezSpell}
						}				
					/if (${Me.Class.ShortName.Equal[BRD]}) {
						/varset MezSongID ${DebuffID[${LookForMezSpell}]}
						/varset MezSongDebuffID ${LookForMezSpell}
						}
					/break
					}
			/next LookForMezSpell
			}
		/if (${DoAEMez}) {
			/if (${Me.Class.ShortName.Equal[ENC]}) {
				/declare AEMezSongID 		int outer 0 
				/declare AEMezSongDebuffID 	int 0
				}
			/if (${Me.Class.ShortName.Equal[BRD]}) {
			/declare AEMezSpellID 			int outer 0
			/declare AEMezSpellDebuffID 	int outer 0
				}
			/declare LookForAEMezSpell 		int local 1
			/for LookForAEMezSpell 1 to ${DebuffTotal}
				/if (${SpellType${LookForAEMezSpell}}!=4) /continue
				/if (${SpellType${LookForAEMezSpell}}==4) {
					/if (${Me.Class.ShortName.Equal[ENC]}) {
						/varset AEMezSpellID ${DebuffID[${LookForAEMezSpell}]}
						/varset AEMezSpellDebuffID ${LookForAEMezSpell}
						}
					/if (${Me.Class.ShortName.Equal[ENC]}) {
						/varset AEMezSongID ${DebuffID[${LookForAEMezSpell}]}
						/varset AEMezSongDebuffID ${LookForAEMezSpell}
						}
					/break
					}
			/next LookForAEMezSpell 
			}
		}
|--- Search Debuff for SpellType 5 (Charm) spells
	/if (${Select[${Me.Class.ShortName},ENC,BRD]}) {
		/if (${DoCharm}) {
			/if (${Me.Class.ShortName.Equal[ENC]}) {
				/declare CharmSpellID 		int outer 0
				/declare CharmSpellDebuffID int outer 0
				}
			/if (${Me.Class.ShortName.Equal[BRD]}) {
				/declare CharmSongID 		int outer 0
				/declare CharmSongDeuffID 	int outer 0
				}
			/declare LookForCharmSpell 		int local 1
			/for LookForCharmSpell 1 to ${DebuffTotal}
				/if (${SpellType${LookForCharmSpell}}!=5) /continue
				/if (${SpellType${LookForCharmSpell}}==5) {
					/if (${Me.Class.ShortName.Equal[ENC]}) {
						/declare CharmSpellID ${DebuffID[${LookForCharmSpell}]}
						/declare CharmSpellDebuffID ${LookForCharmSpell}
						}				
					/if (${Me.Class.ShortName.Equal[BRD]}) {
						/declare CharmSongID ${DebuffID[${LookForCharmSpell}]}
						/declare CharmSongDeuffID ${LookForCharmSpell}
						}
					/break
					}
			/next LookForCharmSpell
			}
		}		
	/if (${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]}) {
		/call LoadVar PetStuff UsePet FALSE UsePet "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetAttack FALSE PetAttack "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetMana 0 PetMana "${MyIni}" ${Function} int
		/call LoadVar PetStuff KillFlappy FALSE KillFlappy "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetFocus "Put the name of your pet focus buff item here" PetFocus "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetSpell "Put the name of your pet Spell here" PetSpell "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetGem "Put the Spell Gem you want to cast your Pet Spell from here" PetGem "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetShrink FALSE PetShrink "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetShrinkSpell "Put the name of your pet shrinking AA/Item/Spell here" PetShrinkSpell "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetShrinkGem "Put gem# for spells, item for items, and alt for AAs" PetShrinkGem "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetBuffTotal 1 PetBuffTotal "${MyIni}" ${Function} int
		/if (!${Defined[PetBuffTotal]}) /declare PetBuffTotal ${Ini[RD1_${Me.CleanName},PetStuff,PetBuffTotal]}
		/if (${Me.Class.ShortName.Equal[MAG]}) {
			/call LoadVar PetStuff SelfPetHealing FALSE SelfPetHealing "${MyIni}" ${Function} bool
			/call LoadVar PetStuff SelfPetHealPct 50 SelfPetHealPct "${MyIni}" ${Function} int
			/call LoadVar PetStuff SelfPetHeal "pet heal spell here" SelfPetHeal "${MyIni}" ${Function} string
			/call LoadVar PetStuff SelfPetHealGem "pet heal spell gem here" SelfPetHealGem "${MyIni}" ${Function} string
			}
		/if (${Me.Class.ShortName.Equal[MAG]}) {
			/call LoadVar PetStuff PetDelayedHealing FALSE PetDelayedHealing "${MyIni}" ${Function} bool
			/call LoadVar PetStuff PetDelayedHealPct 50 PetDelayedHealPct "${MyIni}" ${Function} int
			/call LoadVar PetStuff PetDelayedHeal "pet delayed heal spell here" PetDelayedHeal "${MyIni}" ${Function} string
			/call LoadVar PetStuff PetDelayedHealGem "pet delayed heal gem here" PetDelayedHealGem "${MyIni}" ${Function} string
			}
		/if (${PetBuffTotal}) {
			/if (!${Defined[PetBuffID]})      /declare PetBuffID[${PetBuffTotal}]      int    outer
			/if (!${Defined[PetBuffTimer]})   /declare PetBuffTimer                    timer  outer
			/call LoadVar PetStuff DoPetBuffs FALSE DoPetBuffs "${MyIni}" ${Function} bool
			/call LoadVar PetStuff ReportPetBuffs FALSE ReportPetBuffs ${MyIni} ${Function} bool
			/call LoadVar PetStuff PetBuffRecheck 10s PetBuffRecheck ${MyIni} ${Function} string
			/for i 1 to ${PetBuffTotal}
				/call LoadVar PetStuff PetBuff${i} "pet Buff Item/Spell #${i}" PetBuff${i} ${MyIni} ${Function} string
				/call LoadVar PetStuff PetBuffGem${i} "pet Buff #${i} Gem or put Item if an item" PetBuffGem${i} ${MyIni} ${Function} string
				/call LoadVar PetStuff PetBuffIcon${i} "pet Buff Icon as shown in the pet buff window" PetBuffIcon${i} ${MyIni} ${Function} string
				/if (${PetBuffGem${i}.Equal[alt]} && ${Me.AltAbility[${PetBuff${i}}].Spell.ID}) /varset PetBuffID[${i}] ${Me.AltAbility[${PetBuff${i}}].Spell.ID}
				/if (${PetBuffGem${i}.Equal[iteCm]} && ${FindItem[${PetBuff${i}}].ID}) /varset PetBuffID[${i}] ${FindItem[${PetBuff${i}}].ID}
				/if (${PetBuffGem${i}.NotEqual[item]} && ${PetBuffGem${i}.NotEqual[alt]} && ${Spell[${PetBuff${i}}].RankName.ID}) {
					/varset PetBuff${i} ${Spell[${PetBuff${i}}].RankName}
					/varset PetBuffID[${i}] ${Spell[${PetBuff${i}}].RankName.ID}
					}
|				/if (${Ini[${RDIni},PetStuff,PetBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset PetBuffID[${i}] ${Spell[${Ini[${RDIni},PetStuff,PetBuffIcon${i},NOTFOUND]}].ID}
			/next i
			}			
		}	
	/if (${Select[${Me.Class.ShortName},WIZ,ENC]}) {
		/call LoadVar NukeStuff DoConcussion FALSE DoConcussion ${MyIni} ${Function} bool
		/call LoadVar NukeStuff ConcussionSpell "Concussion Item/Spell" ConcussionSpell ${MyIni} ${Function} string
		/call LoadVar NukeStuff ConcussionGem "Concussion gem# or put item if an item" ConcussionGem ${MyIni} ${Function} string
		}
	/call LoadVar HolyShit TotalShit 1 TotalShit "${MyIni}" ${Function} int
	/if (${TotalShit}) {
		/call LoadVar HolyShit DoHolyShit FALSE DoHolyShit "${MyIni}" ${Function} bool
		/for i 1 to ${TotalShit}
			/call LoadVar HolyShit HolyShit${i} "Name of Item/AA/Spell to cast." HolyShit${i} "${MyIni}" ${Function} string
			/call LoadVar HolyShit HolyShitGem${i} "HolyShit Gem# or aa" HolyShitGem${i} "${MyIni}" ${Function} string
			/call LoadVar HolyShit HolyShitHp${i} 90 HolyShitHp${i} "${MyIni}" ${Function} int
			/call LoadVar HolyShit HolyShitType${i} 0 HolyShitType${i} "${MyIni}" ${Function} int
			/call LoadVar HolyShit HolyShitRUN${i} FALSE HolyShitRUN${i} "${MyIni}" ${Function} bool
		/next i
	}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/call LoadVar Bard DoRally FALSE DoRally "${MyIni}" ${Function} bool		
		/call LoadVar Bard DoDichotomic FALSE DoDichotomic "${MyIni}" ${Function} bool
		/call LoadVar Bard AutoRestOff FALSE AutoRestOff "${MyIni}" ${Function} bool
		/call LoadVar Bard AutoRestRadius 125 AutoRestRadius "${MyIni}" ${Function} int
		/call LoadVar Bard CombatTwist CombatGems CombatTwist "${MyIni}" ${Function} string outer 
		/call LoadVar Bard RestTwist RestGems RestTwist "${MyIni}" ${Function} string outer
	}
	/if (${Me.Class.ShortName.Equal[WAR]}) {
		/if (!${Defined[ShieldTimer]}) /declare ShieldTimer timer outer
		/call LoadVar MeleeStuff DoShield FALSE DoShield ${MyIni} ${Function} bool
		/call LoadVar MeleeStuff ShieldRange 25 ShieldRange ${MyIni} ${Function} int
		/call LoadVar MeleeStuff ShieldHPs 50 ShieldHPs ${MyIni} ${Function} int
		/call LoadVar MeleeStuff ShieldClasses |CLR|DRU|SHM|ENC| ShieldClasses ${MyIni} ${Function} string
	}
	/return