|AUTOBOT XP AND RAIDING MACRO v4.29.02
| Last Update 02-13-2026
|
| Full instruction on the MacroQuest2 wiki
| http://www.macroquest2.com/wiki/index.php/AutoBot.mac-V4.28%2B
|
|
| Necrognomie flavored
|
|	Switched to MQ2Cast_Spell_Routines.inc. Will require the plugin to work.
|	Commmented out the trade option for now...
|
|
|
|	REQUIREMENTS:
|		MQ2Cast
|		MQ2Nav (optional, used with Guard function)
|		MQ2Debuffs (optional, used to self cure)
|		MQ2Melee 
|		MQ2MoveUtils
|		AAPurchase.inc
|		Defense.inc
|		MQ2Cast_Spell_Routines.inc
|		Ninjadvloot.inc
|		QuickBeg.inc
|		Wait4Rez.inc

#warning
#include AAPurchase.inc
#include Ninjadvloot.inc
#include MQ2Cast_Spell_Routines.inc
#include wait4rez.inc
#include QuickBeg.inc
#include Defense.inc
#turbo 120
#CHAT BC
#CHAT CHAT
#CHAT RAIDSAY

#Event AddCombatSong  	"[MQ2] AddCombatSong #1#"
#Event AddAlert       	"[MQ2] AddAlert #1#"
#Event AddAlertCommon 	"[MQ2] AddAlertCommon #1#"
#Event AddRestSong    	"[MQ2] AddRestSong #1#"
#Event ShowDebuffs    	"[MQ2] ShowDebuffs #1#"
#Event Campout			"It will take about 25 more seconds to prepare your camp."
#Event CanNotSee		"You cannot see your target."
#Event ChangeTank		"change tank #1#"
#Event CombatGem		"[MQ2] CombatGem #1#"
#Event Dead           	"#*#You have been slain by#*#"
#Event DelCombatSong  	"[MQ2] DelCombatSong #1#"
#Event DelRestSong    	"[MQ2] DelRestSong #1#"
#Event Experience     	"#*#You gain party experience#*#"
#Event Faded	      	"#*#You escape from combat, hiding yourself from view."
#Event ImHit          	"#*#YOU for#*#points of damage."
#Event ImHit    	  	"#1#to#*#YOU, but #*#"
#Event Invite         	"#1# invites you to join a group."
#Event IRC            	"<#1#> #2#"
#Event IRC            	"[#1#(msg)] #2#"
#Event IRCNoChan      	"#*#You are not on any channels.#*#"
#Event IRCNoChan      	"#*#You are not connected. Please use /iconnect to establish a connection.#*#"
#Event ListSongs      	"[MQ2] ListSongs #1#"
#Event ListSpells     	"[MQ2] ListSpells#1#"
#Event LoadAlert      	"[MQ2] LoadAlert#1#"
#Event LoadIni        	"[MQ2] LoadIni #1#"
#Event MakeStuff      	"You are low on #1# and #2#."
#Event MakeStuff      	"You are out of #1# and #2#."
#Event MakeStuff      	"You are out of #1# and low on #2#."
#Event MakeStuff      	"You are low on #1#."
#Event MakeStuff      	"You are out of #1#."
#Event MezIt          	"#1# begins to cast a spell. <Complete Heal>"
#Event MezIt          	"#1# begins to cast the gate spell."
#Event NeedStuff      	"You are #1#."
#Event NewZone        	"You have entered#*#"
#Event NoLuclin       	"You must have both the Horse Models and your current Luclin Character Model enabled#*#"
#Event NoLuclin       	"You can not summon a mount in this form#*#"
#Event RaidExperience 	"#*#You gained raid experience#*#"
#Event lootall        	"#*#lootall#*#"
#Event Rampage        	"#*#goes on a RAMPAGE#*#"
#Event RemoveAura		"You do not have sufficient focus to maintain that ability."
#Event RestGem			"[MQ2] RestGem #1#"
#Event Restricted     	"This spell does not work here#*#"
#Event Restricted     	"You are missing some required comp#*#"
#Event Restricted     	"You can only cast this spell in the outdoors#*#"
#Event Restricted     	"You need to be in a more open area to summon a mount#*#"
#Event Restricted     	"A voice whispers in your mind, 'There are no heroes here#*#"
#Event NoMount        	"You can not summon a mount here#*#"
#Event Recovered		"You haven't recovered yet..."
#Event SaveIni        	"[MQ2] SaveIni#1#"
#Event SetBuff        	"[MQ2] SetBuff#1#"
#Event SetMA1         	"[MQ2] SetMA1#1#"
#Event SetMA2         	"[MQ2] SetMA2#1#"
#Event SetMA3         	"[MQ2] SetMA3#1#"
#Event SetRampTank    	"[MQ2] SetRampTank#1#"
#Event SongAlias      	"[MQ2] SongAlias #1# #2#"
#Event Stand          	"You must be standing to attack!"
#Event Stand	      	"Auto attack is off."
#Event Stand	      	"You must be standing to cast a spell."
#Event ToggleString   	"[MQ2] ToggleString #1#,#2#,#3#,#4#,#5#"
#Event ToggleVar      	"[MQ2] ToggleVar #1#,#2#,#3#,#4#,#5#"
#Event ToggleAABuy    	"[MQ2] ToggleAABuy"
#Event TooClose			"Your target is too close to use a ranged weapon!!"
#Event TooFar         	"Your target is too far away, get closer!"
#Event TooFar         	"You are too far away from your target"
#Event WornOff        	"#*#Your #1# spell has worn off of #2#."
#Event MezBroke      	"#1# has been awakened by #2#."

Sub Main
	/if (${MacroQuest.GameState.NotEqual[INGAME]}) /endmacro
	/if (!${Defined[PuppetMaster]}) /declare PuppetMaster string outer ${Me.CleanName}
	/echo I come Optimus...
	/declare AEHeal 			bool 	outer FALSE
	/declare AlertTimer   	    timer  	outer
	/declare AssistTimer     	timer  	outer	
	/declare AssistHeal 		bool 	outer FALSE
	/declare BagNum				int		outer
	/declare BardDebug			int		outer 0
	/declare BattleBuffFlag 	bool 	outer FALSE	
	/declare BegIfMeInvis       bool    outer FALSE
	/declare CampX				int		outer 0
	/declare CampY				int		outer 0
	/declare CampZ				int		outer 0	
	/declare castReturn     	string 	outer	
	/declare CheckGroupTimer 	timer  	outer
	/declare CombatStuffTimer   timer   outer
	/declare CombatTwist 		string outer
	/declare DebuffLowest       int     outer 0
	/declare Debug				int		outer 0
	/declare BardSwap 			bool	outer FALSE
	/declare DoBardMeleeSwap	bool	outer FALSE
	/declare DoBardSwap			bool	outer FALSE
 	/declare DoBuffLowest 		int 	outer 10
	/declare DoBuffs 			bool 	outer FALSE
    /declare DoBuffTimer        timer   outer 0
	/declare DoBuffTotal        int     outer
    /declare DoBuffQueue[25,2]  int     outer
	/declare DoCanni 			bool 	outer FALSE
	/declare DoCharm 			bool 	outer FALSE
 	/declare DoCombatStuff 		bool 	outer FALSE
 	/declare DoConcussion 		bool 	outer FALSE
	/declare DoCures 			bool 	outer FALSE
	/declare DoDebuffs 			bool 	outer FALSE
	/declare DoDelayedTimer     timer   outer
	/declare DoDoTs             bool    outer FALSE
	/declare DoHolyShit         bool    outer FALSE
	/declare DoManaTaps 		bool 	outer FALSE
	/declare DoMez				bool	outer FALSE
 	/declare DoNamedStuff 		bool 	outer FALSE
	/declare DoNukes            bool    outer FALSE
	/declare DoRamp				bool	outer FALSE
	/declare DoRetort	 		bool 	outer FALSE
	/declare DoRestStuff 		bool 	outer FALSE
	/declare DoSotWFunction 	string 	outer DoSotW
	/declare DoWoW 				bool 	outer FALSE
	/declare EvaluateFunction 	string 	outer EvaluateGroup
	/declare FollowFlag       	bool   	outer FALSE
	/declare FollowGuy       	int    	outer
    /declare Gems[${Me.NumGems}]	int    	outer
	/declare GMCheck            bool    outer TRUE
	/declare GMob 				string 	outer 999999
	/declare GroupHealing 		bool 	outer FALSE
  	/declare GroupHurtCount		int 	outer 0
	/declare GuardPause 		timer 	outer 0	
	/declare HealDebug			int		outer 0
	/declare HealGroup 			bool 	outer FALSE
	/declare HealPets 			bool 	outer FALSE
	/declare HealXTarget 		bool 	outer FALSE
	/declare IRCConnect      	timer  	outer
	/declare LastCast       	string 	outer
 	/declare LastSpawnCount 	int 	outer 0
    /declare MainTankID         int     outer
	/declare MATarget        	int    	outer 999999
	/declare MaxGems     		int		outer ${Me.NumGems}
	/declare MercStanceTimer	timer	outer 0
    /declare MezSong     		string outer
	/declare noFeigning 		bool	outer TRUE
	/declare noInterrupt 		int 	outer 1
	/declare noInvis         	int    	outer 1
	/declare NPCRadChk       	int    	outer 0
	/declare NukeLowest         int     outer 100	
	/declare NukeTimer          timer   outer 
	/declare Parse          	string 	outer
	/declare PauseFlag 			bool 	outer FALSE
	/declare PauseTimer			timer	outer 0
	/declare PetAttack 			bool 	outer FALSE
	/declare PetBuffTimer 		timer 	outer 0
	/declare PetID		  		int    	outer
	/declare PetMana 			int 	outer 0
	/declare PetToys[4]    		string 	outer
	/declare PetToysDone    	int    	outer       0
    /declare QueueCount         int     outer 0
	/declare RecoveredTimer		timer	outer 0
	/declare RefreshBuffs       bool    outer TRUE
	/declare ReportMana         bool    outer FALSE
	/declare ReportManaPct      int     outer
 	/declare RestStuffTimer 	timer 	outer 0
  	/declare RestTwist   		string outer
	/declare RDIni		 		string 	outer RD1_${Me.CleanName}.ini
	/declare RDPause         	bool   	outer FALSE
	/declare RDVersion      	string 	outer 4.28.05
	/declare SelfBuffs 			bool 	outer FALSE	
	/declare SelfBuffTimer		timer 	outer 0
	/declare ShieldTimer        timer   outer
	/declare SitTimer        	timer  	outer
	/declare SpamFlag        	bool   	outer
	/declare SpamTimer			timer	outer 0
	/declare StayOnHealTimer 	timer  	outer
	/declare TravelMode      	bool   	outer
	/declare TwistTimer			timer	outer 0
 	/declare UniqueSongs 		int	    outer
	/declare UseBDA				bool	outer FALSE
	/declare UseDiscs 			bool 	outer FALSE
	/declare UseCH 				bool 	outer FALSE
	/declare UsePet 			bool 	outer FALSE
	/declare UseRods            bool    outer FALSE
	/declare UseTankHoT         bool    outer FALSE
	/declare WorstHPs 			int		outer 100
    /declare WorstID       		int    	outer 0
	/declare YaulpSpell 		string 	outer Yaulp
	/declare ZoneName       	string 	outer
	/if (${Bool[${Plugin[MQ2Netheal]}]}) {
		/varset EvaluateFunction EvaluateGroupNet
		/varset DoSotwFunction DoSotWNet
		}
	/if (!${Bool[${Plugin[MQ2Melee]}]}) /multiline ; /echo \ar MQ2Melee required for this macro!! ;/end
	/if (!${Bool[${Plugin[MQ2MoveUtils]}]}) /multiline ; /echo \ar MQ2MoveUtils required for this macro!! ;/end
	/if (!${Bool[${Plugin[MQ2AutoLogin]}]}) /echo \ay MQ2AutoLogin recommended for this macro if you want to change to trader.

	
	/if (${RDVersion.NotEqual[${Ini[RDCommon.ini,Settings,Version]}]}) {
		/if (${Bool[${Plugin[MQ2CEcho]}]}) /echo \ar Version Mismatch Detected, Loading Aliases
		/squelch /alias /aabuy		      /echo ToggleAABuy
		/squelch /alias /addalert         /echo AddAlert
		/squelch /alias /addcombatsong    /echo AddCombatSong
		/squelch /alias /addrestsong      /echo AddRestSong
		/squelch /alias /aeheal           /echo ToggleVar AE Healing,AEHeal,HealStuff,AEHealing,	
		/squelch /alias /assistdelay      /echo ToggleString Assist Delay,AssistDelay,GeneralStuff,AssistDelay,
		/squelch /alias /assistheal       /echo ToggleVar Assist Healing,AssistHeal,HealStuff,AssistHealing,
		/squelch /alias /assistma         /echo ToggleVar Auto Assisting the MA,AssistMA,GeneralStuff,AssistMA,
		/squelch /alias /autoloot         /echo ToggleVar Auto Looting,AutoNinja,Settings,AutoNinja,
		/squelch /alias /autoninja        /echo ToggleVar Ninja Looting,AutoNinja,Settings,AutoNinja,
		/squelch /alias /autorestoff      /echo ToggleVar Auto Rest Twist Disabling,AutoRestOff,Bard,AutoRestOff,
		/squelch /alias /autorestradius   /echo ToggleString Auto Rest Twist Off Radius,AutoRestRadius,Bard,AutoRestRadius,
		/squelch /alias /autosit          /echo ToggleVar Auto Sitting,AutoSit,Settings,AutoSit,
		/squelch /alias /buff             /echo SetBuff
		/squelch /alias /cancelpct        /echo ToggleString Cancel Percent,CancelPct,HealStuff,CancelPct,
		/squelch /alias /charm            /echo ToggleVar Auto Charm,DoCharm,DebuffStuff,DoCharm,
		/squelch /alias /changetank 	  /echo ToggleVar Change MA1 on call or death,ChangeTank,GeneralStuff,ChangeTank,
		/squelch /alias /chatchannel      /echo ToggleString Chat Channel,ChatChannel,GeneralStuff,ChatChannel,
		/squelch /alias /checkgroup       /echo ToggleString check Group Interval,CheckGroupInterval,HealStuff,CheckGroupInterval,
		/squelch /alias /combatgem 		  /echo CombatGem
		/squelch /alias /debuff           /echo ToggleVar Auto Debuffing,DoDebuffs,DebuffStuff,DoDebuffs,
		/squelch /alias /debuffchannel    /echo ToggleString Report Channel,DebuffChannel,DebuffStuff,DebuffChannel,
		/squelch /alias /delayedhealpct   /echo ToggleString Main Assist Delayed Heal Percent Hitpoints,DelayedHealPct,HealStuff,DelayedHealPct,
		/squelch /alias /delcombatsong    /echo DelCombatSong
		/squelch /alias /delrestsong      /echo DelRestSong
		/squelch /alias /divarbhps        /echo ToggleString Divine Arbitration Hitpoints,DivArbHPs,HealStuff,DivArbHPs,
		/squelch /alias /dodefense        /echo ToggleVar Auto Engaging Defensive Abilities,DoDefense,MeleeStuff,DoDefense,
		/squelch /alias /dobuffs          /echo ToggleVar Auto Buffing,DoBuffs,DoBuffStuff,DoBuffs,
		/squelch /alias /dobufftells      /echo ToggleVar Buffing Tells,DoBuffTells,DoBuffStuff,DoBuffTells,
		/squelch /alias /docanni          /echo ToggleVar Auto Cannibalization/Harvest,DoCanni,GeneralStuff,DoCanni,
		/squelch /alias /docombat         /echo ToggleVar Combat Scripts,DoCombatStuff,CombatStuff,DoCombatStuff,
		/squelch /alias /docures          /echo ToggleVar Auto Curing,DoCures,CureStuff,DoCures,
		/squelch /alias /dointerrupting	  /echo ToggleVar Interrupting to heal others,Stop4Pad,HealStuff,AutoInterrupt,
		/squelch /alias /domancy		  /echo ToggleVar Toggle auto activating of Pryomancy Acromany Cryomancy,DoMancy,NukeStuff,DoMancy
		/squelch /alias /domercstance     /echo ToggleVar Auto change mercenary stance,DoMercStance,MeleeStuff,DoMercStance,
		/squelch /alias /domercassist     /echo ToggleVar Auto engage macro control of merc assist,DoMercAssist,MeleeStuff,DoMercAssist,
		/squelch /alias /mercengagehps    /echo ToggleString Auto change mercenary stance,MercEngageHPs,MeleeStuff,MercEngageHPs
		/squelch /alias /domelee          /echo ToggleVar Auto Melee,DoMelee,MeleeStuff,DoMelee,
		/squelch /alias /donamed          /echo ToggleVar Named Scripts,DoNamedStuff,NamedStuff,DoNamedStuff,
		/squelch /alias /dopettoys	 	  /echo ToggleVar Auto Summoning pettoys,DoPetToys,SummonStuff,DoPetToys,
		/squelch /alias /doports          /echo ToggleVar Auto Ports,DoPorts,GeneralStuff,DoPorts,
		/squelch /alias /doranged         /echo ToggleVar Auto engage Range attacks,DoRanged,MeleeStuff,DoRanged,		
		/squelch /alias /dorest           /echo ToggleVar Rest Scripts,DoRestStuff,RestStuff,DoRestStuff,
		/squelch /alias /doretort         /echo ToggleVar Using Retort on MA1,DoRetort,HealStuff,DoRetort,
		/squelch /alias /doshrink	  	  /echo ToggleVar DoShrink,DoShrink,Settings,DoShrink,
		/squelch /alias /dot              /echo ToggleVar Auto DoTing,DoDoTs,DebuffStuff,DoDoTs,
		/squelch /alias /doward			  /echo ToggleVar Using Ward on MA1,DoWard,HealStuff,DoWard,		
		/squelch /alias /doyaulp          /echo ToggleVar Auto Yaulping in combat,DoYaulp,GeneralStuff,DoYaulp,	
		/squelch /alias /engagehps        /echo ToggleString Engage Hitpoints,EngageHPs,GeneralStuff,EngageHPs,
		/squelch /alias /guard      	  /echo ToggleVar Guard Melee,Guard,MeleeStuff,Guard,
		/squelch /alias /healchannel      /echo ToggleString Heal Channel,HealChannel,HealStuff,HealChannel,
		/squelch /alias /healfd           /echo ToggleVar Ignoring Non-FD FD classes,HealFD,HealStuff,HealFD,
		/squelch /alias /healgroup        /echo ToggleVar Group Healing,HealGroup,HealStuff,GroupHealing,
		/squelch /alias /healmefirst      /echo ToggleVar Healing Myself over anyone else,HealMeFirst,HealStuff,HealMeFirst,
		/squelch /alias /healpct          /echo ToggleString Heal Hitpoint Percent,HealPct,HealStuff,HealPct,
		/squelch /alias /healpets         /echo ToggleVar pet Healing,HealPets,HealStuff,PetHealing,
		/squelch /alias /healramp         /echo ToggleVar Rampage Healing,DoRamp,HealStuff,RampHealing,
		/squelch /alias /healxtarget      /echo ToggleVar Heal pet or PCs on Xtarget,HealXTarget,HealStuff,HealXTarget,
		/squelch /alias /ignorenpc        /echo AddAlert
		/squelch /alias /ignorenpccommon  /echo AddAlertCommon
		/squelch /alias /ignorerefresh    /echo LoadAlert	
		/squelch /alias /leashlength      /echo ToggleString Leash Length,LeashDistance,Settings,LeashLength,
		/squelch /alias /listsongs        /echo ListSongs
		/squelch /alias /listspells       /echo ListSpells
		/squelch /alias /loadini          /echo LoadIni
		/squelch /alias /ma1              /echo SetMA1
		/squelch /alias /ma2              /echo SetMA2
		/squelch /alias /ma3              /echo SetMA3
		/squelch /alias /medpct           /echo ToggleString Sit/Summon horse Mana Percent,MedPct,Settings,MedPct,
		/squelch /alias /mez              /echo ToggleVar Auto Mezzing,DoMez,DebuffStuff,DoMez,
		/squelch /alias /mezz             /echo ToggleVar Auto Mezzing,DoMez,DebuffStuff,DoMez,		
        /squelch /alias /moveupjitter     /echo ToggleString Jittering for move up,MoveUpJitter,Settings,MoveUpJitter,
		/squelch /alias /npcradchk 		  /echo ToggleString Radius to check for NPC's is now,NPCRadChk,NULL,NULL,
		/squelch /alias /npcradius        /echo ToggleString npc Checking radius,NPCRadius,Settings,NPCRadius,
		/squelch /alias /npczradius       /echo ToggleString npc Checking Z radius,NPCZRadius,Settings,NPCZRadius,
		/squelch /alias /nuke             /echo ToggleVar Auto Nuking,DoNukes,NukeStuff,DoNukes,
		/squelch /alias /nukedelay        /echo ToggleString Delay between Nukes,NukeDelay,NukeStuff,NukeDelay,
		/squelch /alias /nukeset          /echo ToggleString Nuke Spell set is now,WhichNuke,NukeStuff,WhichNuke,
		/squelch /alias /pcradius         /echo ToggleString pc Checking radius,PCRadius,Settings,PCRadius,
		/squelch /alias /pczradius        /echo ToggleString pc Checking Z radius,PCZRadius,Settings,PCZRadius,
		/squelch /alias /PetAttack		  /echo ToggleVar Pet attacking,PetAttack,PetStuff,PetAttack,
		/squelch /alias /petbuff          /echo ToggleVar pet Buffing,DoPetBuffs,PetStuff,DoPetBuffs,
		/squelch /alias /pethealpct       /echo ToggleString pet Healing Percent Hitpoints,PetHealPct,HealStuff,PetHealPct,
		/squelch /alias /pettoyschannel   /echo ToggleString PetToys Channel,PetToysChannel,SummonStuff,PetToysChannel,
		/squelch /alias /ramptank         /echo SetRampTank
		/squelch /alias /rangedist        /echo ToggleString Range attack limit,RangeDist,MeleeStuff,RangeDist,		
		/squelch /alias /rdpause          /echo ToggleVar AutoBot Pause,RDPause,NULL,NULL,
		/squelch /alias /refreshbuffs     /echo ToggleVar Auto Buff Refreshing,RefreshBuffs,DoBuffStuff,RefreshBuffs,
		/squelch /alias /relaytells       /echo ToggleVar Relaying Tells,RelayTells,GeneralStuff,RelayTells,
		/squelch /alias /reportcures      /echo ToggleVar Cure Reporting,ReportCures,CureStuff,ReportCures,
		/squelch /alias /reportdebuffs    /echo ToggleVar Debuff Reporting,ReportDebuffs,DebuffStuff,ReportDebuffs,
		/squelch /alias /reportdefense    /echo ToggleVar Defense Reporting,ReportDefense,MeleeStuff,ReportDefense,
		/squelch /alias /reportdobuffs    /echo ToggleVar Buff Reporting,ReportDoBuffs,DoBuffStuff,ReportDoBuffs,
		/squelch /alias /reportdots       /echo ToggleVar DoT Reporting,ReportDoTs,DebuffStuff,ReportDoTs,
		/squelch /alias /reportevents     /echo ToggleVar Event Reporting,ReportEvents,GeneralStuff,ReportEvents,
		/squelch /alias /reportheals      /echo ToggleVar Heal Reporting,ReportHeals,HealStuff,ReportHeals,
		/squelch /alias /reportinterrupts /echo ToggleVar Interrupt Reporting,ReportInterrupts,HealStuff,ReportInterrupts,
		/squelch /alias /reportmana       /echo ToggleVar Mana Reporting,ReportMana,GeneralStuff,ReportMana,
		/squelch /alias /reportmanapct    /echo ToggleString ReportMana Percent,ReportManaPct,GeneralStuff,ReportManaPct,
		/squelch /alias /reportmez        /echo ToggleVar Mezz Reporting,ReportMez,DebuffStuff,ReportMez,
		/squelch /alias /reportmezbroke   /echo ToggleVar Report Mez breaking,Mezbroke,DebuffStuff,Mezbroke,
		/squelch /alias /reportpettoys    /echo ToggleVar PetToys Reporting,ReportPetToys,SummonStuff,ReportPetToys,
		/squelch /alias /reportselfbuffs  /echo ToggleVar Self Buff Reporting,ReportSelfBuffs,SelfBuffStuff,ReportSelfBuffs,
		/squelch /alias /reportsotw       /echo ToggleVar Spirit of the Wood Reporting,ReportSotW,HealStuff,ReportSotW,
		/squelch /alias /reporttoggles    /echo ToggleVar Toggle Reporting,ReportToggles,GeneralStuff,ReportToggles,
		/squelch /alias /reportwow        /echo ToggleVar Wrath of the Wild Reporting,ReportWoW,GeneralStuff,ReportWoW,
		/squelch /alias /restgem 		  /echo RestGem
		/squelch /alias /saveini          /echo SaveIni
		/squelch /alias /selfbuff         /echo ToggleVar Auto Self Buffing,SelfBuffs,SelfBuffStuff,SelfBuffs,
		/squelch /alias /showdebuffs	  /echo ShowDebuffs	
		/squelch /alias /sitdelay         /echo ToggleString Sit Delay after casting,SitDelay,Settings,SitDelay,
		/squelch /alias /SongAlias        /echo SongAlias
		/squelch /alias /sotw             /echo ToggleVar Auto Spirit of the Wood,DoSotW,HealStuff,DoSotW,
		/squelch /alias /sotwpct          /echo ToggleString SotW/CR/AAid Average Group Percent Hitpoints,SotWPct,HealStuff,SotWPct,
		/squelch /alias /status      	  /echo ToggleVar Toggle group status checking,Status,MeleeStuff,Status,
		/squelch /alias /stayonheal	      /echo ToggleString Staying on heal,StayOnHeal,HealStuff,StayOnHeal,	
		/squelch /alias /stickargs        /echo ToggleString Melee args for stick,StickArgs,MeleeStuff,StickArgs,
		/squelch /alias /stophps          /echo ToggleString Stop Nuking Percent Hitpoints,StopHPs,GeneralStuff,StopHPs,
		/squelch /alias /summonmeals      /echo ToggleVar Auto Summoning of food and drink,SummonFood,SummonStuff,SummonFood,
		/squelch /alias /tankhealpct      /echo ToggleString Main Assist Complete Heal Percent Hitpoints,TankHealPct,HealStuff,TankHealPct,
		/squelch /alias /targetlock       /echo ToggleVar Using non-assist target lock,TargetLock,GeneralStuff,TargetLock,
		/squelch /alias /useammoclicky    /echo ToggleVar Summoning of ammo,UseAmmoClicky,SummonStuff,UseAmmoClicky,
		/squelch /alias /UseCH            /echo ToggleVar CHing of MA1,UseCH,HealStuff,UseCH,
		/squelch /alias /usedelayed       /echo ToggleVar Delayed Heal of MA1,UseDelayedHeal,HealStuff,UseDelayedHeal,
		/squelch /alias /usedivarb        /echo ToggleVar Auto Divine Arbitration,UseDivArb,HealStuff,UseDivArb,
		/squelch /alias /useepic          /echo ToggleString Mobs for use epic,UseEpic,GeneralStuff,UseEpic,
		/squelch /alias /usetankhot       /echo ToggleVar Useage of Heal over Time on MA1,UseTankHoT,HealStuff,UseTankHoT,
		/squelch /alias /useirc           /echo ToggleVar Using the IRC Plugin,UseIRC,Settings,UseIRC,
		/squelch /alias /usegroupassist   /echo ToggleVar Use Grouprole Main Assist as MA1,UseGroupMA,GeneralStuff,UseGroupMA,		
		/squelch /alias /usegroupma 	  /echo ToggleVar Use Grouprole Main Assist as MA1,UseGroupMA,GeneralStuff,UseGroupMA,
        /squelch /alias /usegrouptank     /echo ToggleVar Use Tank set by Role instead of MA1 for healing,UseGroupTank,GeneralStuff,UseGroupTank,
		/squelch /alias /usehott          /echo ToggleVar Health of Target's Target Evaluation for Debuffs,UseHoTT,DebuffStuff,UseHoTT,	
		/squelch /alias /usemount         /echo ToggleVar Auto Mounting,UseMount,Settings,UseMount,
		/squelch /alias /UsePet           /echo ToggleVar Auto Pet summoning and melee,UsePet,PetStuff,UsePet,
		/squelch /alias /useraidassist    /echo ToggleVar Use Raid Designated Main Assist1 as MA1,UseRaidMA,GeneralStuff,UseRaidMA,
		/squelch /alias /useraidma		  /echo ToggleVar Use Raid Designated Main Assist1 as MA1,UseRaidMA,GeneralStuff,UseRaidMA,		
		/squelch /alias /waittocancel     /echo ToggleVar Waiting to Cancel Heals,WaitToCancel,HealStuff,WaitToCancel,
		/squelch /alias /wow              /echo ToggleVar Auto Wrath of the Wild,DoWoW,GeneralStuff,DoWoW,	
		/ini "RDCommon.ini" "Settings" "Version" "${RDVersion}"
	}
	/call LoadIni "${RDIni}" LOAD
	/call QuickBegDeclares
	/call SetupAdvLootVars
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (!${Bool[${Plugin[MQ2Twist].Name}]}) /plugin MQ2Twist noauto
		/delay 10s ${Bool[${Plugin[MQ2Twist].Name}]}
		/if (!${Bool[${Plugin[MQ2Twist].Name}]}) {
			/echo You need MQ2Twist to play a bard!
			/end
			}
|---EDIT per Sifun forum post 10-2-17
|		/call Event_ListSongs None All
|		/call SetTwists
		}
	/varset ZoneName ${Zone.Name}
	/echo Finished loading, ready for battle.
	/call AnnounceMessage ${ChatChannel} 1 g Ready
	/call INICheck1
	
:mainloop
	/if (!${Me.Moving} && !${Guard}) {
		/call AutoSit
		}
    /if (${RDPause} && !${PauseTimer}) {
        /varset PauseTimer 10s
        /echo Paused ...
		/varset PauseFlag TRUE
		}
	/if (!${RDPause}) {
		/varset PauseFlag FALSE
		}
	/if (${Me.State.Equal[HOVER]}) {
		/call Event_Dead
		}
	/if (!${Zone.Name.Equal[${ZoneName}]}) {
		/call Event_NewZone
		}
	/if (${UseGroupMA}==TRUE  && ${Group.MainAssist.ID}!=${Spawn[${MA1}].ID}) {
		/varset MA1 ${Group.MainAssist}
		}
	/if (${UseRaidMA}==TRUE  && ${UseGroupMA}==FALSE && ${Raid.MainAssist.ID}!=${Spawn[${MA1}].ID}) {
		/varset MA1 ${Raid.MainAssist}
		}
    /if (${UseGroupTank}) {
        /varset MainTankID ${Group.MainTank.ID}
		} else {
        /varset MainTankID ${Spawn[${MA1}].ID}
		}
	/if (!${RDPause} && (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]})) {
		/if (${Me.Class.ShortName.Equal[BRD]} && !${TwistTimer}) {
			/call SingSongs
			}
		/call MeBegBuff
		/call MeBegItem
		/call PetBegBuff
		/if (${DoRestStuff} && !${Me.CombatState.Equal[COMBAT]} && !${RestStuffTimer}) {
			/call DoStuff Rest
			/call MercStuff
			/call ClassStuffRest
			}
		/if (!${RDPause} && !${Me.Moving}) {
			/call SummonStuff
			}
		/if (${Bool[${Plugin[MQ2Debuffs]}]}) {
			/if (${Debuff}) {
				/call MeBegCure
				}
			}
		/if (${UseRods}) {
			/call ClickRods
			}
		/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) {
			/call CheckGroup
			}
		/if (${DoShrink} && !${RDPause} && !${Me.Moving} && !${Me.Invis} && !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) {
			/call ShrinkStuff
			}
		/if (!${RDPause} && ${QueueCount} && !${Me.Moving} && ${DoBuffs} && (${BattleBuffFlag} || !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) && ${Me.PctMana}>=${DoBuffLowest}) {
			/if (${Debug}) /echo Calling DoBuffEvents with QueueCount=${QueueCount}
			/call DoBuffEvents
			}
		/if (!${RDPause} && !${DoBuffTimer} && (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]}) && !${Me.Moving} && !${Melee.Combat} && !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && (!${Me.Casting.ID} || ${Me.Class.ShortName.Equal[BRD]})) {
			/if (${SelfBuffs} && !${SelfBuffTimer}) {
				/call CheckBuffs
				}
			/if ((${UsePet} || ${DoCharm}) && ${Me.PctMana}>=${PetMana} && !${Bool[${PetBuffTimer}]}) {
				/call PetStuff
				}
			/if (!${Me.Moving} && ${DoWoW} && ${Me.AltAbilityReady[Wrath of the Wild]}) {
				/call DoWoW
				}
			/if (${DoBuffTotal}) {
				/varset DoBuffTimer 3s
				}
		}
		/if (!${RDPause} && (!${Me.Invis} || ${Me.Class.ShortName.Equal[ROG]}) && ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]} && ${Zone.ID}!=202 && ${Zone.ID}!=344) {
			/if (${AssistHeal}) {
				/call DoAssistHeal
				}
			/if (${AEHeal}) {
				/call DoAEHeal
				}
			/if (${HealXTarget} && !${RDPause}) {
				/call HealXTarget
				}
			/if (${AssistMA}) {
				/call AssistMA1
				}
			/if ((${DoMez} || ${DoCharm}) && ${Select[${Me.Class.ShortName},BRD,ENC,DRU]} && (!${CheckGroupTimer} || ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}!=${LastSpawnCount})) {
				/call CheckMez
				}
			/if (${Guard}) {
				/call Guard
				}
			/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${AssistTimer}) {
				/call PetAttackStuff
				}
			/if ((${DoDebuffs} || ${DoDoTs} || ${DoManaTaps}) && ${Me.PctMana}>=${DebuffLowest}) {
				/call DebuffIt
				}
			/if (!${NukeTimer} && ${DoNukes} && ${Me.PctMana}>=${NukeLowest} && ${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${MATarget}!=999999) {
				/call Nukeit
				}
			/if (${DoCombatStuff} && ${Me.CombatState.Equal[COMBAT]} && !${CombatStuffTimer}) {
				/call DoStuff Combat
				}
			/if (${DoDefense} && ${Me.CombatState.Equal[COMBAT]} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]} && (${Target.Named} || ${Me.XTarget}>2 || (${Spawn[id ${MATarget}].Level}>=${Math.Calc[${Me.Level}+3]}) || ${Me.PctHPs}<70) && ${Target.Distance}<75) {
				/call Defense
				}
			/if (((${Target.Named} || ${Spawn[id ${MATarget}].Level}>=${Math.Calc[${Me.Level}+4]}) || ${Me.XTarget}>2) && ${Target.Type.Equal[npc]} && ${DoNamedStuff}) {
				/call Named 			
				}
			/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]}) {
				/call ClassStuffCombat
				}
			}
		}
	/call MoveStuff
	/if (!${Me.Moving}) {
		/call AutoSit
		}
	/if (${Defined[Irc]}) {
		/if (!${Irc} && ${IRCConnect}) /call Connect
		}
	/doevents
|	/if (${Window[TradeWnd].HisTradeReady} && (${MasterList.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList2.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || |${MasterList3.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList4.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]} || ${MasterList5.Find[${Window[TradeWnd].Child[TRDW_HisName].Text}]})) {
|		/notify TradeWnd TRDW_Trade_Button leftmouseup
|		}
	/goto :mainloop
	/return

Sub PauseFunction
	/delay 10s !${Me.Casting.ID}
	/return
	
Sub INICheck1
|------------------
| Checks sections that are turned on, announces check in MQ2Chat window. If there are errors, announces the section and number of the problem INI entry
| sort 1 = single variables with "spell" in the name
| sort 2 = single variables with out "spell" in the name
| sort 3 = multiple variables with "spell" in the name
| sort 4 = multiple variables with out "spell" in the name
|------------------
	/if (${SelfBuffs}) {
		/call INICheck2 SelfBuff 4
		}
	/if (${DoBuffs}) {
		/call INICheck2 DoBuff 4
		}
	/if (${DoDebuffs}) {
		/call INICheck2 Debuff 3
		}
	/if (${Defined[DoNukes]}) {
		/if (${DoNukes}) /call INICheck2 Nuke 4
		}
	/if (${UseGroupMA}) {
		/echo ${If[${Group.MainAssist.ID},\am Group MA is \ay ${Group.MainAssist},\ar NO assigned group MA!!]}
		}	
	/if (${UseRaidMA}) {
		/if (${Raid.Members}<1) {
			/echo \ar ERROR \ay using Raid Assist while not on a raid!
			}
		/if (${Raid.Members}>1 && !${Raid.MainAssist.ID}) {
			/echo \ar ERROR \ay no Raid Main Assist assigned
			}
		/if (${UseGroupMA} || ${UseGroupTank}) {
			/echo \ar ERROR \ay trying to use Raid Assist with ${If[${UseGroupMA},UseGroupMA on!!,]} ${If[${UseGroupTank},UseGroupTank on!!,]}
			}
		}
	/if (${UseGroupTank}) {
		/echo ${If[${Group.MainTank.ID},\am Main Tank is \ay ${Group.MainTank},\ar NO Main Tank assigned!!]}
		/if (${UseGroupMA} && ${Group.MainAssist.ID}!=${Group.MainTank.ID}) {
			/echo \ao Both "/usegrouptank" and "/usegroupma" are on, need one of them off
			}
		}
	/if (${DoShrink}) {
		/call INICheck2 Shrink 1
		}
	/if (${Defined[HealGroup]}) {
		/if (${HealGroup}) {
			/if (${DoRetort}) {
				/if (!${Me.Book[${Me.Book[${Spell[${RetortSpell}].RankName}]}].ID}) /echo \ar Retort spell ${RetortSpell} not in spellbook.
				}
			/if (${UseTankHoT}) {
				/call INICheck2 Hot 1
				}
			/if (${UseFranticHeal}) {
				/call INICheck2 FranticHeal 2
				}
			/if (${HealGroup} || ${Bool[${FastHeal}]}) {
				/call INICheck2 FastHeal 2
				}
			/if (${UseCH}) {
				/call INICheck2 TankHeal 2
				}
			/if (${HealPets}) {
				/call INICheck2 PetHeal 2
				}
			/if (${GroupHealing}) {
				/call INICheck2 GroupHeal 2
				}
			/if (${UseDelayedHeal}) {
				/call INICheck2 DelayedHeal 2
				}
			}
		}
	/if (${Defined[UseDivArb]}) {
		/if (${UseDivArb}) {
			/call INICheck2 DivArb 1
			}
		}
	/if (${Defined[DoWard]}) {
		/if (${DoWard}) {
			/if (!${Me.Book[${Me.Book[${Spell[${WardSpell}].RankName}]}].ID}) /echo \ar Ward spell ${WardSpell} not in spellbook.
			}
		}
	/if (${DoCures}) {
		/call INICheck2 Cure 3
		}
	/if (${Defined[UsePet]}) {
		/if (${UsePet}) {
			/call INICheck2 Pet 1
			}
		}
	/if (${Defined[PetShrink]}) {
		/if (${PetShrink}) {
			/call INICheck2 PetShrink 1
			}
		}
	/if (${Defined[DoPetBuffs]}) {
		/if (${DoPetBuffs}) {
			/call INICheck2 PetBuff 4
			}
		}
	/if (${SummonFood}) {
		/call INICheck2 food 1
		/call INICheck2 drink 1
		}
	/return

Sub INICheck2(Types,Sort)
|------------------
| The actualy function of the INI check feature.
|------------------	
	/declare x int local
	/if (${Sort}==1) {
	|For spells with "spell" in the name IE InvisibilitySpell
		/echo \ay Checking \ao ${Types}
		/if (!${Select[${${Types}Gem},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}Spell}].RankName}]}].ID}) {
			/echo \ar ${${Types}Spell} not in spellbook.
			}
		/if (${${Types}Gem.Equal[item]} && !${FindItem[${${Types}Spell}].ID}) {
			/echo \ar ${Types} ${${Types}Spell} is marked as an item and not in inventory.
			}
		/if (${${Types}Gem.Equal[alt]} && !${Me.AltAbility[${${Types}Spell}].ID}) {
			/echo \ar ${Types} ${${Types}Spell} is marked as an AA, you don't appear to have.	
			}
		}
	/if (${Sort}==2) {
	|For spells with out "spell" in the name IE DelayedHeal
		/echo \ay Checking \ao ${Types}
		/if (!${Select[${${Types}Gem},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}}].RankName}]}].ID}) {
			/echo \ar ${${Types}} not in spellbook.
			}
		/if (${${Types}Gem.Equal[item]} && !${FindItem[${${Types}}].ID}) {
			/echo \ar ${${Types}} is marked as an item and not in inventory.
			}
		/if (${${Types}Gem.Equal[alt]} && !${Me.AltAbility[${${Types}}].ID}) {
			/echo \ar ${${Types}} is marked as an AA, you don't appear to have.	
			}
		}		
	/if (${Sort}==3) {
	|for spells with a variable at the end, with "spell" in the name IE DebuffSpell
		/echo \ay Checking \ao ${Types}
		/for x 1 to ${${Types}Total}
			/if (!${Select[${${Types}Gem${x}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}Spell${x}}].RankName}]}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} not in spellbook.
				}
			/if (${${Types}Gem${x}.Equal[item]} && !${FindItem[${${Types}Spell${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} is marked as an item and not in inventory.
				}
			/if (${${Types}Gem${x}.Equal[alt]} && !${Me.AltAbility[${${Types}Spell${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}Spell${x}} is marked as an AA, you don't appear to have.
				}
		/next x
		}
	/if (${Sort}==4) {
	|for spells with a variable at the end,but no "spell" in the name IE Dobuff1
		/echo \ay Checking \ao ${Types}
		/for x 1 to ${${Types}Total}
			/if (!${Select[${${Types}Gem${x}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${${Types}${x}}].RankName}]}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} not in spellbook.
				}
			/if (${${Types}Gem${x}.Equal[item]} && !${FindItem[${${Types}${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} is marked as an item and not in inventory.
				}
			/if (${${Types}Gem${x}.Equal[alt]} && !${Me.AltAbility[${${Types}${x}}].ID}) {
				/echo \ar ${Types} -${x}- ${${Types}${x}} is marked as an AA, you don't appear to have.
				}
		/next x
		}		
	/return	

sub check_who_has(string _sender, string _verbage)
	| Credit = LamaHerder, exspes007
	/declare _slot          int local
	/declare _augslot    int local
	/declare _bagslot    int local

	/if (${FindItem[${_verbage}].ID} && !${FindItem[${_verbage}].Type.Equal[Augmentation]}) {
		/call AnnounceMessage "${ChatChannel}" 2 m "${FindItem[${_verbage}]}" y ": Item Inventory"
		} else /if (${FindItemBank[${_verbage}].ID} && !${FindItemBank[${_verbage}].Type.Equal[Augmentation]}) {
		/call AnnounceMessage "${ChatChannel}" 2 m "${FindItemBank[${_verbage}]}" y ": Item Bank"
		}
	| augment search   
	| worn inventory skip powersource (21) unless your powersource does something mine doesn't?
	/for _slot 0 to 22
		/if (${_slot} == 21) /goto :noWornItemAug
		/for _augslot 0 to ${Me.Inventory[${_slot}].Augs}
			/if (${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name}" g ": Worn Augment in" y "${Me.Inventory[${_slot}].Name}" g ":item is worn"
				/return
				}
		/next _augslot
		:noWornItemAug
	/next _slot         
	| bag inventory
	/for _slot 23 to 32
    | top slot augs
		/if (${Me.Inventory[${_slot}].Name.Equal[${_verbage}]}) /call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Name}" g ": Inventory Augment in" y "${Me.Inventory[${_slot}].Name}" g ":in a top inventory slot"
	| top slot item   with augs
		/if (${Me.Inventory[${_slot}].Augs}) {
			/for _augslot 0 to ${Me.Inventory[${_slot}].Augs}
				/if (${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].AugSlot[${_augslot}].Name}" g ": Inventory Item Augment in" y "${Me.Inventory[${_slot}].Name}" g ":in a top inventory slot"
				/return
				}
			/next _augslot
			}
	| inside bags
		/if (${InvSlot[${_slot}].Item.Container}) {
         /for _bagslot 1 to ${InvSlot[${_slot}].Item.Container}
            /if (${Me.Inventory[${_slot}].Item[${_bagslot}].Name.Equal[${_verbage}]}) {
				/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Item[${_bagslot}].Name}" g ": Inventory Item in" y  "${Me.Inventory[${_slot}].Name}" g ":in my bags"
				/return
				}
            | augmented items inside bags
            /if (${Me.Inventory[${_slot}].Item[${_bagslot}].Augs}) {
               /for _augslot 0 to ${Me.Inventory[${_slot}].Item[${_bagslot}].Augs}
					/if (${Me.Inventory[${_slot}].Item[${_bagslot}].AugSlot[${_augslot}].Name.Equal[${_verbage}]}) {
					/call AnnounceMessage "${ChatChannel}" 4 m "${Me.Inventory[${_slot}].Item[${_bagslot}].AugSlot[${_augslot}].Name}" g ": Inventory Item Augment in" y "${Me.Inventory[${_slot}].Item[${_bagslot}].Name}" g ":in my bags"
					/return
					}
               /next _augslot   
            }
         /next _bagslot
      }
   /next _slot 
   :exit
/return		
	
Sub ClassStuffCombat
	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/if (${QM}) {
			/call QuietMiracle 
			}
		/if (${DoRetort}) {
			/call Retort
			}
		/if (${DoWard}) {
			/call Ward
			}
		/if (${UseDelayedHeal} && ${Bool[!${DoDelayedTimer}]}) {
			/call DelayedHeal
			}
		/if (${UseTankHoT} && !${RDPause}) {
			/call HealOverTime
			}
		}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${DoDichotomic}) {
|---EDIT per Sifun forum post 10-2-17
|			/if (${Me.Casting.ID} && !${Cast.Timing}) {
|				/twist stop
|				}
			/call DichotomicPsalm
			}
		}
	/if (${Me.Class.ShortName.Equal[DRU]}) {
		/if (${DoWoW} && ${Me.AltAbilityReady[Wrath of the Wild]}) {
			/call DoWoW
			}
		/if (${UseDelayedHeal} && !${DoDelayedTimer}) {
			/call DelayedHeal
			}
		/if (${UseTankHoT} && !${RDPause}) {
			/call HealOverTime
			}
		}
	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/if (${UseDelayedHeal} && !${DoDelayedTimer}) {
			/call DelayedHeal
			}
		/if (${UseTankHoT} && !${RDPause}) {
			/call HealOverTime
			}
		}
	/if (${Me.Class.ShortName.Equal[BST]}) { 
		/if (${QM}) {
			/call ParagonOfSpirit 
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Potential].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Potential].RankName}" Gem${Me.Gem[Gather Potential]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Capacity].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Capacity].RankName}" Gem${Me.Gem[Gather Capacity]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Magnitude].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Magnitude].RankName}" Gem${Me.Gem[Gather Magnitude]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<20 && ${Me.AltAbilityReady[Mana Reserve]}) {
			/call MQ2Cast "Mana Researve" ALT 5 SpellFiller 3
			}
		}
	/if (${Select[${Me.Class.ShortName},MAG,NEC]}) {
		/if (${Me.Pet.ID} && ${SelfPetHealing}) {
			/call PetHealing
			}
		/if (${Me.Pet.ID} && ${PetDelayedHealing}) {
			/call PetDelayedHealing
			}
		}
	/return


	
Sub ClassStuffRest	
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/if (${QM}) {
			/call QuietMiracle
			}
		}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/if (${DoRally}) {
			/call RallyingCall
			}
		}
	/if (${Me.Class.ShortName.Equal[BST]}) { 
		/if (${QM}) {
			/call ParagonOfSpirit
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Potential].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Potential].RankName}" Gem${Me.Gem[Gather Potential]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Capacity].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Capacity].RankName}" Gem${Me.Gem[Gather Capacity]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<50 && ${Cast.Ready[${Me.Gem[${Spell[Gather Magnitude].RankName}]}]}) {
			/call MQ2Cast "${Spell[Gather Magnitude].RankName}" Gem${Me.Gem[Gather Magnitude]} 5 SpellFiller 3
			}
		/if (${Me.PctMana}<20 && ${Me.AltAbilityReady[Mana Reserve]}) {
			/call MQ2Cast "Mana Researve" ALT 5 SpellFiller 3
			}
		/if (!${Me.Pet.Primary} && ${Me.Pet.ID} && ${DoPetToys}) {
			/call PetToys ${Me.Pet.ID}
			}
		/if (${Me.Pet.ID} && ${SelfPetHealing}) {
			/call PetHealing
			}
		/if (${Me.Pet.ID} && ${PetDelayedHealing}) {
			/call PetDelayedHealing
			}
		}
	/return

	
Sub DelayedHeal
	/if (${Select[${Me.Class.ShortName},MNK,NEC,SHD,WAR,ROG,ENC,BRD,WIZ,BER]}) /return
	/if (${DoDelayedTimer}) /return
	/if (!${Me.Gem[${Spell[${DelayedHeal}].RankName}]}) {
		/memspell ${DelayedHealGem} "${Spell[${DelayedHeal}].RankName}"
		/return
		}
	/if (${HealDebug}) {
		/echo Delayed called, test1	
		}
	/if (!${RDPause} && ${MainTankID} && ${Spawn[ID ${MainTankID}].PctHPs}<${DelayedHealPct} && ${Me.SpellReady[${Spell[${DelayedHeal}].RankName}]} && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${DelayedHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${DelayedHealID}].Mana}) {
		/if (${HealDebug}) {
			/echo Delayed check passed, test2
			}
		/invoke ${Spawn[${MA1}].DoTarget}
		/if (${Bool[!${Target.Buff[${DelayedHeal}].ID}]}) {
			/call MQ2Cast "${Spell[${DelayedHeal}].RankName}" ${DelayedHealGem} 2s Check4Pad
			/if (${HealDebug}) {
				/echo casting "${Spell[${DelayedHeal}].RankName}" ${DelayedHealGem} , test 3
				}
			/if (${castReturn.Equal[CAST_SUCCESS]}) {
				/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ has Delayed Heal" t "${Spell[${DelayedHeal}].RankName}"
				}
			/varcalc DoDelayedTimer 3+10*${Spell[${DelayedHealID}].Duration.TotalSeconds}
			} else {
			/varcalc DoDelayedTimer 2+10*${Target.BuffDuration[${DelayedHeal}].TotalSeconds}
			}
		}
	/varset castReturn CAST_CANCELLED
	/if (${HealDebug}) {
		/echo leaving Delayed routine
		}
	/return
	
Sub AddMaster(Master)
	/if (${Debug}) /echo \ag Entering \ao Masterlist sub
	/if (${Ini[RDCommon.ini,Settings,Masterlist].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 1
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist2].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 2
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList2"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist3].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 3
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList3"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist4].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 4
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList4"
		/return
		}
	/if (${Ini[RDCommon.ini,Settings,Masterlist5].Find[${Master}]}) {
		/if (${Debug}) /echo already on masterlist 5
		/call AnnounceMessage "${ChatChannel}" 2 m ${Master} y "is already on the MasterList5"
		/return
		}
	/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}>350 && ${MasterList5.Length}>350) {
		/if (${Debug}) /echo all masterlists full
		/call AnnounceMessage "${ChatChannel}" ${ChatChannel} 3 m ${Master} r "NOT added," y MasterList is full
		/return
		}		
	/if (!${Ini[RDCommon.ini,Settings,Masterlist].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist2].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist3].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist4].Find[${Master}]} && !${Ini[RDCommon.ini,Settings,Masterlist5].Find[${Master}]}) {
		/if (${MasterList.Length}<350) /ini RDCommon.ini Settings Masterlist ${MasterList}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}<350) /ini RDCommon.ini Settings Masterlist2 ${MasterList2}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}<350) /ini RDCommon.ini Settings Masterlist3 ${MasterList3}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}<350) /ini RDCommon.ini Settings Masterlist4 ${MasterList4}${Master}|
		/if (${MasterList.Length}>350 && ${MasterList2.Length}>350 && ${MasterList3.Length}>350 && ${MasterList4.Length}>350 && ${MasterList5.Length}>350) /ini RDCommon.ini Settings Masterlist5 ${MasterList5}${Master}|

		/call AnnounceMessage ${ChatChannel} 3 m ${Master} g "added to the" y MasterList
		/delay 2s
		/call LoadVar Settings MasterList "Put your list of master bots here" MasterList "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList2 "Put your list of master bots here" MasterList2 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList3 "Put your list of master bots here" MasterList3 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList4 "Put your list of master bots here" MasterList4 "RDCommon.ini" ${Function} string
		/delay 1s
		/call LoadVar Settings MasterList5 "Put your list of master bots here" MasterList5 "RDCommon.ini" ${Function} string
		} else {
		/call AnnounceMessage ${ChatChannel} 4 m ${Master} r "NOT ADDED" g "to the" y MasterList
		}

	/return	

Sub AddToMobList(int NPCID)
	/if (${Debug}) /echo \ag Entering \ao AddToMobList sub
	/if (!${PetID} && ${DoCharm} && ${Spawn[${NPCID}].Level}<=${MaxCharmLvl}) {
		/varset PetID ${NPCID}
		}
	/declare e int local
	/declare b int local
	/for e 1 to ${MaxMobs}
		/if (!${Bool[${e}]}) /next e
		/if (${Debug}) /echo Add Mob to List first \ag for \ao loop a = \ay ${e} \ao bool = \ag ${Bool[${e}]} \ao moblist = ${MobList[${e}]}
		/if (!${MobList[${e}]}) {
			/varcalc VarNPCCount ${VarNPCCount}+1
			/varset MobList[${e}] ${NPCID}
			/for b 1 to ${DebuffTotal}
				/if (${Debug}) /echo Add Mob to list second \ag for \ao loop b = \ay ${b}
				/varset DebuffArray[${e},${b}] ${Macro.RunTime}
			/next b
			/return
		}
	/next e
	/if (${Debug}) /echo \am Exiting AddToMobList
	/return	

Sub AddToQueue(int Buffee,int BuffNumber)
	/if (${Debug}) /echo \ag Entering \ao AddToQueue sub
	/declare a           int local 1
	/declare Compare     int local 0
	/if (!${RestrictedList.Find[|${DoBuffID[${BuffNumber}]}|]} && ${QueueCount}<25 && !(${Spawn[${Buffee}].Type.Equal[corpse]} ^^ ${RezBuff${BuffNumber}}) && ${Spawn[${Buffee}].ID}) {
		/if (${Debug}) {
			/echo First check: \ay Restricted List = \ag !${RestrictedList.Find[|${DoBuffID[${BuffNumber}]}|]} 
			/echo QueCount is \ag ${QueueCount}<25 \ao Buffee is not a corpse = ${Spawn[${Buffee}].Type.NotEqual[corpse]}
			/echo Rez buff number = \ag ${RezBuff${BuffNumber}} 
			/echo Buff ${BuffNumber}, Bufee is \am ${Spawn[${Buffee}].CleanName} \ao and ID is \am ${Spawn[${Buffee}].ID}
			}
		/varset Compare 0
		/for a 1 to 25
		/if (${Debug}) {
			/echo For loop a = \ag ${a}
			}
		/if ((${Buffee}==${DoBuffQueue[${a},1]} || (${Select[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} && (${Group.Member[${Spawn[${Buffee}].CleanName}].Index} || ${Group.Member[${Spawn[${Buffee}].Master.CleanName}].Index}) && ${Group.Member[${Spawn[${DoBuffQueue[${a},1]}].CleanName}].Index})) && ${BuffNumber}==${DoBuffQueue[${a},2]}) {
			/varset Compare 1
			}
		/if (${Debug}) {
			/echo does buffee equal queue? \ag ${Buffee}==${DoBuffQueue[${a},1]}
			/echo is the buff a group spell? \ag ${Select[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} \ao and buff a group member? \ay ${Group.Member[${Spawn[${Buffee}].CleanName}].Index}
			/echo if the bufee a pet is it's master in the group? \ag  ${Group.Member[${Spawn[${Buffee}].Master.CleanName}].Index}
			/echo does the buffnumber equal the queue? \ag ${BuffNumber}==${DoBuffQueue[${a},2]}
			}
		/next a
		/if (!${Compare}) {
			/for a 1 to 25
				/if (!${DoBuffQueue[${a},1]}) {
					/varset DoBuffQueue[${a},1] ${Buffee}
					/varset DoBuffQueue[${a},2] ${BuffNumber}
					/varcalc QueueCount ${QueueCount}+1
					/return
				}
			/next a
		}
	}
	/if (${Debug}) /echo \am Exiting AddToQueue
	/return

Sub AddSong(LowGem,HighGem,TwistType,Song)
	/declare i         int    local
	/declare j         int    local
	/declare flag      int    local 1
	/call CheckMaxSongs
	/if (${UniqueSongs}==${MaxGems}) {
		/for i 1 to ${MaxGems}
			/if (${SongsArray${i}.Equal[${Song}]}) {
				/varset i ${Math.Calc[${MaxGems}*2]}
				/varset flag 0
			}
		/next i
		/if (${flag}) {
			/call AnnounceMessage ${ChatChannel} "4" "g" "Already" "y" "${MaxGems}" "g" "unique songs set in twist." "r" "No gems available" 
			/call Event_ListSongs none all
			/return
			}
		}
	/for i ${LowGem} to ${HighGem}
		/if (${Ini[${RDIni},"Bard-${TwistType}",SongsArray${i},NOTFOUND].Equal[Song Name]}) {
			/if (!${Spell[${Song}].RankName.ID}) {
				/if (${Ini[${RDIni},"Bard-Aliases",${Song},NOTFOUND].Equal[NOTFOUND]}) /return
				/call AnnounceMessage ${ChatChannel} 4 g  "Adding" y "${Song}" g "-->" t "${Ini[${RDIni},"Bard-Aliases",${Song}]}"
				/varset Song ${Ini[${RDIni},"Bard-Aliases",${Song}]}
				}
			/for j ${LowGem} to ${i}
				/if (${Ini[${RDIni},"Bard-${TwistType}",SongsArray${j},NOTFOUND].Equal[${Song}]}) /return
			/next j
			/ini "${RDIni}" "Bard-${TwistType}" "SongsArray${i}" "${Song}"
			/call AnnounceMessage "${ChatChannel}" 4 g "-->" y "${Song}" g "added to" t "${TwistType} Twist"
			/varset SongsArray${i} ${Song}
			/call GetFreeGems
			/call MemSongs
			/call SetTwists
			/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs 1
			/call Event_ListSongs none all
			/return
		}
	/next i
	/call AnnounceMessage "${ChatChannel}" 3 r "no openings in" y "${TwistType} Twist list." r "Song NOT added"
	/call Event_ListSongs none all
	/return

Sub AnnounceMessage(Channel, EventTotal, Color1, Event1, Color2, Event2, Color3, Event3, Color4, Event4, Color5, Event5,)
	/if (${Channel.Equal[NULL]}) /return
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[1]}) /BC [+${Color1}+] ${Event1}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[2]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[3]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[4]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3} [+${Color4}+] ${Event4}
	/if (${Channel.Equal[BC]} && ${EventTotal.Equal[5]}) /BC [+${Color1}+] ${Event1} [+${Color2}+] ${Event2} [+${Color3}+] ${Event3} [+${Color4}+] ${Event4} ${Event5}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[1]}) /${Channel} ${Event1}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[2]}) /${Channel} ${Event1} ${Event2} 
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[3]}) /${Channel} ${Event1} ${Event2} ${Event3} 
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[4]}) /${Channel} ${Event1} ${Event2} ${Event3} ${Event4}
	/if (${Channel.NotEqual[BC]} && ${EventTotal.Equal[5]}) /${Channel} ${Event1} ${Event2} ${Event3} ${Event4} ${Event5}
	/return	
	
Sub AssistLoop
	/declare i int local
	/if (${UseGroupMA} && ${Group.Members} && ${Group.MainAssist.ID}) {
		|If we have GroupAssist and group assist is a valid target get it.
		/if (${Me.GroupAssistTarget.ID} && (${Me.GroupAssistTarget.Type.Equal[NPC]} || ${Me.GroupAssistTarget.Master.Type.Equal[npc]}) && ${Me.GroupAssistTarget.ID}!=${MATarget} && ${Me.GroupAssistTarget.Type.NotEqual[corpse]}) {
			/varset MATarget ${Me.GroupAssistTarget.ID}
			/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			/varset AssistTimer ${AssistDelay}
			/if (${Debug}) {
				/echo MATarget ${MATarget}
				/echo Me.GroupAssistTarget.ID ${Me.GroupAssistTarget.ID}
				}
			/return
		}
		|If we had a valid MATarget then stay with it.
		/if (${Spawn[${MATarget}].ID} && !${Spawn[${MATarget}].Type.Equal[corpse]}) {
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|Else we reset the MA
		/varset MATarget 999999
		/varset AssistTimer ${AssistDelay}
		/return
	}
	/if (${UseRaidMA} && !${UseGroupMA} && ${Raid.Members}>1 && ${Raid.MainAssist.ID}) {
		|If we have RaidAssist and Raid Assist's target is a valid target, get it.
		/if (${Me.RaidAssistTarget[1].ID} && (${Me.RaidAssistTarget[1].Type.Equal[NPC]} || ${Me.RaidAssistTarget[1].Master.Type.Equal[npc]}) && ${Me.RaidAssistTarget[1].ID}!=${MATarget} && ${Me.RaidAssistTarget[1].Type.NotEqual[corpse]}) {
			/varset MATarget ${Me.RaidAssistTarget[1].ID}
			/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|If we had a valid MATarget then stay with it.
		/if (${Spawn[${MATarget}].ID} && !${Spawn[${MATarget}].Type.Equal[corpse]}) {
			/varset AssistTimer ${AssistDelay}
			/return
		}
		|Else we reset the MA
		/varset MATarget 999999
		/varset AssistTimer ${AssistDelay}
		/return
	}	
	/for i 1 to 3
		/if (${Spawn[${MA${i}} radius 150 zradius 50].ID} && !${UseRaidMA} && !${UseGroupMA}) {
			/if (${Me.CleanName.NotEqual[${MA${i}}]}) /call AssistStuff ${i}
			/if ((${Target.Type.Equal[NPC]} || ${Target.Master.Type.Equal[npc]}) && ${Target.ID}!=${MATarget} && ${Target.Type.NotEqual[corpse]}) {
				/varset MATarget ${Target.ID}
				/if (${Defined[MADebuffed]}) /varset MADebuffed FALSE
			}
			/varset AssistTimer ${AssistDelay}
			/return
		}
	/next i
	/varset MATarget 999999
	/varset AssistTimer ${AssistDelay}
	/return

Sub AssistMA1
	| if we are not assisting, set the MATarget to our target
	| unless someone set it for us...
	/if (${Spawn[${MA1}].ID}==${Me.ID}) /return
	/if (!${AssistMA} && !${RDPause}) {
		/if (${TargetLock}) {
			/if (${MATarget}!=999999 && ${Spawn[${MATarget}].ID} && ${Target.ID}!=${MATarget} && ${Spawn[${MATarget}].Type.NotEqual[Corpse]}) {
				/target targetable id ${MATarget}
				/delay 1s ${Target.ID}==${MATarget}
				} else {
				/varset MATarget ${Target.ID}
				/if (!${MATarget}) /varset MATarget 999999
				}
			}
		/call MoveStuff
		/return
		}
	/if (!${RDPause} && (!${AssistTimer} || !${Spawn[${MATarget}].ID} || ${Spawn[${MATarget}].Type.Equal[corpse]})) {
		/call AssistLoop
		}
	/if (${Spawn[${MATarget}].Type.Equal[Corpse]}) {
		/varset MATarget 999999
		/return
		}
	/call MoveStuff
	/return	
	
Sub AssistStuff(int i)
	/declare OldTarget int local ${Target.ID}
	/if (${Spawn[${MA${i}}].ID}==${Me.ID}) /return
	/if (!${RDPause} && ${Target.ID} && (!${Melee.Combat} || ${Target.ID}!=${MATarget})) {
		/varset OldTarget NULL
|		/squelch /target clear
		}
	/delay 1s !${Target.ID} || ${Melee.Combat}
	/assist ${Spawn[${MA${i}}].CleanName}
	/delay 5s ${Target.ID}!=${OldTarget} && ${Me.AssistComplete}==TRUE
/return	

Sub AutoSit
	/declare i int local
	/declare TempGuy int local
	/if (!${RDPause}) {
		/if (${MakeCamp.Status.Equal[ON]} && ${MakeCamp.CampDist}>20) /makecamp return
		/delay 30s !${Me.Moving}
		/if (${Me.PctMana}==100) {
			/if (${ReportFM}) /call AnnounceMessage "${ChatChannel}" 3 g "Mana at" t "${Me.PctMana}" g "GTG boss!"
			/varset ReportFM FALSE
			}
		/if (${Select[${Me.Class.ShortName},WIZ,SHM,NEC,MAG,ENC,CLR,BST]} && ${Defined[CanniTotal]} && ${Defined[MedPct]})	{
			/if (${DoCanni}) {
				/if (!${Defined[CanniTotal]}) /call AnnounceMessage "${ChatChannel}" 3 r WARNING g CanniTotal y "is not defined, check INI"
				/if (!${Defined[MedPct]}) /call AnnounceMessage "${ChatChannel}" 3 r WARNING g MedPct y "is not defined, check ini"
				/if (!${Defined[CanniTotal]} || !${Defined[MedPct]}) /goto :skipcanni
				/if (${Defined[CanniTotal]} && ${Defined[MedPct]} && ${CanniTotal} && !${Me.Casting.ID} && ${Me.PctMana}<${MedPct} && !${Me.Invis}) {
					/for i 1 to ${CanniTotal}
					/if (((${Me.SpellReady[${Spell[${CanniSpell${i}}].RankName}]} || (!${Me.Gem[${CanniSpell${i}}]} && ${Spell[${CanniSpell${i}}].RankName.ID})) || ${Me.AltAbilityReady[${CanniSpell${i}}]} || (${CanniGem${i}.Equal[item]} && !${FindItem[${CanniSpell${i}}].Timer})) && ${Me.PctHPs}>${CanniHPs${i}} && ${Me.PctMana}<${CanniMana${i}} && !${Me.Buff[${CanniSpell${i}}].ID}) /call MQ2Cast "${CanniSpell${i}}" ${CanniGem${i}} 10s Check4Pad
					/if (${Me.Class.ShortName.Equal[WIZ]} && ${Me.Buff[${CanniSpell${i}}].ID}) /delay 19s !${Me.Buff[${CanniSpell${i}}].ID}
					/if (${Me.Buff[${CanniSpell${i}}].ID} && ${Me.PctHPs}<${CanniHPs${i}}) /nomodkey /notify BuffWindow buff${Me.Buff[${CanniSpell${i}}].ID} leftmouseup
					/if (!${Me.Buff[${CanniHealSpell}].ID} && ${Me.PctHPs}<${CanniHealHPs}) {
						/squelch /target targetable id ${Me.ID}
						/delay 1s ${Target.ID}==${Me.ID}		 		 		 		 
						/if (${Target.ID}==${Me.ID}) /call MQ2Cast "${CanniHealSpell}" ${CanniHealGem} 10s Check4Pad
						}
					/delay 1s
					/delay 10s !${Me.Casting.ID}
					/next i
					}
				}
			}
			:skipcanni
		/if (${Select[${Cursor.ID},3426,6346,18745,52674,52709,52803,52817,52888,57264,64951,76502,76503,79320,79321,79322,17574]}) {
			/if (${Me.FreeInventory}<=1 || ${Select[${Me.Class.ShortName},MNK,WAR,BER,ROG]}) {
				/call AnnounceMessage "${ChatChannel}" 3 y "I don't have enough free space for this mod-rod" w "(or I'm not a caster)" r "so I'm destroying it."
				/destroy
				}
			/autoinv	
			}
		/if (${Defined[QM]}) {
			/if (${QM} && !${Me.Invis}) /call QuietMiracle
			}
	|	/if (${DoYaulp} && !${Me.Buff[${YaulpSpell}].ID} && ${Spell[${YaulpSpell}].Stacks[0]} && (${Me.SpellReady[${Spell[${YaulpSpell}].RankName}]} || !${Me.Gem[${Spell[${YaulpSpell}].RankName}]}) && !${Me.Casting.ID} && ${Me.PctMana}<${MedPct} && !${Me.Mount.ID} && ((${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]} && ${NearestSpawn[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1].LineOfSight}) || !${AutoSit})) /call MQ2Cast "${YaulpSpell}" ${YaulpGem} 10s SpellFiller 3 
		/if (${Defined[GatherPct]}) {
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${FindItem["Azure Mind Crystal"].ID} && !${FindItem["Azure Mind Crystal"].Timer}) /call MQ2Cast "Azure Mind Crystal" item 10s SpellFiller 3
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${Me.AltAbilityReady[Mana draw]}) /call MQ2Cast "Mana draw" alt 10s SpellFiller 3
			/if (${Me.PctMana}<=${GatherPct} && !${Me.Invis} && ${Me.AltAbilityReady[Gather Mana]}) /call MQ2Cast "Gather Mana" alt 10s SpellFiller 3
			}
		/if (${Defined[MedPct]}) {
			/if (!${Me.Casting.ID} && !${Me.Invis} && (${Me.PctMana}<${MedPct} || ${Me.PctEndurance}<${EndMedPct}) && !${Me.Mount.ID} && !${Melee.Combat} && !${Me.Buff[${YaulpSpell}].ID}) {
				/if (${UseMount} && !${Me.FeetWet} && !${RestrictedList.Find[|NoMount|]}) {
					/doevents flush Restricted
					/call MQ2Cast "${MountItem}" item 10s Check4Pad
					/call DoRestrictedEvents NoMount
					}
				/if (${AutoSit} && !${Me.AutoFire} && !${SitTimer} && ${Me.Standing} && ${Me.CombatState.Equal[ACTIVE]} && (!${SpawnCount[npc targetable radius ${ASRadius} zradius ${ASZRadius} noalert 1]} || (${Me.PctAggro}<60)) && (${Stick.Status.NotEqual[ON]} || ${Spawn[id ${FollowGuy}].Distance}<${LeashDistance})) {
					/if (${Me.Class.ShortName.Equal[BRD]} && ${Twist.Twisting} && (${Me.PctMana}<${MedPct} || ${Me.PctEndurance}<${EndMedPct}) && !${Me.Mount.ID} && !${Melee.Combat}) /squelch /twist off
					/sit
					/varset SitTimer ${SitDelay}
					}
				}
			}
		}
	/return
	
Sub FranticHeal
	/target targetable id ${Spawn[$MA1]}.ID}
	/if (${Me.SpellReady[${FranticHeal}]}) {
		/call MQ2Cast "${FranticHeal}" ${FranticHealGem} 2s SpellFiller 3
		/if (${ReportHeals} && ${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage "${HealChannel}" 4 y "Frantic Heal" m "-> ${Target.CleanName} <-" g "with" t "${FranticHeal}"
		} else {
		/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 y "ACK!" t "${FranticHeal}" r "IS NOT CAST" y "because it is not ready!"
		}
	/return

Sub BegFrantic
	/if (${FranticSpamTimer}>0) {
		/return
		} else {
		/call AnnounceMessage "${ChatChannel}" 1 y "Frantic Heal NOW!" 
		/varset FranticSpamTimer 10s
		}
	/return

Sub BreakInvis
	/varset TravelMode FALSE
	/squelch /makemevisible
	/delay 10s !${Me.Invis}
	/return

Sub CalmGroup(Puller)
	/declare oldTarget int local 0
	/declare i int local 1
	/declare tempTarget int local 0
	/declare centerMob int local 0
	/declare casted int local 0
	/if (${Spawn[${Puller}].ID} && ((${FindItem[${CalmSpell}].ID} && ${CalmGem.Equal[item]}) || (${CalmGem.Equal[alt]} && ${Me.AltAbilityReady[${CalmSpell}]}) || ${Spell[${CalmSpell}].RankName.ID})) {
			/if (${Puller}!=${Me.ID}) {
			/squelch /target targetable id ${Puller}
			/delay 1s ${Target.ID}==${Puller} && ${Me.AssistComplete}==TRUE
			/assist
			/delay 1s ${Target.ID}!=${Puller} && ${Me.AssistComplete}==TRUE
		}
		/varset centerMob ${Target.ID}
		/while (${casted}<4 && ${Spawn[${centerMob}].NearestSpawn[${i},npc targetable radius 40 zradius 50 range 1 ${MaxCalmLvl} noalert 1].ID})
			/varset tempTarget ${Spawn[${centerMob}].NearestSpawn[${i},npc targetable radius 40 zradius 50 range 1 ${MaxCalmLvl} noalert 1].ID})
			/squelch /target targetable id ${tempTarget}
			/delay 1s ${Target.ID}==${tempTarget}
			/call MQ2Cast "${CalmSpell}" ${CalmGem} 3s Check4Pad 3		 
			/if (${castReturn.Equal[CAST_IMMUNE]} && ${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /call AnnounceMessage "${DebuffChannel}" 3 w "${Target.CleanName" r "is Immune to" y "${CalmSpell}"
			/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /call AnnounceMessage "${ChatChannel}" 2 y "${Target.CleanName}" g "is calmed" 
            /if (${castReturn.Equal[CAST_RESIST]}) {
				/if (${ReportDebuffs} && ${Target.ID} && ${Target.Type.Equal[NPC]}) /${DebuffChannel} ${Target.CleanName} ressisted calm
				/varset casted -1
				/break
			}
			/varcalc casted ${casted}+1		 		 
			/varcalc i ${i}+1		 
		/endwhile
		/if (${casted}==-1 && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 y "Calm not properly done" 
		/if (${casted} && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 g "Calm done pull away" 
		/if (!${casted} && ${ReportDebuffs}) /call AnnounceMessage "${DebuffChannel}" 1 y "No mobs to calm"
	}
	/return
	
Sub Check4Pad(int spellID)
|	/if (${Cursor.ID}) /autoinventory
	/if (${DoMez}) /doevents MezIt
	/if (!${RDPause} && (${DoMez} || ${DoCharm}) && ${Select[${Me.Class.ShortName},BRD,ENC]} && (!${CheckGroupTimer} || ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID}))) /call CheckMez ${spellID}
	/if (${Select[${Me.Class.ShortName},MNK,NEC,SHD,WAR,ROG,ENC,BRD,WIZ,BER,MAG]}) /return
	/if (!${RDPause}) {
		/if (${UseCH} && ${MainTankID}) {
|			/call CheckPPS
			/if (${Spawn[ID ${MainTankID}].Type.NotEqual[corpse]} && ${Spawn[ID ${MainTankID}].PctHPs}<${TankHealPct} && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${TankHealID}].Mana}) /call DoHeal ${MainTankID} Tank
			}
		/if (${HealXTarget} && !${RDPause} && ${Me.XTarget}) /call HealXTarget
		/if (${HealGroup}) {
			/call ${EvaluateFunction}
			/if (${Spawn[ID ${WorstID}].Type.NotEqual[corpse]} && ${WorstHPs}<${HealPct} && ${Me.CurrentMana}>${Spell[${FastHealID}].Mana} && (${Bool[${Plugin[MQ2Netheal]}]} || !${DAArray[${WorstMember},2]})) /call DoHeal ${WorstID} Fast
			}
		}
	/doevents ImHit
	/return


Sub CheckBuffs
	/if (${Melee.Combat} || (${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[Corpse]}) || !${Me.Combat}) /return
	/if (${Cursor.ID}) /autoinventory
	/if (!${RDPause}) {
	/declare i int local 1
	/declare a int local
	/for i 1 to ${SelfBuffTotal}
		/if (${i}>30) /break
		/if (${i}<1) /break
|-----Check to be sure your toon has the DoBuff spell, item, or AA	
		/if (!${Select[${SelfBuffGem${i}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${SelfBuff${i}}].RankName}]}].ID}) /multiline ; /echo \ar SelfBuff -${i}- ${SelfBuff${i}} not in spellbook. ; /next i
		/if (${SelfBuffGem${i}.Equal[item]} && !${FindItem[${SelfBuff${i}}].ID}) /multiline ; /echo \ar SelfBuff -${i}- ${SelfBuff${i}} is marked as an item and not in inventory. ; /next i
		/if (${SelfBuffGem${i}.Equal[alt]} && !${Me.AltAbility[${SelfBuff${i}}].ID}) /multiline ; /echo \ar SelfBuff -${i}- ${SelfBuff${i}} is marked as an AA, you don't appear to have. ; /next i
|-----
		/if ((${Me.CurrentMana}<${Spell[${SelfBuff${i}}].Mana} && !${Select[${SelfBuffGem${i}},alt,item,comb]}) || (${Select[${SelfBuffGem${i}},comb]} && ${Me.Endurance}<200)) /return
		/if (!${RestrictedList.Find[|${SelfBuffID[${i}]}|]} && ${Me.State.NotEqual[FEIGN]} && ((!${SelfBuffAura${i}} && ${Spell[${Spell[${SelfBuffIcon${i}}].RankName}].Stacks[0]} && !${Me.Buff[${Spell[${SelfBuffIcon${i}}].RankName}].ID} && !${Me.Song[${Spell[${SelfBuffIcon${i}}].RankName}].ID})  || (${SelfBuffAura${i}} && !${Bool[${Me.Aura[${SelfBuffIcon${i}}]}]})) && (${Me.CountBuffs}<${SelfBuffCount${i}} || ${SelfBuffAura${i}}) && (((!${SitTimer} || ${Me.Gem[${SelfBuff${i}}]} || ${Me.Mount.ID}) && ${Me.CurrentMana}>${Spell[${SelfBuff${i}}].Mana}) || (${SelfBuffGem${i}.Equal[item]} && !${FindItem[${SelfBuff${i}}].Timer}) || (${SelfBuffGem${i}.Equal[alt]} && ${Me.AltAbilityReady[${SelfBuff${i}}]}) || (${SelfBuffGem${i}.Equal[comb]} && ${Me.CombatAbilityReady[${SelfBuff${i}}]}))) {		
			/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
			/if (${Select[${Spell[${SelfBuffID[${i}]}].TargetType},pc,Single]} || (${Me.Class.ShortName.Equal[ENC]} && ${Spell[${SelfBuffID[${i}]}].Name.Find[Illusion:]})) {
				/squelch /target targetable id ${Me.ID}
				/delay 1s ${Target.ID}==${Me.ID}
			}
			/if (${ReportSelfBuffs}) /call AnnounceMessage  4 g "Buffing" o "${Spell[${SelfBuff${i}}]}" g "on" m "myself... OOH!"
			/varset SitTimer ${SitDelay}
|-----
|Bard Spell section
|-----			
			/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${SelfBuffGem${i}},item,alt,comb]}) {
				/if (${BardDebug}) /echo Self Buff enter Bard section
				/squelch /twist stop
				/delay 5s !${Me.Casting.ID}
				/delay 1s
				/if (!${Me.Gem[${Spell[${SelfBuff1}].RankName}]}) {
					/memspell ${SelfBuffGem1.Right[-3]} "${Spell[${SelfBuff${i}}].RankName}"
					/delay 30s ${Me.SpellReady[${Spell[${SelfBuff${i}}].RankName}]}
					/if (${BardDebug}) /echo Memorizing spell
					}
				/delay 1s
				/call DoCastingEvents
				/if (${BardDebug}) /echo Twisting spell ${Spell[${SelfBuff${i}}].RankName}
				/squelch /twist once ${Me.Gem[${Spell[${SelfBuff${i}}].RankName}]}
				/delay ${Spell[${SelfBuff${i}}].MyCastTime.TotalSeconds}s
				/delay 2s
				/squelch /twist off
				/varset castReturn CAST_SUCCESS
				/call DoCastingEvents
				/squelch /twist stop
				/if (${BardDebug}) /echo \am exiting Bard section
				/if (!${Me.Invis} && !${TwistTimer}) /call SingSongs
|-----
| End Bard Spell section
|-----					
			} else {
				/if (${Select[${SelfBuffGem${i}},comb]}) /disc ${SelfBuff${i}}
				/if (!${Select[${SelfBuffGem${i}},comb]}) {
					/if (${Me.Casting.ID} && ${Me.Class.ShortName.NotEqual[BRD]} && ${Me.Casting.ID}!=${SelfBuffID[${i}]}) /call DoInterrupt
					/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
					/doevents flush Restricted
					/squelch /target targetable id ${Me.ID}
					/if (${SelfBuffGem${i}.Equal[item]} && ${Me.HaveExpansion[Veil of Alaris]}) {
						/useitem ${SelfBuff${i}}
						/if (${ReportSelfBuffs}) /call AnnounceMessage  2 g "Clicking item" o "${SelfBuff${i}}"
						/return
						}
					/if (${Spell[${SelfBuff${i}}].RankName.ID} && ${SelfBuffGem${i}.NotEqual[ALT]} && ${SelfBuffGem${i}.NotEqual[comb]}) {
						/call MQ2Cast "${Spell[${SelfBuff${i}}].RankName}" ${SelfBuffGem${i}} 30s Check4Pad
						} else {
						/call MQ2Cast "${SelfBuff${i}}" ${SelfBuffGem${i}} 30s Check4Pad
						}
					/call DoRestrictedEvents ${SelfBuffID[${i}]}
|					/if (${castReturn.Equal[CAST_SUCCESS]} && ${Select[${Spell[${SelfBuffID[${i}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) /call RemoveFromQueue 0 ${SelfBuffID[${i}]}
					/if (${castReturn.Equal[CAST_SUCCESS]}) /call RemoveFromQueue 0 ${SelfBuffID[${i}]}
					
					/if (${castReturn.Equal[CAST_UNKNOWNSPELL ]}) {
						/call AnnounceMessage "${ChatChannel"}" 2 o "${SelfBuff${i}}" r "not found"
						/call RemoveFromQueue 0 ${SelfBuffID[${i}]}
						}
					/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
						/call AnnounceMessage "${ChatChannel"}" 2 o "${SelfBuff${i}}" r "wont take hold!!"
						/call RemoveFromQueue 0 ${SelfBuffID[${i}]}
						}
					/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs
					}
				}
		}
	/next i
	}
	/varset SelfBuffTimer ${SelfBuffRecheck}
	/call MoveStuff
	/return

Sub CheckDoBuffs(Sender,ChatText)
	/declare a        int local
	/declare i        int local
	/for i 1 to ${DoBuffTotal}
		/for a 1 to ${DoBuffAliases${i}.Count[|]}
			/if (${ChatText.Find["${DoBuffAliases${i}.Arg[${a},|]}"]}) {
				/if (${ChatText.Find[" pet"]} || ${ChatText.Find[${Spawn[pc "${Sender}"].Pet.CleanName}]}) {
					/call AddToQueue ${Spawn[pc ${Sender}].Pet.ID} ${i}
				} else /if (${Spawn[pc "${Sender}"].ID} && ${Spawn[corpse "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[pc ${Sender}].ID} ${i}
					/call AddToQueue ${Spawn[corpse ${Sender}].ID} ${i}
				} else /if (${Spawn[pc "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[pc ${Sender}].ID} ${i}
				} else /if (${Spawn[corpse "${Sender}"].ID}) {
					/call AddToQueue ${Spawn[corpse ${Sender}].ID} ${i}
				}		 		 
			}
		/next a
	/next i
	/return
	
Sub CheckGroup
:StayOnHeal
	/if (!${RDPause} && ${UseCH}) {
		/if (${MainTankID} && (${Me.Gem[${TankHeal}]}) && ${Me.SpellReady[${Spell[${TankHeal}].RankName}]}) {
			/call CheckPPS
			/if ((${TankTTL}<200 || ${Spawn[ID ${MainTankID}].PctHPs}<${TankHealPct}) && ${Spawn[ID ${MainTankID}].Distance}<${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.CurrentMana}>${Spell[${TankHealID}].Mana}) /call DoHeal ${MainTankID} Tank
			}
		}	
	/if (!${RDPause} && ${HealGroup}) {
		/call ${EvaluateFunction}
		/if (${WorstHPs}<${HealPct} && (${Bool[${Plugin[MQ2Netheal]}]} || !${DAArray[${WorstMember},2]})) {
			/if ((${GroupHurtCount}>=${GroupHealCount}) && (${Me.CurrentMana}>${Spell[${GroupHealID}].Mana}) && (${Me.Gem[${GroupHeal}]} || ${Me.SpellReady[${Spell[${GroupHeal}].RankName}]})) {
				/call DoHeal ${WorstID} Group
			} else /if ((${Me.CurrentMana}>${Spell[${FastHealID}].Mana}) && (${Me.Gem[${FastHeal}]} || ${Me.SpellReady[${Spell[${FastHeal}].RankName}]})) /call DoHeal ${WorstID} Fast
		}
	}
	/if (${HealXTarget} && !${RDPause} && ${Me.XTarget}) /call HealXTarget
	/if (!${RDPause} && ${HealPets}) {
		/if ((${Me.Gem[${PetHeal}]} || ${Me.SpellReady[${Spell[${PetHeal}].RankName}]}) && ${Me.CurrentMana}>${Spell[${PetHeal}].Mana}) {
			/call EvaluatePets
			/if (${WorstHPs}<${PetHealPct}) /call DoHeal ${WorstID} Pet
			}
		}
	/if (${StayOnHealTimer}) /goto :StayOnHeal
	/if (${DoCures} && ${CureTotal} && !${Me.Casting.ID}) /call CureMe
	/if (${Bool[${Plugin[MQ2Debuffs]}]}) {
		/if (${Debuff}) /call Cureme
		}
	/doevents
	/if (!${RDPause} && (${DoMez} || ${DoCharm}) && ${Select[${Me.Class.ShortName},BRD,ENC]} && (!${CheckGroupTimer} || ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID}))) /call CheckMez
	/if (!${Me.Moving}) /call AutoSit
	/return	
	
Sub CheckHP
	/if (!${RDPause} && ${Me.Casting.ID}) {
		/if (!${SpamFlag} && ${ReportHeals} && ${Target.ID}) {
			/call AnnounceMessage "${ChatChannel}"  4 t "Healing" m "${Target.CleanName}" t "with" o "${Me.Casting}"
			/varset SpamFlag TRUE
			}
	 	/if (${HealFD} && ${Target.State.Equal["FEIGN"]} && ${Select[${Target.Class.ShortName},MNK,NEC,SHD]}) /call DoInterrupt
	 	/call ${EvaluateFunction}
		/if (${UseCH} && ${Me.Casting.ID}==${TankHealID} && ${Target.ID}==${MainTankID} && ${FastHealID}!=${TankHealID}) {
			/call CheckPPS
			/if (${Target.PctHPs}>${TankHealPct} && ${TankTTL}>250 && ${castEndTime}<40 && ${castEndTime}>=${TankTTL}+50) {
				/call Interrupt
				/call DoHeal ${Target.ID} Fast
				}
			}
|		/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${TankHealID} && ${Me.Casting.ID}!=${DelayedHealID} && ${Me.Casting.ID}!=${DivArbSpellID} && ${Target.PctHPs}>=${CancelPct} && (!${WaitToCancel} || ${castEndTime}<5)) /call Interrupt
		/if (${HealMeFirst} && ${Me.PctHPs}<=${HealPct} && ${Target.ID}!=${Me.ID}) /call DoHeal ${Me.ID} Fast
		}
	/doevents ImHit
	/return	

Sub CheckMaxSongs
	/declare i       int  local
	/declare j       int  local
	/declare DupFlag bool local
	/varset UniqueSongs 0
	/for i 1 to ${Math.Calc[${MaxGems}*2]}
		/if (${SongsArray${i}.NotEqual[Song Name]}) /varcalc UniqueSongs ${UniqueSongs}+1
	/next i
	/for i 2 to ${Math.Calc[${MaxGems}*2]}
		/for j 1 to ${Math.Calc[${i}-1]}
			/if (${SongsArray${i}.NotEqual[Song Name]} && ${SongsArray${i}.Equal[${SongsArray${j}}]}) {
				/varset DupFlag 1
				/varset j ${i}
			}
		/next j
		/if (${DupFlag}) /varcalc UniqueSongs ${UniqueSongs}-1
	/next i
	/return	
	
Sub CheckMez(int spellID)
	/declare i int local
	/declare a int local
	/declare j int local
   |   Check if casting a charm
	/if (${spellID}) {
		/for i 1 to ${DebuffTotal}
			/if (${i}==30) /break
			/if (${SpellType${i}}!=5) /continue
			/if (${DebuffID[${i}]}==${spellID}) /return
		/next i
		}
	/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID})) /call PopulateNPCs
	/declare canAEMez bool local FALSE
	/if (${VarNPCCount}-${VarOldNPCCount}>2) /varset canAEMez TRUE
	/for j 1 to ${DebuffTotal}
		/if (${j}==30) /break
		/if (${j}<1) /break
		/doevents
		/if (!((${SpellType${j}}==2  || ${SpellType${j}}==4) && ${DoMez}) && !(${SpellType${j}}==5 && ${DoCharm})) /continue
		/if (${Me.Casting.ID}==${DebuffID[${j}]} && ${SpellType${j}}==2 && (${Target.ID}==${MATarget} || ${Target.Assist})) {
			/call DoInterrupt
			/varset castReturn X
			/return
			}
		/if (${spellID}==${DebuffID[${j}]}) /return
		/for a 1 to ${MaxMobs}  
			/if (${a}==30) /break
			/if (${a}<1) /break
			/if (!${MobList[${a}]}) /continue
			/if (${DoCharm} &&!${RDPause} && ${SpellType${j}}==5 && !${Me.Pet.ID} && ${MobList[${a}]} && ${Spawn[${MobList[${a}]}].LineOfSight} && ${Spawn[${MobList[${a}]}].Standing} && ${Spawn[${MobList[${a}]}].Level}<=${MaxCharmLvl} && ${MobList[${a}]}==${PetID}) {
				/if (!${${DebuffID[${j}]}Immune.Find[|${Spawn[${MobList[${a}]}].CleanName}|]} && (${Spawn[${MobList[${a}]}].Distance}<${Int[${Spell[${DebuffID[${j}]}].MyRange}]} || !${Spell[${DebuffID[${j}]}].MyRange}) && (${spellID}!=${DebuffID[${j}]} || ${Me.Class.ShortName.Equal[BRD]})) {
					/call DebuffStuff ${a} ${j}
					}
				}
			/if (${DoMez} && ${canAEMez} && ${SpellType${j}}==4 && !${RDPause} && ${MobList[${a}]} && ${Spawn[${MobList[${a}]}].LineOfSight} && ${MobList[${a}]}!=${MATarget} && !${Spawn[${MobList[${a}]}].Assist} && ${DebuffArray[${a},${j}]}<=${Macro.RunTime} && ${Spawn[${MobList[${a}]}].Standing} && ${Spawn[${MobList[${a}]}].Level}<=${MaxMezLvl}) {
				/if (!${${DebuffID[${j}]}Immune.Find[|${Spawn[${MobList[${a}]}].CleanName}|]} && (${Spawn[${MobList[${a}]}].NearestSpawn[2,npc targetable radius 30 noalert 1].ID}) && ((${Spawn[${MobList[${a}]}].Distance} < ${Int[${Spell[${DebuffID[${j}]}].MyRange}]}) || (!${Spell[${DebuffID[${j}]}].MyRange} && ${Spawn[${MobList[${a}]}].Distance}<${Int[${Spell[${DebuffID[${j}]}].AERange}]}))) {
					/varset VarOldNPCCount ${VarNPCCount}
					/varset canAEMez FALSE                    
					/call DebuffStuff ${a} ${j}                    
					}
				}      
			/if (${DoMez} && ${MobList[${a}]} && ${PetID}!=${MobList[${a}]} && !${RDPause} && ${SpellType${j}}==2 && ${Spawn[${MobList[${a}]}].LineOfSight} && ${MobList[${a}]}!=${MATarget} && !${Spawn[${MobList[${a}]}].Assist} && ${DebuffArray[${a},${j}]}<=${Macro.RunTime} && ${Spawn[${MobList[${a}]}].Standing} && ${Spawn[${MobList[${a}]}].Level}<=${MaxMezLvl}) {
				/if (!${${DebuffID[${j}]}Immune.Find[|${Spawn[${MobList[${a}]}].CleanName}|]} && (${Spawn[${MobList[${a}]}].Distance}<${Int[${Spell[${DebuffID[${j}]}].MyRange}]} || !${Spell[${DebuffID[${j}]}].MyRange}) && (${Me.Casting.ID}!=${DebuffID[${j}]} || ${Me.Class.ShortName.Equal[BRD]})) /call DebuffStuff ${a} ${j}
				}
				/varset VarOldNPCCount ${VarNPCCount}
				/varset canAEMez FALSE
		/next a
		/delay 1
	/next j
	/call MoveStuff
	/varset CheckGroupTimer 1s
	/return
	
Sub CheckPPS
	/if (${Debug}) /echo entering CheckPPS
|not pretty doing it here again but should tank die and receive rez it will not reset!
    /if (${UseGroupTank}) {
        /varset MainTankID ${Group.MainTank.ID}
		} else {
        /varset MainTankID ${Spawn[${MA1}].ID}
		}
|keep 3 around
    /declare tmpTarget int local 0
    /declare wegothit int local 0
    /if (!${UseGroupTank}) {
        /if (${Target.ID}!=${Spawn[pc ${MA1}].ID} && !${Spawn[pc group ${MA1}].ID}) {
            /varset tmpTarget ${Target.ID}
            /target targetable id ${Spawn[pc ${MA1}].ID}
            /delay 1s ${Target.ID}==${Spawn[pc ${MA1}].ID}
			}
		} else {
|do nothing because Tank will be in OUR group !${Group.MainTank.ID} evaluates FALSE
		}
|if he's not in our group
|and is pct went down 
|and it wasn't a complete heal
    /if (!${UseGroupTank}) {
        /if (!${Spawn[pc group ${MA1}].ID} && ${TankLastPct}>${Target.PctHPs} && ${Target.PctHPs}!=100) {
|he got hit by something (bad assumption of complete heal)
            | /varcalc TotalTankHits ${TotalTankHits}+(${TankLastPct}-${Target.PctHPs})
            /varset wegothit ${Target.PctHPs}
			} else {
 |if (tank in group) && (hp went down) && (hp != 100)
 | tothits = tothits+deltahp
            /if (${Spawn[pc group ${MA1}].ID} && ${TankLastPct}>${Spawn[pc group ${MA1}].PctHPs}) {
                | /varcalc TotalTankHits ${TotalTankHits}+(${TankLastPct}-${Spawn[pc group ${MA1}].PctHPs})
                /varset wegothit ${Spawn[pc group ${MA1}].PctHPs}
            }
        }
    } else {
        | using UseGroupTank - will always be in group so we do not need to check like above
        /if (${TankLastPct}>${Spawn[ID ${MainTankID}].PctHPs}) {
            /varset wegothit ${Spawn[ID ${MainTankID}].PctHPs}
        }
    }

    /if (${wegothit}) {
        /varcalc TotalTankHits ${TotalTankHits}-${TankHitsArray[${TankHitsIndex}]}+${TankLastPct}-${wegothit}
        /varcalc TankHitsArray[${TankHitsIndex}] ${TankLastPct}-${wegothit}
        /varset TankTimeArray[${TankHitsIndex}] ${Macro.RunTime}
        /varcalc TankHitsIndex ${TankHitsIndex}+1
        /if (${TankHitsIndex}>3) /varset TankHitsIndex 1
    }

    | we incremented the index already so we are pointing to the first
    | data point we recorded
    /if (${TankTimeArray[${TankHitsIndex}]} || ${TankHitsIndex}>1) {
        /varcalc TotalTankTime ${Macro.RunTime}-${If[${TankTimeArray[${TankHitsIndex}]},${TankTimeArray[${TankHitsIndex}]},${TankTimeArray[1]}]}
        /if (${TotalTankTime}) /varcalc TankPPS ${TotalTankHits}/${TotalTankTime}
    } else {
        | don't return anything until we've taken two hits
        /varset TankPPS 0
    }

    /if (!${TankPPS}) {
             /varset TankTTL 3000
    } else {
             /varcalc TankTTL (${Spawn[ID ${MainTankID}].PctHPs}*10)/${TankPPS}
    }

    |/if (${SpawnCount[npc radius 200]} && ${TankTTL}!=3000) {
    |/echo TankPPS ${TankPPS} TankTTL ${TankTTL} 
    |/echo TotalTankTime ${TotalTankTime} TotalTankHits ${TotalTankHits}
    |}

    /varset TankLastPct ${Spawn[ID ${MainTankID}].PctHPs}
    /if (${tmpTarget}) {
        /target targetable id ${tmpTarget}
        /delay 1
		}
	/return
	
Sub ClearCursor
    /declare i int local
    :auto_inv
    /if (${Cursor.ID}) {
		/if (${Cursor.Container}) {
			|---- Inventory Bag Slots
			/for i 1 to 10   
            /if (!${InvSlot[pack${i}].Item.Container}) /nomodkey /itemnotify pack${i} leftmouseup
			/next i
			|---- Inventory Bag Slots   
			} else {
			/timed 5 /autoinventory
			}
		/goto :auto_inv
		}
	/return	
	
Sub ClickRods
	|I am a mage
	|I do not have a rod in inventory
	|I do not have something on cursor
	|Summon a rod
	/if (!${RDPause} && ${Me.Class.ShortName.Equal[MAG]} && !${FindItem[Wand of Pelagic Modulation].ItemSlot} && !${FindItem[Summoned: Giant Modulation Shard].ItemSlot} && !${FindItem[Summoned: Large Modulation Shard].ItemSlot} && !${FindItem[Summoned: Medium Modulation Shard].ItemSlot} && !${FindItem[Summoned: Small Modulation Shard].ItemSlot} && !${FindItem[Want of Phantasmal Transvergence].ItemSlot} &&!${FindItem[Wand of Phantasmal Modulation].ItemSlot} && !${FindItem[Rod of Arcane Transvergence].ItemSlot} && !${FindItem[Rod of Spectral Transvergence].ItemSlot} && !${FindItem[Wand of Temporal Mastery].ItemSlot} && !${FindItem[Rod of Mechamagical Mastery].ItemSlot} && !${FindItem[Rod of Ethereal Transvergence].ItemSlot} && !${FindItem[Rod of Prime Transvergence].ItemSlot} && !${FindItem[Wand of Elemental Transvergence].ItemSlot} && !${FindItem[Rod of Mystical Transvergence].ItemSlot} && !${FindItem[Summoned: Modulating Rod].ItemSlot} && !${Cursor.ID}) {
		/target myself
		/call MQ2Cast "${Spell[${RodSpell}].RankName}" ${RodGem} 5s  SpellFiller 3
		/delay 2s ${Cursor.ID}
		}
	|99783 = Wand of Palegic Transvergence
	|99782 = Wand of Pelagic Modulation
	|79497 = Summoned: Giant Modulation Shard
	|79322 = Summoned: Large Modulation Shard
	|79321 = Summoned: Medium Modulation Shard
	|79320 = Summoned: Small Modulation Shard
	|76503 = Wand of Phantasmal Transvergence
	|76502 = Wand of Phantasmal Modulation
	|64951 = Rod of Arcane Transvergence
	|57264 = Rod of Spectral Transvergence
	|52888 = Wand of Temporal Mastery
	|52803 = Rod of Mechamagical Mastery
	|52709 = Rod of Prime Transvergence
	|52674 = Wand of Elemental Transvergence   
	|18745 = Rod of Ethereal Transvergence
	|6346 = Summoned: Modulating Rod   
	|3426 = Rod of Mystical Transvergence
	/if (${Select[${Cursor.ID},99783,99782,79322,79321,79320,76503,76502,64951,57264,52888,52803,52709,52674,18745,6346,3426]}) /autoinv
	|I am not paused
	|My mana is below RodMana
	|I have a rod in inventory and it does not have a timer
	|Click a rod
	/if (!${RDPause} && ${Me.PctMana}<${RodMana} && ${Me.PctHPs}>30) {
		/if (${FindItem[Summoned: Giant Modulation Shard].ID} && !${FindItem[Summoned: Giant Modulation Shard].TimerReady} && ${Me.CurrentHPs}>30100) /useitem "Summoned: Giant Modulation Shard" 
		/if (${FindItem[=Wand of Pelagic Modulation].ID} && !${FindItem[Wand of Pelagic Modulation].TimerReady} && ${Me.CurrentHPs}>12850) /useitem "Wand of Pelagic Modulation" 
		/if (${FindItem[=Wand of Pelagic Transvergence].ID} && !${FindItem[Wand of Pelagic Transvergence].TimerReady} && ${Me.CurrentHPs}>3594) /useitem "Wand of Pelagic Transvergence" 
		/if (${FindItem[Summoned: Large Modulation Shard].ID} && !${FindItem[Large Modulation Shard].TimerReady} && ${Me.CurrentHPs}>23100) /useitem "Summoned: Large Modulation Shard" 
		/if (${FindItem[Summoned: Medium Modulation Shard].ID} && !${FindItem[Medium Modulation Shard].TimerReady} && ${Me.CurrentHPs}>15100) /useitem "Summoned: Medium Modulation Shard" 
		/if (${FindItem[Summoned: Small Modulation Shard].ID} && !${FindItem[Small Modulation Shard].TimerReady} && ${Me.CurrentHPs}>7600) /useitem "Summoned: Small Modulation Shard" 
		/if (${FindItem[=Wand of Phantasmal Modulation].ID} && !${FindItem[Wand of Phantasmal Modulation].TimerReady} && ${Me.CurrentHPs}>11100) /useitem "Wand of Phantasmal Modulation" 
		/if (${FindItem[=Wand of Phantasmal Transvergence].ID} && !${FindItem[Wand of Phantasmal Transvergence].TimerReady} && ${Me.CurrentHPs}>3138) /useitem "Wand of Phantasmal Transvergence" 
		/if (${FindItem[=Rod of Arcane Transvergence].ID} && !${FindItem[Rod of Arcane Transvergence].TimerReady} && ${Me.CurrentHPs}>2530) /useitem "Rod of Arcane Transvergence" 
		/if (${FindItem[=Rod of Spectral Transvergence].ID} && !${FindItem[Rod of Spectral Transvergence].TimerReady} && ${Me.CurrentHPs}>1720) /useitem "Rod of Spectral Transvergence" 
		/if (${FindItem[=Rod of Ethereal Transvergence].ID} && !${FindItem[Rod of Ethereal Transvergence].TimerReady} && ${Me.CurrentHPs}>1320) /useitem "Rod of Ethereal Transvergence" 
		/if (${FindItem[=Rod of Prime Transvergence].ID} && !${FindItem[Rod of Prime Transvergence].TimerReady} && ${Me.CurrentHPs}>1000) /useitem "Rod of Prime Transvergence" 
		/if (${FindItem[=Wand of Elemental Transvergence].ID} && !${FindItem[Wand of Elemental Transvergence].TimerReady} && ${Me.CurrentHPs}>920) /useitem "Wand of Elemental Transvergence"  
		/if (${FindItem[=Rod of Mystical Transvergence].ID} && !${FindItem[Rod of Mystical Transvergence].TimerReady} && ${Me.CurrentHPs}>550) /useitem "Rod of Mystical Transvergence" 
		/if (${FindItem[=Rod of Mechamagical Mastery].ID} && !${FindItem[Rod of Mechamagical Mastery].TimerReady} && ${Me.CurrentHPs}>1400) /useitem "Rod of Mechamagical Mastery" 
		/if (${FindItem[=Wand of Temporal Mastery].ID} && !${FindItem[Wand of Temporal Mastery].TimerReady} && ${Me.CurrentHPs}>1686) /useitem "Wand of Temporal Mastery" 
		/if (${FindItem[=Summoned: Modulating Rod].ID} && !${FindItem[Summoned: Modulating Rod].TimerReady} && ${Me.CurrentHPs}>325) /useitem "Summoned: Modulating Rod" 
		}
   /call MoveStuff
/return	

Sub CureMe
	/if (!${DoCures}) /return
	/declare i int local
	/for i 1 to ${CureTotal}
		/if ((!${RDPause} && ((${Debuff.Cursed} && ${Debuff.Cursed}<=${CurseCounters${i}}) || (${Debuff.Diseased} && ${Debuff.Diseased}<=${DiseaseCounters${i}}) || (${Debuff.Poisoned} && ${Debuff.Poisoned}<=${PoisonCounters${i}}) || (${Debuff.Corrupted} && ${Debuff.Corrupted}<=${CorruptionCounters${i}}))) && ((${Me.SpellReady[${CureSpell${i}}]} || (!${Me.Gem[${CureSpell${i}}]} && ${Me.Book[${CureSpell${i}}]})) || ${Me.AltAbilityReady[${CureSpell${i}}]} || (${CureGem${i}.Equal[item]} && !${FindItem[${CureSpell${i}}].Timer}))) {
        
			/target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			/if (${ReportCures}) /call AnnounceMessage "${ChatChannel}"  4 g "Casting CureSpell-" t "${CureSpell${i}}" g "on" m "myself"
			/call MQ2Cast "${CureSpell${i}}" ${CureGem${i}} 1s Check4Pad
		}
	/next i
	/return
	
|-----------------------------
|taken from Dead2SK, author unknown
|------------------------------
	
Sub CreateCampfire
	/if (!${RDPause}) {
		/windowstate FellowshipWnd open
		/delay 5s
		/nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
		/nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
		/delay 5s ${Window[ConfirmationDialogBox].Open}
		/if (${Window[ConfirmationDialogBox].Open}) {
			/nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
			}
		/delay 2s
		/nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
		/delay 1s        
		/nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect 1
		/delay 1s
		/nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
		/delay 5s
		/windowstate FellowshipWnd close
		/call AnnounceMessage "${ChatChannel}" 2 g "Made a" r "CAMPFIRE!" 
		}
	/return

Sub CreateTimer(MyTimer,MyLength)
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[${MyTimer}]}) /declare ${MyTimer} timer outer
	/if (${MyLength.NotEqual[NULL]}) /varset ${MyTimer} ${MyLength}
	/return	
	
Sub Connect
	/if (${UseIRC}==TRUE && ${Irc}==FALSE) {
		/if (${IRCConnect}>0) /return
		/i quit
		/iconnect ${IRCAddress} ${IRCPort} ${IRCChannel} ${Me.Name}
		/varset IRCConnect 20s
	}
	/if (!${EQBC.Connected}) {
		/bccmd connect ${EQBC.Server}
	}
	/return	

Sub DebuffCommon(int a, int i)
	/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${AssistTimer}) /call PetAttackStuff
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
	/if (${DoCombatStuff} && ${Me.CombatState.Equal[COMBAT]} && !${CombatStuffTimer}) /call DoStuff Combat
	/if ((${MobList[${a}]}!=${MATarget}) && ((!${MADebuffed} && ${DebuffMAFirst}) || ${DebuffMAOnly${i}})) /return
	/if (!${RDPause} && (${Me.Class.ShortName.Equal[BRD]} || !${Me.Casting.ID}) && ${Spawn[${MobList[${a}]}].LineOfSight} && ${Spawn[${MobList[${a}]}].Standing}  && (${WhichNuke}==${DebuffSpellSet${i}} || !${DebuffSpellSet${i}}) && ${DebuffArray[${a},${i}]}<=${Macro.RunTime} && ${MobList[${a}]} && (${NearestSpawn[npc targetable named].ID}==${MobList[${a}]} || !${DebuffNamedOnly${i}})) {
		/if (!${${DebuffID[${i}]}Immune.Find[|${Spawn[${MobList[${a}]}].CleanName}|]} && (${Spawn[${MobList[${a}]}].Distance}<${Int[${Spell[${DebuffID[${i}]}].MyRange}]} || !${Spell[${DebuffID[${i}]}].MyRange})) {
			/if ((${Me.PctMana}>=${DebuffMana${i}} && !${Select[${DebuffGem${i}},item,alt]} && (!${SitTimer} || ${Me.Gem[${DebuffSpell${i}}]} || ${Me.Mount.ID})) || ${Me.AltAbilityReady[${DebuffSpell${i}}]} || (${FindItem[${DebuffSpell${i}}].ID} && !${FindItem[${DebuffSpell${i}}].TimerReady})) {
			/if ((${DoDebuffs} && !${SpellType${i}}) || (${DoDoTs} && ${SpellType${i}}==1) || (${DoManaTaps} && ${SpellType${i}}==3 && (${Spawn[${MobList[${a}]}].Class.CanCast} || ${Zone.ID}>=400))) /call DebuffStuff ${a} ${i}
			}
		}
	}
	/return
	
Sub DebuffIt
	/if (${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}!=${LastSpawnCount} || (${PetID} && !${Me.Pet.ID}) || (!${PetID} && ${Me.Pet.ID})) /call PopulateNPCs
	/call AssistMA1
	/varset MADebuffed FALSE
	/declare i int local
	/declare a int local
	/declare localMaxMobs int local ${MaxMobs}
	| loop through and find the MATarget in MobList if DebuffMAFirst
	/if (${DebuffMAFirst} || ${MADebuffOnly}) {
		/for a 1 to ${localMaxMobs}
			/if (${a}>30) /break
			/if (${a}<1) /break
			/if (${MobList[${a}]} && ${MobList[${a}]}==${MATarget}) {
				/for i 1 to ${DebuffTotal}
					/call DebuffCommon ${a} ${i}
				/next i
				/goto :continuedebuffs
			}
		/next a
	}
:continuedebuffs
	/varset MADebuffed TRUE
	/if (${MADebuffOnly}) /goto :enddebuffs

	/if (${AllDebuffsFirst}) {
		/for a 1 to ${localMaxMobs}
			/if (${a}>30) /break
			/if (${a}<1) /break
			/if (${MobList[${a}]} && ${Spawn[${MobList[${a}]}].ID}) {
				/for i 1 to ${DebuffTotal}
					/if (${SpellType${i}}==0 || ${SpellType${i}}==1 || ${SpellType${i}}==3) /call DebuffCommon ${a} ${i}
				/next i
			}
		/next a
	} else {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==0 || ${SpellType${i}}==1 || ${SpellType${i}}==3) {
			/for a 1 to ${localMaxMobs}
				/if (${a}>30) /break
				/if (${a}<1) /break
				/if (${MobList[${a}]} && ${Spawn[${MobList[${a}]}].ID}) /call DebuffCommon ${a} ${i}
			/next a
			}
		/next i
	}
	:enddebuffs
	/call MoveStuff
/return

Sub DebuffStuff(int a,int i)
	/declare x int local
	/declare DebuffDuration int local
	/declare DOTBurnDurationPenalty int local
:RecastDebuff
	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
	/if (${Me.Combat} && ${MobList[${a}]}!=${MATarget}) {
		/attack off
		}
	/delay 1s !${Melee.Combat} || ${MobList[${a}]}==${MATarget}
	/if (${Target.ID}!=${MobList[${a}]}) {
		/target targetable id ${MobList[${a}]}
		}
	/delay 1s ${Target.ID}
	/if (${Target.ID}!=${MobList[${a}]}) {
		/return
		}
|-----Check to be sure your toon has the DeBuff spell, item, or AA	
	/if (!${Select[${DebuffGem${i}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${DebuffSpell${i}}].RankName}]}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ay not in spellbook.
		}
	/if (${DebuffGem${i}.Equal[item]} && !${FindItem[${DebuffSpell${i}}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ay is marked as an item and not in inventory.
		}
	/if (${DebuffGem${i}.Equal[alt]} && !${Me.AltAbility[${DebuffSpell${i}}].ID}) {
		/echo Debuff \ag ${i} \am ${DebuffSpell${i}} \ao is marked as an AA, you don't appear to have.
		}
|-----	
	/delay 10s ${Target.BuffsPopulated}
	/call EvaluateCondition "${DebuffCondition${i}}"
	/if (!${Macro.Return}) {
		/return
		}
	/if ((!(${UseHoTT} && !${Me.TargetOfTarget.ID})) && ((${Target.PctHPs}<=${DebuffHPs${i}} || ${SpellType${i}}==2 || ${SpellType${i}}==4 || ${SpellType${i}}==5) && ${Target.PctHPs}>${DebuffStopHPs${i}}) && ${Target.Type.Equal[NPC]}) {
|-----	Bard section
		/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${DebuffGem${i}},item,alt]} && ${Me.Gem[${DebuffSpell${i}}]}) {
			/varset x ${DebuffRecast${i}}
			/call DoCastingEvents
:bardrecast
			/if (${Faded} && ${Me.Invis}) {
				/return
				}
			/squelch /twist once ${Me.Gem[${DebuffSpell${i}}]}
			/varset castReturn CAST_SUCCESS
			/delay ${Spell[${DebuffSpell${i}}].MyCastTime.TotalSeconds}s
			/delay 1s
			/call DoCastingEvents
			/if (${castReturn.Equal[CAST_RESISTED]} && ${x}) {
				/multiline ; /varcalc x ${x}-1;/goto :bardrecast
				}
|-----	End Bard section
			} else {
			/if ((${Me.Class.ShortName.NotEqual[BRD]} || ${Select[${DebuffGem${i}},item,alt]}) && ${Me.Casting.ID}!=${DebuffID[${i}]} && ${DebuffArray[${a},${i}]}<=${Macro.RunTime}) {
				/if (${Me.Class.ShortName.Equal[BRD]}) {
					/squelch /twist stop		 		 		 
					}
|				/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${DebuffID[${i}]}) {
					/call DoInterrupt
					}
|:RecastDebuff
				/call MQ2Cast "${DebuffSpell${i}}" ${DebuffGem${i}} 3s Check4Pad ${DebuffRecast${i}}
				/delay 5s !${Me.Casting.ID}
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) {
					/call SingSongs
					}
				}
			}
		/if (${castReturn.Equal[CAST_RESISTED]} && ${SpellType${i}}==2 && !${Target.Type.Equal[corpse]}) {
			/goto :RecastDebuff
			}
		/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]} && !${Target.Type.Equal[corpse]} && ((${SpellType${i}}!=2 && ${SpellType${i}}!=4) || (!${Target.Assist} && ${Target.ID}!=${MATarget}))) {
		/goto :RecastDebuff
			}
		/if (${Select[${castReturn},CAST_IMMUNE,CAST_RESISTED,CAST_TAKEHOLD]}) {
			/if (${castReturn.Equal[CAST_IMMUNE]}) {
				/if (((${ReportDebuffs} && !${SpellType${i}}) || (${ReportDoTs} && ${SpellType${i}}==1) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Target.ID} && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]}) {
					/call AnnounceMessage "${DebuffChannel}" 4 r "Warning!" y "${Spawn[${MobList[${a}]}].CleanName}" r "is IMMUNE to" o "${DebuffSpell${i}}"
					}
				/varset ${DebuffID[${i}]}Immune ${${DebuffID[${i}]}Immune}${Spawn[${MobList[${a}]}].CleanName}|
		 		/ini RDCommon.ini ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune "${${DebuffID[${i}]}Immune}"
				}
		 	/if (${castReturn.Equal[CAST_RESISTED]} && ((${ReportDebuffs} && !${SpellType${i}}) || (${ReportDoTs} && ${SpellType${i}}==1) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Target.ID} && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]}) {
				/call AnnounceMessage "${DebuffChannel}" 3 y "${Spawn[${MobList[${a}]}].CleanName}" r "RESISTED" o "${DebuffSpell${i}}." "--"
				}
		 	/varcalc DebuffArray[${a},${i}] ${Macro.RunTime}+10000
			}		 
		/if (${castReturn.Equal[CAST_SUCCESS]}) {
		 	/varset Parse ${DebuffMessage${i}}
		 	/if (${DebuffMessage${i}.Find[%Target]}) {
				/Call ParseMessage "%Target" "${Spawn[${MobList[${a}]}].CleanName}"
				}
		 	/if (${DebuffMessage${i}.Find[%Spell]}) {
				/Call ParseMessage "%Spell"  "${DebuffSpell${i}}"
				}
		 	/if (${DebuffMessage${i}.Find[%Duration]}) {
				/Call ParseMessage "%Duration"  "${Target.BuffDuration[${DebuffSpell${i}}].TotalSeconds}"
				}
			/if (((${ReportDebuffs} && !${SpellType${i}} && ${Parse.NotEqual[None]}) || (${ReportDoTs} && ${SpellType${i}}==1  && ${Parse.NotEqual[None]}) || (${ReportMez} && (${SpellType${i}}==2 || ${SpellType${i}}==4))) && ${Spawn[${MobList[${a}]}].Type.Equal[NPC]} && ${Parse.NotEqual[None]}) /${DebuffChannel} ${Parse}
			/if (!${Spell[${DebuffID[${i}]}].Duration}) {
				/varset DebuffDuration 10003
				} else {
				/varset DebuffDuration ${Spell[${DebuffID[${i}]}].Duration.TotalSeconds}
				/if (${SpellType${i}}==1) { 
					| For a necro who's burning using "Funeral Pyre" AA, dot durations are shortened.
					/docommand ${If[${Me.Song[Smoldering Fury].ID},/varset DOTBurnDurationPenalty 50,/varset DOTBurnDurationPenalty 0]}
					/if (${DebuffDuration}>=24) {
						/varcalc DebuffDuration (${DebuffDuration}*((${DoTDurFocus}-${DOTBurnDurationPenalty}+200)/200)+${DoTDurAASecs})
						}
					/if (${DebuffDuration}<${Spell[${DebuffID[${i}]}].RecastTime.TotalSeconds}) {
						/varcalc DebuffDuration ${Spell[${DebuffID[${i}]}].RecastTime.TotalSeconds} + 3
						}
					}
				/if ((${SpellType${i}}==2) || (${SpellType${i}}==4)) /varcalc DebuffDuration (${DebuffDuration}+${MezDurAASecs})
				}
			/varcalc DebuffArray[${a},${i}] ${Macro.RunTime}+${DebuffDuration}-3
			}
		/varset castReturn CAST_CANCELLED
		}
	/doevents
	/if (!${Melee.Combat} && ${Target.ID}==${MATarget}) {
		/call AssistMA1
		}
	/return
	
Sub Delayer
	/delay 1s
	/return	

Sub DelSong(LowGem,HighGem,TwistType,Song)
	/declare i    int    local
	/declare k    int    local
	/declare flag int    local
	/if (!${Spell[${Song}].RankName.ID}) {
		/if (${Ini[${RDIni},"Bard-Aliases",${Song},NOTFOUND].Equal[NOTFOUND]}) {
			/call AnnounceMessage "${ChatChannel}"  4 y "song-" o "${Song}" y "not found. Song" r "NOT REMOVED"
			/return
			}
		/call AnnounceMessage "${ChatChannel}"  o "${Song}" g "-->" y "${Ini[${RDIni},"Bard-Aliases",${Song}]}"
		/varset Song ${Ini[${RDIni},"Bard-Aliases",${Song}]}
		}
	/for i ${LowGem} to ${HighGem}
		/if (${Song.Equal[${Ini[${RDIni},"Bard-${TwistType}",SongsArray${i},NOTFOUND]}]}) /varset flag ${i}
	/next i
	/if (${flag}>=${LowGem} && ${flag}<${HighGem}) {
		/for i ${flag} to ${HighGem}
			/varset k ${Math.Calc[${i}+1]}
			/if (${i}<${HighGem}) {
				/varset SongsArray${i} ${SongsArray${k}}
				/ini "${RDIni}" "Bard-${TwistType}" "SongsArray${i}" "${SongsArray${i}}"
			}
			/if (${i}==${HighGem}) {
				/varset SongsArray${HighGem} Song Name
				/ini ${RDIni} "Bard-${TwistType}" "SongsArray${HighGem}" "Song Name"
			}
		/next i
	}
	/if (${flag}==${HighGem}) {
		/varset SongsArray${HighGem} Song Name
		/ini "${RDIni}" "Bard-${TwistType}" "SongsArray${HighGem}" "Song Name"
	}
	/if (${flag}) {
		/call AnnounceMessage "${ChatChannel}"  4 g "Song:" o "${Song}" r "DELETED from the" y "${TwistType} Twist"
		/call GetFreeGems
		/call SetTwists
		/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs 1
		/call Event_ListSongs none All
		/return
		}
	/call AnnounceMessage "${ChatChannel}" 4 o"${Song}" r "NOT FOUND" y "in ${TwistType} twist," r "song NOT DELETED!"
	/call Event_ListSongs none All
	/return

Sub DestroyBag
	/declare j int local
|========================================	
| Make sure bag has no items other than summoned in it before deleting.
|========================================
	/if (${InvSlot[pack${BagNum}].Item.Items}) {
		/for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
		/if (!${InvSlot[pack${BagNum}].Item.Item[${j}].NoRent} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
			/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${ChatChannel}"	2 y "Bag has non summoned item(s) in it. Aborting delete." r "Pet Toys Off"
			/varset DoPetToys 0
			/return
			}
		/next j
        }
	/if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) {
		/nomodkey /itemnotify pack${BagNum} leftmouseup
		/delay 5s ${Cursor.ID}
		/if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
		/delay 20 !${Cursor.ID}
        }
	/return
	
Sub DiscStuff(int DiscCall)
	/declare i int local
	/for i 1 to ${DiscTotal}
		/if (!${RDPause} && ${Window[CombatAbilityWnd].Child[CAW_CombatEffectLabel].Text.Equal["No Effect"]} && ${Me.PctEndurance}>${DiscEndurance${i}} && ${Me.CombatAbilityReady[${DiscName${i}}]} && ${DiscSpawnCount${i}}>=${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1 playerstate 4]} && ${DiscType${i}}==${DiscCall} && ((${DiscType${i}} && ${Target.ID}==${MATarget} && ${Target.PctHPs}<=${DiscMinHPs${i}} && ${Target.PctHPs}>=${DiscMaxHPs${i}} && ${Melee.Combat}) || (!${DiscType${i}} && ${Me.PctHPs}<=${DiscMinHPs${i}} && ${Me.PctHPs}>=${DiscMaxHPs${i}}))) {
			/disc ${DiscName${i}}
			/return
		}
	/next i
	/return



Sub DoAEHeal
	/declare i            int local
	/declare PCArray[100] int local
	/declare PCsInRange   int local ${SpawnCount[pc radius ${PCRadius} zradius ${PCZRadius}]}
	/for i 1 to ${PCsInRange}
		/varset PCArray[${i}] ${NearestSpawn[${i}, pc].ID}
	/next i
	/for i 1 to ${PCsInRange}
		/if (${Me.CurrentMana}<${Spell[${FastHealID}].Mana}) /return
		/if (!${RDPause} && ${Spawn[${PCArray[${i}]}].Type.NotEqual[corpse]} && ${Spawn[${PCArray[${i}]}].Type.NotEqual[untargetable]}) {
			/target targetable id ${PCArray[${i}]}
			/delay 3
			/call ShouldIHeal
		}
	/next i
	/return	
	
Sub DoAssistHeal
	/declare i            int local
	/declare NPCArray[50] int local
	/declare NPCsInRange  int local ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}
	/for i 1 to ${NPCsInRange}
		/if (!${i}) /return
		/varset NPCArray[${i}] ${NearestSpawn[${i}, npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4].ID}
	/next i
	/for i 1 to ${NPCsInRange}
		/if (${Me.CurrentMana}<${Spell[${FastHealID}].Mana}) /return
		/if (!${RDPause} && ${Spawn[${NPCArray[${i}]}].LineOfSight} && ${Spawn[${NPCArray[${i}]}].Type.NotEqual[corpse]} && ${Spawn[${NPCArray[${i}]}].Standing} && ${Spawn[${NPCArray[${i}]}].Type.NotEqual[untargetable]}) {
			/squelch /target targetable id ${NPCArray[${i}]}
			/delay 5s ${Target.ID}==${NPCArray[${i}]} && ${Me.AssistComplete}==TRUE
			/assist
			/delay 5s ${Target.Type.Equal[PC]} && ${Me.AssistComplete}==TRUE
			/call ShouldIHeal
		}
	/next i
	/return

Sub DoBuffEvents
	/if (${Debug}) /echo \ag Entering \ao DoBuffEvents sub
	/if (${Cursor.ID}) /autoinventory
	/declare a int local 1
|	/declare TempVar int local ${Math.Calc[${DoBuffTotal}+1]}	
	/declare TempVar int local ${If[${Bool[${DoBuffTotal}]}, ${DoBuffTotal}, ${Math.Calc[${DoBuffTotal}+1]}]}
|	/declare TempVar int local ${DoBuffTotal}
	/declare TempGuy int local 0
	/doevents WornOff
	/for a 1 to 25
|		/if (${Debug}) /echo QueueCount = ${QueueCount}( ${DoBuffQueue[${a},2]} <= ${TempVar} and ${Spawn[${DoBuffQueue[${a},1]}].ID} and ( ${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].Name.Find[Illusion:]} or ${Spawn[${DoBuffQueue[${a},1]}].Distance} < ${Int[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].MyRange}]} or ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].AERange} ) )
		/if (${DoBuffQueue[${a},2]}<=${TempVar} && ${Spawn[${DoBuffQueue[${a},1]}].ID} && (${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].Name.Find[Illusion:]} || ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Int[${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].MyRange}]} || ${Spawn[${DoBuffQueue[${a},1]}].Distance}<${Spell[${DoBuffID[${DoBuffQueue[${a},2]}]}].AERange})) {
			/varset TempGuy ${DoBuffQueue[${a},1]}
			/varset TempVar ${DoBuffQueue[${a},2]}
			/if (${Debug}) {
				/echo \ao DoBuff Que - \ag TempGuy \am ${Spawn[${TempGuy}].CleanName} \ag Buff \ay ${DoBuffQueue[${a},2]} and a= ${a}
				}
			}
		/if (${Defined[RezBuff${DoBuffQueue[${a},2]}]}) {
			/if (!(${Spawn[${DoBuffQueue[${a},1]}].Type.Equal[corpse]} ^^ ${RezBuff${DoBuffQueue[${a},2]}})) {
				/varset TempGuy ${DoBuffQueue[${a},1]}
				/varset TempVar ${DoBuffQueue[${a},2]}
				/if (${Debug}) /echo \ao DoBuff Que REZ section - \ag TempGuy \am ${Spawn[${TempGuy}].CleanName} \ag Buff \ay ${DoBuffQueue[${a},2]}			
				}
			}	
	/next a
	/if (${Debug}) /echo \ao DoBuffQueue set 
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
|-----Check to be sure your toon has the DoBuff spell, item, or AA
	/if (!${Select[${DoBuffGem${TempVar}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${DoBuff${TempVar}}].RankName}]}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} not in spellbook.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
	/if (${DoBuffGem${TempVar}.Equal[item]} && !${FindItem[${DoBuff${TempVar}}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} is marked as an item and not in inventory.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
	/if (${DoBuffGem${TempVar}.Equal[alt]} && !${Me.AltAbility[${DoBuff${TempVar}}].ID}) {
		/echo \ar DoBuff -${TempVar}- ${DoBuff${TempVar}} is marked as an AA, you don't appear to have.
		/call RemoveFromQueue ${TempGuy} ${TempVar}
		}
|-----
	/if ((${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && ${BattleBuff${TempVar}}==1) || (${BattleBuff${TempVar}}==2 && ${Me.CombatState.Equal[COMBAT]}) || ${Select[${DoBuffGem${TempVar}},item,alt]} || (${Me.Gem[${DoBuff${TempVar}}]} && ${BattleBuff${TempVar}}!=2) || (!${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && ${BattleBuff${TempVar}}!=2)) {
		/if (${Debug}) /echo \ao DoBuff - passed battlebuff check or spawn check Target= \ay ${Spawn[${TempGuy}].CleanName} \ag DoBuff \ay ${DoBuff${TempVar}}
		/if (${TempGuy}) {
			/if (((${Me.SpellReady[${DoBuff${TempVar}}]} || !${Me.Gem[${DoBuff${TempVar}}]} || ${Spell[${DoBuffID[${TempVar}]}].RecastTime}<30) && ${Me.CurrentMana}>${Spell[${DoBuffID[${TempVar}]}].Mana} && ${Me.PctMana}>=${DoBuffMana${TempVar}}) && (!${Select[${DoBuffGem${TempVar}},item,alt]} || (${DoBuffGem${TempVar}.Equal[item]} && ${FindItem[${DoBuff${TempVar}}].TimerReady}<30) || (${DoBuffGem${TempVar}.Equal[alt]} && ${Me.AltAbilityReady[${DoBuff${TempVar}}]}))) {
				/if (${Debug}) /echo \ao DoBuff there is a target, and the spell is ready
				/squelch /target targetable id ${TempGuy}
				/delay 1s ${Target.ID}==${TempGuy}
				/if (${Target.ID}==${TempGuy}) {
					/if (${DoBuffTells}) /tt ${Spell[${DoBuffID[${TempVar}]}].Name}
					/if (${ReportDoBuffs} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Buffing" o "${Spell[${DoBuffID[${TempVar}]}].Name}" g "on" m "${Spawn[${TempGuy}].CleanName}"
					/doevents flush Restricted
					/call MQ2Cast "${DoBuff${TempVar}}" ${DoBuffGem${TempVar}} 30s Check4Pad
					/call DoRestrictedEvents ${DoBuffID[${TempVar}]}
					/delay 10s !${Me.Casting.ID}
					/if (${Select[${castReturn},CAST_SUCCESS,CAST_TAKEHOLD,CAST_NOTHOLD]}) {
						/if (${Debug}) /echo \ao DoBuff Cast sucessful or did not take hold
						/if (${castReturn.Equal[CAST_SUCCESS]} || ${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
							/if (${Select[${Spell[${DoBuff${TempVar}}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]} && (${Group.Member[${Spawn[${TempGuy}].CleanName}].Index} || ${Group.Member[${Spawn[${TempGuy}].Master.CleanName}].Index} || ${Target.Type.Equal[Pet]} || ${Target.Type.Equal[Mercenary]})) /varset TempGuy 0
							/call RemoveFromQueue ${TempGuy} ${TempVar}
							} else {
								/call RemoveFromQueue ${TempGuy} ${TempVar}
								}
						/call AutoSit
						}
					}
				}
			}
	}
	/varset DoBuffTimer 10s
/return
	
Sub DoDivArb
	/if ((!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) || (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID})) {
		/if (${Me.Casting.ID}) /call DoInterrupt
		/if (${FindItem[Harmony of the Soul].ID}) /call MQ2Cast "Harmony of the Soul" item 5s SpellFiller 3
		/if (${FindItem[Aegis of Superior Divinity].ID}) /call MQ2Cast "Aegis of Superior Divinity" item 5s SpellFiller 3
		} else /if ((${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) || (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) || (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer}))) {
		/if (${Me.Casting.ID} && ${Me.Casting.ID}!=${DivArbSpellID}) /call DoInterrupt
		/call MQ2Cast "${DivArbSpell}" ${DivArbGem} 5s SpellFiller 3
		}
	/if (!${Select[${DivArbGem},alt,item]} && ${Spell[${DivArbSpell}].RankName.ID}) /varset DivArbTimer ${Spell[${DivArbSpell}].RecastTime.TotalSeconds}s
	/varset StayOnHealTimer ${StayOnHeal}
	/return	

Sub DoHeal(int HealGuy,HealType)
	/if (${HealDebug}) /echo DoHeal ${HealGuy} ${HealType}
	/if (${Me.Casting.ID} && !${Select[${Me.Casting.ID},${DivArbSpellID},${GroupHealID},${FastHealID},${TankHealID},${DelayedHealID},${PetHealID}]}) {
		/call DoInterrupt
		/if (${HealDebug}) /echo Interupt called
		/delay 1s !${Me.Casting.ID}
		}
	/if (${Target.ID}!=${HealGuy}) /target targetable id ${HealGuy}
	/delay 1s ${Target.ID}==${HealGuy}
|-----If tankheal is not ready, switch to caster heal.
	/if (${HealType.Equal[Tank]} && !${Me.SpellReady[${Spell[${TankHeal}].RankName}]}) /varset HealType Fast
	/if (${HealType.Equal[Fast]}) /varset StartHPs ${Target.PctHPs}
	/if (${Target.ID}==${HealGuy} && ${Spawn[${HealGuy}].Type.NotEqual[corpse]}) {
		/call MQ2Cast "${Spell[${${HealType}Heal}].RankName}" ${${HealType}HealGem} 5s CheckHP
		/if (${HealDebug}) /echo casting ${${HealType}Heal} ${${HealType}HealGem} 
		}
|	/if (${HealType.Equal[Fast]} && ${Target.ID}==${HealGuy} && ${Target.PctHPs}<${StartHPs}+5 && ${Target.PctHPs}>=${StartHPs}) {
|		/varset DAArray[${WorstMember},1] ${StartHPs}
|		/varset DAArray[${WorstMember},2] 1
|		}
	/varset SpamFlag FALSE
	/varset StayOnHealTimer ${StayOnHeal}
	/varset WorstHPs 100
	/call DoCastingEvents
	/varset castReturn CAST_CANCELLED
|	/target clear
	/return	
	
Sub DoInterrupt
	/if (${Me.Casting.ID}) {
		/if (${Defined[ReportInterrupts]}) {
			/if (${ReportInterrupts}) /call AnnounceMessage "${ChatChannel}"  4 r "Interrupting" o "${Me.Casting}" g "being cast at" m "${Target.CleanName}"
			}
		/call Interrupt
		/delay 1s !${Me.Casting.ID}
		}
	/return
	
Sub DoMelee
	/if (!${DoMelee}) /return
	/declare i int local
	/if (${Target.Type.Equal[corpse]} && ${Melee.Combat}) {
		/target clear
		/return
	}
	/if (!${RDPause}) {
		/if (${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${Spawn[${MATarget}].Distance}<${NPCRadius} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && ${Spawn[${MATarget}].LineOfSight} && ${UseEpic} && (!${FindItem[${Epic}].Timer} && ${FindItem[${Epic}].ID}) && ${UseEpic}<=${SpawnCount[npc targetable radius ${NPCRadius} zradius 50 noalert 1 playerstate 4]} && (${Me.Class.ShortName.Equal[BRD]} || !${Me.Casting.ID})) {
			/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
			/if (${Me.Casting.ID}) {
				/call DoInterrupt
				}
			/call MQ2Cast "${Epic}" item 2s SpellFiller 3
			/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs
		}
		/if (${Spawn[${MATarget}].Type.NotEqual[Corpse]} && ${Spawn[${MATarget}].Distance}<${NPCRadius} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && ${Spawn[${MATarget}].LineOfSight} && (${DoMelee} || ${DoRanged} || (${DoCharm} && ${Me.Pet.ID}) || (${UsePet} && ${Me.Pet.ID})) && !${Me.Moving} && (${MATarget}!=${Melee.Target} || ${Target.ID}!=${MATarget})) {
			/if (${Target.ID}!=${MATarget}) /target targetable id ${MATarget}
			/delay 1s ${Target.ID}==${MATarget}
			/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
			/stick off
			/if (${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist}) {
				/face fast
				/autofire
				}
			/if ((!${DoRanged} || ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) /squelch /killthis
			/if (${PetAttack} && ${Me.Pet.ID} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${AssistTimer} && (!${Me.Pet.Target.ID} || ${Me.Pet.Target.ID}!=${Spawn[${MATarget}].ID})) {
				/pet back off
				/call PetAttackStuff
				}
		}
		/if (${UseDiscs}) /call DiscStuff 1
		/if (${Defined[DoShield]}) {
			/if (${DoShield} && !${ShieldTimer}) {
				/for i 1 to ${Group}
					/if (${Window[CombatAbilityWnd].Child[CAW_CombatEffectLabel].Text.Equal["No Effect"]} && ${Group.Member[${i}].PctHPs}<${ShieldHPs} && ${Group.Member[${i}].Distance}<=${ShieldRange} && (${ShieldClasses.Find[|${Group.Member[${i}].Class.ShortName}|]} || ${ShieldClasses.Equal[All]})) {
						/shield ${Group.Member[${i}].CleanName}
						/varset ShieldTimer 3m
						/return
						}
					/next i
				}
			}

		}
	/if (${Mercenary.State.Equal[ACTIVE]} && !${RDPause}) /call MercStuff
	/return

Sub DoRestrictedEvents(BuffID)
	/if (${Defined[BuffID]}) {
		/varset LastCast ${BuffID}
		/doevents Restricted
		/varset LastCast BLAH
	}
	/return	
	
Sub DoSotW
	/declare i             int local
	/declare GroupTotalHPs int local
	/declare GroupMember   int local
	/varcalc GroupMember ${Group}+1
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].ID}) {
			/varcalc GroupTotalHPs ${GroupTotalHPs}+${Group.Member[${i}].PctHPs}
		} else {
			/varcalc GroupTotalHPs ${GroupTotalHPs}+100
		}
	/next i
	/if (!${RDPause} && ${GroupTotalHPs}/(${Group}+1)<${SotWPct} && !${Me.Buff[Celestial Regeneration].ID} && !${Me.Buff[Celestial Rejuvenation].ID} && !${Me.Buff[Ethereal Elixir].ID} && !${Me.Buff[Celestial Renewal].ID} && !${Me.Buff[Spirit of the Wood].ID} && !${Me.Buff[Spirit of the Grove].ID} && !${Me.Buff[Ancestral Aid].ID} && !${Me.Buff[Paragon of Spirit].ID} && !${Me.Buff[Perfection of Spirit].ID}) {
		/if (${Target.Type.NotEqual[NPC]}) {
			/target id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
		}
		/if (${ReportSotW}) /call AnnounceMessage "${HealChannel}" 4 g "Prepare for" t "${SotWAA}" g "to heal" m "the group"
		/call MQ2Cast "${SotWAA}" alt 1s SpellFiller 3
		}
	/varset GroupTotalHPs 0
	/return

Sub DoSotWNet
	/if (!${RDPause} && ${NetWorst.Request[pc all group radius${Int[${Spell[${SotWAA}].MyRange}]}]}>1 && ${NetWorst.Average}<${SotWPct} && !${Me.Song[Celestial Regeneration].ID} && !${Me.Song[Celestial Rejuvenation].ID} && !${Me.Song[Ethereal Elixir].ID} && !${Me.Song[Celestial Renewal].ID} && !${Me.Song[Spirit of the Wood].ID} && !${Me.Song[Spirit of the Grove].ID} && !${Me.Song[Ancestral Aid].ID} && !${Me.Song[Paragon of Spirit].ID} && !${Me.Song[Perfection of Spirit].ID}) {
		/if (${Target.Type.NotEqual[NPC]}) {
			/target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			}
		/if (${ReportSotW}) /call AnnounceMessage "${ChatChannel}" 4 g "Prepare for" o "${SotWAA}" g "to heal" m "the group"
		/call MQ2Cast "${SotWAA}" alt 1s SpellFiller 3
		}
	/return	
	
Sub DoStuff(StuffType)
	/declare i int local
	/declare tempTargetID int local
	/varset tempTargetID 0
	/for i 1 to ${${StuffType}Total}
		/if (${RDPause} || (${Me.CombatState.Equal[COMBAT]} && ${StuffType.Equal[Rest]}) || ${Me.State.Equal[HOVER]}) /return
		/if (${HealGroup} && !${CheckGroupTimer}) /call EvaluateGroup
		/if (${tempTargetID}) /target id ${tempTargetID}	
		/call EvaluateCondition "${${StuffType}Condition${i}}"
		/if (${Macro.Return}) /call ExecuteStuff ${StuffType} ${i}
		/varset tempTargetID ${Target.ID}
	/next i
	/varset ${StuffType}StuffTimer ${${StuffType}StuffRecheck}
	/call MoveStuff
	/return

Sub DoWoW
	/if (${Defined[DoWoWTimer]}) {
		/if (${DoWoWTimer}>0) /return
		} 
	/declare i int local
	/for i 1 to 3
		/if (!${RDPause} && ${Spawn[${MA${i}}].ID} && ${Spawn[${MA${i}}].Distance}<100) {
			/target targetable ${MA${i}}
			/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
			/delay 5s ${Target.ID}==${MainTankID}
			/if (${Target.Type.Equal[Corpse]}) {
				/echo MA${i} is dead, can not place Wrathe of the Wild on them
				/call CreateTimer DoWoWTimer 5m
				/return
				}
			/call MQ2Cast "Wrath of the Wild" alt Check4Pad
			/if (${castReturn.Equal[CAST_SUCCESS]} || !${Me.AltAbilityReady[Wrath of the Wild]}) {
				/if (${ReportWoW} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Put" o "Wrath of the Wild" g "on" m "${Target.CleanName}"
				/return
				}
			/if (${Select[${castReturn},CAST_IMMUNE,CAST_RESIST,CAST_TAKEHOLD,CAST_NOTHOLD]}) {
				/call AnnounceMessage "${ChatChannel}" 4 r "Failed to put" o "Wrath of the Wild" r "on" m "${Target.CleanName}"
				/call CreateTimer DoWoWTimer 3m
				}
			}
	/next i
	/return	
	
Sub EvaluateCondition(Condition)
	/declare sCondition string local
	/declare sVarL string local
	/declare sVarC string local
	/declare j int local
	/varset sVarC
	/varset sCondition (${Condition})
	/if (${sCondition.Count[{]}>0) {
		/for j 1 to ${sCondition.Count[{]}
			/varset sVarL ${sCondition.Arg[${j},{]}
			/varset sVarC ${sVarC}${sVarL}${
		/next j
		/varset sVarC ${sVarC}${sCondition.Arg[${j},{]}
		}
	} else {
		/varset sVarC ${sCondition}
	}
	/if (${sVarC}) /return 1
	/return 0

Sub EvaluateGroup
	/declare i int local
	/varset WorstHPs 100
	/varset GroupHurtCount 0
    
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Type.Equal[Corpse]}) /goto :NextEvaluateGroup
		/if (!${RDPause} && ${UseDivArb} && ${Group.Member[${i}].PctHPs}<=${DivArbHPs} && (((${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) || (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) || (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer}))) || (!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) || (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID}))&& ${Spawn[${Group.Member[${i}]}].ID} && ${Spawn[${Group.Member[${i}]}].Distance}<${Spell[Divine Arbitration].MyRange}) /call DoDivArb

		/if (!${RDPause} && ${UseBDA} && ${Group.Member[${i}].PctHPs}<=${DivArbHPs} && ${Me.AltAbilityReady[Bestow Divine Aura]} && ${Group.Member[${i}].ID}!=${MainTankID} && ${Group.Member[${i}].ID}!=${Spawn[${MA2}].ID} && ${Group.Member[${i}].ID}!=${Spawn[${MA3}].ID}) {
			/if (${Me.Casting.ID}) {
				/call DoInterrupt
				/bc EvaluateGroup Interrupt1
				}
			/target targetable id ${Group.Member[${i}].ID}
			/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
			/call MQ2Cast "Bestow Divine Aura" alt 5s SpellFiller 3
			/varset DAArray[${Math.Calc[${i}+1]},1] ${Group.Member[${i}].PctHPs}
			/varset DAArray[${Math.Calc[${i}+1]},2] 1
		}
		/if (${HealMeFirst} && ${Me.PctHPs}<${HealPct}) {
			/varset WorstHPs 0
			/varset WorstID ${Me.ID}
					/goto :EvaluateGroupreturn
		}
		/if (${DAArray[${Math.Calc[${i}+1]},2]} && (${Group.Member[${i}].PctHPs}>=${DAArray[${Math.Calc[${i}+1]},1]}+5 || ${DAArray[${Math.Calc[${i}+1]},1]}>${Group.Member[${i}].PctHPs})) {
			/varset DAArray[${Math.Calc[${i}+1]},1] 0
			/varset DAArray[${Math.Calc[${i}+1]},2] 0
		}
		/if ((${HealFD} && ${Group.Member[${i}].State.NotEqual["FEIGN"]} && ${Select[${Group.Member[${i}].Class.ShortName},MNK,NEC,SHD]}) || ((${UseCH} || ${Group.Member[${i}].PctHPs}>${TankHealPct}) && ${Group.Member[${i}].ID}==${MainTankID})) /goto :NextEvaluateGroup
			| don't do fast heals on MA1 unless TankHealPct not set
		/if (${Group.Member[${i}].PctHPs}<=${WorstHPs} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<${Spell[${FastHealID}].MyRange} && (${Group.Member[${i}].ID}!=${MainTankID} || !${TankHealPct})) {
			/varset WorstHPs ${Group.Member[${i}].PctHPs}
			/varset WorstID ${Group.Member[${i}].ID}
			/varcalc WorstMember ${i}+1
		}
		/if (${Group.Member[${i}].PctHPs}<${HealPct}) /varcalc GroupHurtCount ${GroupHurtCount}+1
				:NextEvaluateGroup
	/next i
	/if (!${Me.Casting.ID} && ${DoSotW} && ${Me.AltAbilityReady[${SotWAA}]}) /call ${DoSotWFunction}
	:EvaluateGroupreturn
	/varset CheckGroupTimer ${CheckGroupInterval}
	/return

Sub EvaluateGroupNet
	/declare i int local
	/varset WorstHPs 100
	/varset GroupHurtCount 0
	/declare fd string local
	/if (${HealFD}) /varset fd fd
	/if (!${RDPause} && ${UseDivArb} && ${NetWorst.Request[radius${Int[${Spell[Divine Arbitration].MyRange}]} pc group all hp${DivArbHPs}]} && (((${DivArbGem.Equal[alt]} && ${Me.AltAbilityReady[${DivArbSpell}]}) || (${DivArbGem.Equal[item]} && ${FindItem[${DivArbSpell}].TimerReady}) || (!${Select[${DivArbGem},alt,item]} && (${Me.SpellReady[${DivArbSpell}]} || !${DivArbTimer}))) || (!${FindItem[Harmony of the Soul].Timer} && ${FindItem[Harmony of the Soul].ID}) || (!${FindItem[Aegis of Superior Divinity].Timer} && ${FindItem[Aegis of Superior Divinity].ID}))) /call DoDivArb
	/if (!${RDPause} && ${UseBDA} && ${NetWorst.Request[pc group all hp${DivArbHPs} self]} && ${Me.AltAbilityReady[Bestow Divine Aura]} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA1}].ID} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA2}].ID} && ${NetHeal.ID[1]}!=${Spawn[pc ${MA3}].ID}) {
		/if (${Me.Casting.ID}) {
			/call DoInterrupt
			/bc EvaluateGroupNet Innterrupt 1
			}
		/target targetable id ${NetHeal.ID[1]}
		/delay 1s ${Target.ID}==${NetHeal.ID[1]}
		/call MQ2Cast "Bestow Divine Aura" alt 5s SpellFiller 3
		/netheal da 30000 ${NetHeal.ID[1]}
		}		 
	/if (${HealMeFirst} && ${Me.PctHPs}<${HealPct}) {
		/varset WorstHPs ${Me.PctHPs}
		/varset WorstID ${Me.ID}
		/goto :EndCheck
		}
	/if (!${RDPause} && ${NetWorst.Request[radius${Int[${Spell[${FastHealID}].MyRange}]} pc all hp${HealPct} ${fd}]}) {
		/varset i 1
		/if (${TankHealPct} && ${NetHeal.ID[1]}==${Spawn[pc ${MA1}].ID} && ${NetWorst.Counter}==1) /goto :EndCheck
		/if (${TankHealPct} && ${NetHeal.ID[1]}==${Spawn[pc ${MA1}].ID} && ${NetWorst.Counter}>1) /varset i 2
		/varset WorstHPs ${NetHeal.PctHPs[${i}]}
		/varset WorstID ${NetHeal.ID[${i}]}
		}	
	:EndCheck
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].PctHPs}<${HealPct}) /varcalc GroupHurtCount ${GroupHurtCount}+1
	/next i
	/if (!${Me.Casting.ID} && ${DoSotW} && ${Me.AltAbilityReady[${SotWAA}]}) /call DoSotW
	/varset CheckGroupTimer ${CheckGroupInterval}
	/return

Sub EvaluatePets
	/declare i int local
	/varset WorstHPs 100
	/for i 0 to ${Group}
		/if (${Group.Member[${i}].Pet.PctHPs}<=${WorstHPs} && ${Group.Member[${i}].Pet.ID} && ${Group.Member[${i}].Pet.Distance}<${Int[${Spell[${PetHealID}].MyRange}]}) {
			/varset WorstHPs ${Group.Member[${i}].Pet.PctHPs}
			/varset WorstID ${Group.Member[${i}].Pet.ID}
		}
	/next i
	/return

Sub ExecuteStuff(StuffType,NumOrder)
	/declare j int local
	/declare sOrder string local
	/declare sVarL string local
	/declare sVarC string local
	/if (${RDPause} || (${Me.CombatState.Equal[COMBAT]} && ${StuffType.Equal[Rest]})) /return
		/varset sVarC
		/varset sOrder ${${StuffType}Command${NumOrder}}
		/if (${sOrder.Count[{]}>0) {
			/for j 1 to ${sOrder.Count[{]}
				/varset sVarL ${sOrder.Arg[${j},{]}
				/varset sVarC ${sVarC}${sVarL}${
			/next j
			/varset sVarC ${sVarC}${sOrder.Arg[${j},{]}
			}
		} else {
			/varset sVarC ${sOrder}
		}	
	/docommand ${sVarC}
	/return

Sub GetFreeGems
	/declare FreeGems int    local
	/declare i        int    local
	/for i 1 to ${MaxGems}
	/varset Gems[${i}] 0
	/next i
	/if (${DebuffTotal}) {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==2) {
				/if (${DebuffSpell${i}.NotEqual[${Me.Gem[${DebuffGem${i}.Right[-3]}]}]}) /varset Gems[${DebuffGem${i}.Right[-3]}] 1
				/varset MezSong ${DebuffSpell${i}}
			}
		/next i
		}
	/for i 1 to ${Math.Calc[${MaxGems}*2]}
	/if (${Me.Gem[${SongsArray${i}}]}) /varset Gems[${Me.Gem[${SongsArray${i}}]}] 1
	/next i
	/for i 1 to ${MaxGems}
	/if (!${Gems[${i}]}) /varcalc FreeGems ${FreeGems}+1
	/next i
	/return	

 Sub GiveTo(string GItem, int GTarget)
	/declare ItemSummoned int local 0
	/if (${Cursor.ID} && ${Cursor.NoRent}) {
		/destroy
		/delay 2s !${Cursor.ID}
		}
	/if (${Cursor.ID} && !${Cursor.NoRent}) {
		/autoinv
		}	
	/delay 5s !${Cursor.ID}	
	/if (${Target.ID}!=${GTarget}) {
		/target id ${GTarget}
	    /delay 2s ${Target.ID}==${GTarget}
        }
	/if (${Target.Distance}>10 && ${Target.Distance}<=150) {
	    /moveto id ${Spawn[${GTarget}].ID}
		/delay 50 ${MoveTo.Stopped}
        }
	/if (${Cursor.ID}==${FindItem[${GItem}].ID} && ${Cursor.ID}) {
		/goto :CursorFree
		} else /if (${FindItemCount[${GItem}]}>0) {
		/shift /itemnotify "${FindItem[${GItem}]}" leftmouseup
		/delay 20 ${Cursor.ID}
		}
	:CursorFree
		/if (${Cursor.ID} && ${Cursor.NoRent}) {
			/varset ItemSummoned 1
			/nomodkey /click left target
			/delay 5
            }
		/if (${Cursor.ID} && ${Cursor.NoRent}) /goto :CursorFree
		/delay 10
		/if (${ItemSummoned}) {
			/notify GiveWnd GVW_Give_Button leftmouseup
            /if (${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 4 g "Giving" y "${GItem}" g "to" m "${Target.CleanName}"
			} else {
            /if (${ReportPetToys}==TRUE) /call AnnounceMessage "${ChatChannel}"	 4 y "Item" g "${Cursor}" r "NOT SUMMONED" y "canceling trade"
            /notify GiveWnd GVW_Cancel_Button leftmouseup
			}
        /delay 200 !${Window[GiveWnd].Open}
|======
| if pet refuses item, autodestroy it
|======		
		/if (${Cursor.ID} && ${Cursor.NoRent}) {
			/destroy
			/delay 2s !${Cursor.ID}
			}
	/return
	
Sub GoToCampfire
	/if (!${RDPause} && !${Me.Invis}) /call MQ2Cast "Fellowship Registration Insignia" item 5 SpellFiller 3
	/call AnnounceMessage "${ChatChannel}"  1 g "Clicking campfire port!"
	/return

Sub Guard
|========================================
| Activate using "/guard on" sets group's main tank to monitor the extended target window and
|	the mobs around the good. Using command " guard here" in a channel the toon is listening to
|	will cause the toon with guard on to set up a tight /makecamp where the toon is standing
|========================================
	/declare i				int local 1
	/declare j				int local 0
	/declare k				int local 0
	/declare GuardMob		int local 0
	/call GMChecks
	/if (!${Defined[GuardTimer]}) /call CreateTimer GuardTimer 0
	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
	/if (${RDPause} || ${Select[${Zone.ID},345,344,202,203,279]}) /return
	/if (${Me.AutoFire} && (${Target.ID}!=${MATarget} || ${Target.ID})) {
		/target ID ${Me.ID}
		/autofire off
		}
|========================================
|	Checks for Named mobs on the extended target window, switches to them if it finds one. 
|========================================		
	/if (${Me.XTarget}>0 && ${SpawnCount[npc named targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
		/if (${Target.Named}) /return
		/for k 1 to ${Me.XTarget}
			/if (${Me.XTarget[${k}].Named} && ${Me.XTarget[${k}].Type.Equal[NPC]}) {
				/target ID ${Me.XTarget[${k}].ID}
				/if (${Target.ID} && ${Target.ID}==${Me.XTarget[${k}].ID} && ${Me.XTarget[${k}].PctHPs}<${EngageHPs}) {
					/varset MATarget ${Me.XTarget[${k}].ID}
					/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
					/if (${Group.MainTank.ID}==${Me.ID} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
					/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist}) {
						/face fast
						/autofire on
						/delay 1s
						} else /if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
						/killthis
						/call DoMelee
						}
					/popup Killing ${Target.CleanName}
					/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 r "/varset MATarget ${Me.XTarget[${k}].ID}"
					/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 y Named!!
					/call CreateTimer GuardTimer 50
					/return
					}
				}
		/next k
|		/return
		}
|========================================
| If there is no MATarget, and not currently fighting something, checks the extended target window. 
|	 Targets XTarget1 and attacks
|========================================		
	/if (${Spawn[${MA1}].ID}==${Me.ID} && ${Me.XTarget} && (!${Me.Combat} && !${Me.AutoFire}) && ${Me.XTarget[1].Distance}<${NPCRadius}) {
		/xtarget 1
		/if (${Target.ID} && ${Target.ID}==${Me.XTarget[1].ID} &&  && ${Me.XTarget[1].Type.Equal[NPC]}) {
			/varset MATarget ${Target.ID}
			/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
			/if (${Group.MainTank.ID}==${Me.ID} && ${Target.Named} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
			/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist} && ${Me.XTarget[1].PctHPs}<${EngageHPs}) {
				/face fast
				/autofire on
				/delay 1s
				} else /if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
				/killthis
				/call DoMelee
				}
			/popup Killing ${Target.CleanName}
			/squelch /face fast nolook
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 r "/varset MATarget ${Me.XTarget[1].ID}"
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 y "Guard function XTarget window activated!"
			/call CreateTimer GuardTimer 50
			/return
			}
		}
	/if (${GuardTimer}>0) /return
	/for j 1 to ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}
	/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
|========================================
| Monitors area around toon. If a mob not on the alert list, and comes with in the NPCRadius, and is in line of sight, 
|	 it will initiate combat either through range attack (if DoRanged is on) or using /killthis to initiate MQ2Melee attacking
|========================================	
		/if (!${Melee.Combat} && !${Me.AutoFire} && !${RDPause} && !${Me.Invis} && ${Melee.Status.NotEqual[ENGAGED]} && !${GuardPause} && ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}) {
			/if (${Status}) /call Status
			/if (${GuardPause}) /return
			/varset GuardMob ${NearestSpawn[${j}, npc radius ${NPCRadius} zradius ${NPCZRadius} targetable noalert 1].ID}
			/if (${Target.Type.Equal[Corpse]} || ${Target.Type.Equal[Pet]} || ${Target.Type.Equal[Mercenary]}) /target clear
			/if (${Spawn[${GuardMob}].Type.Equal[untargetable]} || ${Spawn[${GuardMob}].Type.Equal[Corpse]}) {
				/varset MATarget 999999
				/next j
				}
|========================================
| Attempts to use MQ2Nav, if it is loaded, and there 
|  is a mesh for the zone
|========================================			
		/if (${Bool[${Plugin[MQ2Nav]}]}) {
			/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
			/if (${Navigation.MeshLoaded} && ${Spawn[${GuardMob}].Type.NotEqual[corpse]} && ${Spawn[${GuardMob}].Type.NotEqual[untargetable]} && !${Me.Moving}) {
				/if (!${Navigation.PathExists[id ${GuardMob}]}) /next j
				/if (${Navigation.PathExists[id ${GuardMob}]}) {
					:retarget
					/if (${Debug}) /echo \ag Entering \ao Navigation section of Guard
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						/if (${Debug}) /echo pausing makecamp 1, status: ${MakeCamp.Status}
						/varset CampX ${MakeCamp.AnchorX}
						/varset CampY ${MakeCamp.AnchorY}
						/varset CampZ ${Me.Z}
						}
					/if (${MakeCamp.Status.Equal[OFF]})	{
						/varset CampX ${Me.X}
						/varset CampY ${Me.Y}
						/varset CampZ ${Me.Z}
						}
					:restartnav
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						/if (${Debug}) /echo pausing makecamp 2, status: ${MakeCamp.Status}
						}
					/nav ID ${GuardMob}
					/if (${DoRanged}) {
						/if (${Debug}) {
							/echo Doing ranged navigation
							/echo ${MakeCamp.Status}
							}
						/delay 30s ${Spawn[${GuardMob}].Distance}<60
						/delay 60s ${Spawn[${GuardMob}].LineOfSight}
						/if (${Me.XTarget}) /goto :navreturn
						/if (${MakeCamp.Status.Equal[ON]}) /echo stuck again....
						/if (${MakeCamp.Status.Equal[ON]} || (${Navigation.Active} && !${Me.Moving} || !${Spawn[${GuardMob}].LineOfSight})) {
							/goto :restartnav
							}
						/nav stop
						/if (${Spawn[${GuardMob}].Distance}>100 || !${Spawn[${GuardMob}].LineOfSight}) /goto :restartnav
						/squelch /target targetable id ${GuardMob}
						/if (${Target.PctHPs}<100 || (${Target.AggroHolder.ID} && ${Target.AggroHolder.ID}!=${Me.ID})) {
							/target clear
							/goto :navreturn
							}
						/if (!${Me.AutoFire} && ${Target.Distance}>30) {
							/autofire
							/delay 10s ${Me.XTarget}
							/goto :navreturn
							}
						/if (${Target.Distance}<30) {
							/attack
							/delay 10s ${Me.XTarget}
							/goto :navreturn
							}
						}
					/if (!${DoRanged}) {
						/if (${Debug}) {
							/echo doing non-ranged navigation
							/echo MakeCamp status is ${MakeCamp.Status}
							}
						/delay 120s !${Navigation.Active} || ${Me.XTarget}
						/nav stop
						/if (${Spawn[${GuardMob}].Distance}>100) /goto :restartnav
						/squelch /target targetable id ${GuardMob}
						/if (${Target.PctHPs}<100 || (${Target.AggroHolder.ID} && ${Target.AggroHolder.ID}!=${Me.ID})) {
							/target clear
							/goto :navreturn
							}
						/attack
						/delay 30s ${Me.XTarget}
						/if (${Debug}) /echo attacking ${GuardMob}
						/if (${Me.XTarget}) /goto :navreturn
						/if (${Me.XTarget}>1) /goto :retarget
						}
					:navreturn
					/echo \ag RETURNING
					/if (${MakeCamp.Status.Equal[ON]}) {
						/makecamp pause
						/delay 10s ${MakeCamp.Status.Equal[PAUSED]}
						}
					/nav loc ${CampY} ${CampX} ${CampZ}
					/delay 2s
					/delay 60s !${Navigation.Active}
					/if (${MakeCamp.Status.Equal[PAUSED]} && ${MakeCamp.CampDist}<30) /makecamp unpause
					/return
					}
				}
			}
		/if (!${RDPause} && !${GuardTimer} && !${Me.XTarget} && ${Spawn[${GuardMob}].LineOfSight} && ${Spawn[${GuardMob}].Type.NotEqual[corpse]} && ${Spawn[${GuardMob}].Type.NotEqual[untargetable]} && !${Me.Moving}) {
			/if (${Debug}) /echo Targeting ${GuardMob} and line of sight is ${Spawn[${GuardMob}].LineOfSight}
			/squelch /target targetable id ${GuardMob}
			/if (${Target.ID} && ${Target.ID}==${GuardMob}) {
				/delay 5s ${Target.ID}==${GuardMob}
				/squelch /face fast nolook
				/if (${MATarget}!=${GuardMob}) /varset MATarget ${GuardMob}
				/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
				/if (${Group.MainTank.ID}==${Me.ID} && ${Target.Named} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]}) /call defense
				/if (${Target.ID} && ${DoRanged} && !${Me.AutoFire} && ${Target.Distance}>${RangeDist} && ${Target.PctHPs}<=${EngageHPs}) {
					/face fast
					/autofire on
					/delay 10s ${Me.XTarget}
					/popup Killing ${Target.CleanName} by range
					} else /if (${Target.ID} && (!${Me.AutoFire} || ${Me.AutoFire} && ${Target.Distance}<${RangeDist}) && ${Target.Type.NotEqual[Mercenary]}) {
					/popup Killing ${Target.CleanName} too close for range
					/killthis
					/call DoMelee
					}
				/if (!${DoRanged} && ${Target.PctHPs}<=${EngageHPs} && ${Target.Type.NotEqual[Mercenary]}) {
					/if (!${Me.Standing} && (${Me.State.NotEqual[FEIGN]} || (${Me.State.Equal[FEIGN]} && !${Select[${Me.Class.ShortName},SHD,NEC,MNK]}))) /stand
					/popup Killing ${Target.CleanName} Melee
					/stick ID ${Target.ID}
					/killthis
					/call DoMelee
					}
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 r "/varset MATarget ${Target.ID}"
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 1 y "Guard function activated!" 
|				/squelch /face fast nolook
				/call CreateTimer GuardTimer 50
				/return
				}
			}
		}
	/next j	
	/doevents
	/return
	
Sub Status
|========================================
| Checks the Mana and Endurance of each group member
|	 change the minimul amounts you want the pause feature to engage at
|========================================
	/declare i int local
	/if (${Me.Combat} || ${Me.XTarget}) /return
	/for i 5 downto 0
	/if (${Group.Member[${i}].ID} && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG,BST]} && ${Group.Member[${i}].PctMana}<50 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<40 || ${Group.Member[${i}].Type.Equal[corpse]})) {
		/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
		/delay 1s
		/varset GuardPause 60s
		/if (!${Me.Sitting}) /sit
		/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" "4" "y" "Pausing" "w" "${Math.Calc[${GuardPause}/10]} seconds" "g" "for" "o" "${Target.CleanName}"
		}
	/next i	
	/if (${Target.ID}) /target clear
	/return	
	
Sub GMChecks
	/if (${Spawn[gm].ID} && ${GMCheck}) {
		/if (${Me.Combat} || ${Me.XTarget}) /return
		/if (!${Me.Combat} || !${Me.XTarget}) /bcaa //q
		}
	/return
	
	
Sub HealOverTime
|========================================
|code based on Nytemyst's AFCleric
|========================================	
	/if (!${Defined[HotTimer]}) /call CreateTimer HotTimer
	/if (${HotTimer}<10) {
		/if (${Spawn[ID ${MainTankID}].Distance}<=${Spell[${HotSpell}].MyRange} && ${Spawn[ID ${MainTankID}].PctHPs}>=80 && ${UseTankHoT} && ${SpawnCount[npc los Range 5 110 radius 50 zradius 50 targetable]} && ${Me.CombatState.Equal[COMBAT]} && ${Me.PctMana}>10) {
			/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
			/call MQ2Cast "${HotSpell}" ${HotSpellGem} 1s Check4Pad
			/if (${Debug}) /echo casting ${HotSpell} from Gem ${HotSpellGem} on ${Target.CleanName}
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 g "Casting on->" m "${Target.CleanName}" g "<-with HoT" t "${HotSpell}"
			/if (${castReturn.Equal[CAST_SUCCESS]}) /varset HotTimer 60s
			/if (${Debug} && ${castReturn.Equal[CAST_SUCCESS]}) /echo Cast Successful
			/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) /varset HotTimer 60s
			/varset castReturn CAST_CANCELLED
			}
		}
	/return	

Sub HealXTarget
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/declare X int local 
	/declare i int local 1
|--------Loops Through extended target window For Pets and Players to heal.
	/for X 1 to ${Me.XTarget}
	/if (${Me.XTarget[${X}].ID} && ${Me.XTarget[${X}].Type.NotEqual[NPC]}) {
		/if (${Me.XTarget[${X}].PctHPs}<=${PetHealPct} && ${Me.XTarget[${X}].Distance}<=200 && ${Me.XTarget[${X}].Type.Equal[PET]} && ${HealPets}) /call DoHeal ${Me.XTarget[${X}].ID} Pet
		/if (${Me.XTarget[${X}].Type.NotEqual[Corpse]} && ${Me.XTarget[${X}].PctHPs}<=${TankHealPct} && ${Me.XTarget[${X}].Distance}<=${Int[${Spell[${TankHealID}].MyRange}]} && ${Me.XTarget[${X}].Type.Equal[PC]} && ${Select[${Me.XTarget[${X}].Class.ShortName},WAR,PAL,SHD]}) /call DoHeal ${Me.XTarget[${X}].ID} Tank
		/if (${Me.XTarget[${X}].Type.NotEqual[Corpse]} && ${Me.XTarget[${X}].PctHPs}<=${HealPct} && ${Me.XTarget[${X}].Distance}<=${Int[${Spell[${FastHealID}].MyRange}]} && ${Me.XTarget[${X}].Type.Equal[PC]} && ${Select[${Me.XTarget[${X}].Class.ShortName},MNK,NEC,BRD,WIZ,ENC,CLR,DRU,MAG,SHM,ROG,BST,BER,RNG]}) /call DoHeal ${Me.XTarget[${X}].ID} Fast
		}
	/next X
	/return	
	
Sub HolyShit(MobName)
	/declare i int local
	/declare LastCastReturn string local ${castReturn}
	/for i 1 to ${TotalShit}
		/if (!${RDPause} && !${Me.Buff[${HolyShit${i}}].ID} && ${Me.PctHPs}<${HolyShitHp${i}} && (${Me.SpellReady[${Spell[${HolyShit${i}}].RankName}]} || ${Me.AltAbilityReady[${HolyShit${i}}]} || ${Me.CombatAbilityReady[${HolyShit${i}}]} || (${FindItem[${HolyShit${i}}].ID} && !${FindItem[${HolyShit${i}}].TimerReady}))) {
			/if (${HolyShitType${i}}==1 && ${Target.ID}!=${Me.ID}) /target targetable id ${Me.ID}
			/if (${HolyShitType${i}}==2 && ${Spawn[npc targetable ${MobName}].ID} && ${Target.ID}!=${Spawn[npc targetable ${MobName}].ID}) /target targetable ${MobName}
			/delay 10s !${Me.Casting.ID} || ${Me.Class.ShortName.Equal[BRD]}
			/if (${Me.CombatAbilityReady[${HolyShit${i}}]}) {
				/doability ${HolyShit${i}}
			 /	varset castReturn CAST_SUCCESS
			} else {
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Select[${HolyShitGem${i}},item,alt]} && ${Me.Gem[${HolyShit${i}}]}) {
					/squelch /twist once ${Me.Gem[${HolyShit${i}}]}
					/varset castReturn CAST_SUCCESS
					/delay ${Spell[${HolyShit${i}}].MyCastTime.TotalSeconds}s
					/delay 1s
					/call DoCastingEvents
				} else {
					/if (${Me.Class.ShortName.NotEqual[BRD]} || ${Select[${HolyShitGem${i}},item,alt]}) {
						/if (${Twist}) /squelch /twist off
						/if (${Me.Casting.ID}) /call Interrupt
						/delay 5s !${Me.Casting.ID}        
						/call MQ2Cast "${HolyShit${i}}" ${HolyShitGem${i}} 10s SpellFiller 3
						/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs
					}
				}
			}
			/if (${HolyShitRUN${i}}) /call HolyShitRun "${MobName}"
			/if (${castReturn.Equal[CAST_SUCCESS]}) {
				/if (${LastCastReturn.NotEqual[CAST_SUCCESS]}) /varset castReturn CAST_CANCELLED
				/return
			}
		}
	/next i
	/if (${LastCastReturn.NotEqual[CAST_SUCCESS]}) /varset castReturn CAST_CANCELLED
	/return

Sub HolyShitRun(AggroMob)
	/declare i int local
	/for i 1 to 3
		/if (!${RDPause} && ${Spawn[${MA${i}}].ID}) {
		/squelch /face fast nolook id ${NearestSpawn[pc ${MA${i}}].ID}
			/keypress forward hold
			/delay 1s ${Spawn[npc targetable id ${AggroMob}].Distance}>${Spawn[npc targetable id ${AggroMob}].MaxRange}+10
			/keypress back
			/return
		}
	/next i
	/return	

Sub LoadVar(IniSection,IniVar,IniValue,MacroVar,MyIni,Function,VarType)
	/if (!${Defined[${MacroVar}]} && ${Defined[VarType]}) /declare ${MacroVar} ${VarType} outer
	/if (${Function.Equal[LOAD]}) {
		/declare IniString string local ${Ini[${MyIni},${IniSection},${IniVar},NOTFOUND]}
		/varset ${MacroVar} ${IniString}
	}
	/if (${IniString.Equal["NOTFOUND"]} || ${Function.Equal[SAVE]}) {
		/if (${IniString.Equal["NOTFOUND"]} && ${Function.Equal[LOAD]}) /varset ${MacroVar} ${IniValue}
		/ini ${MyIni} "${IniSection}" "${IniVar}" "${${MacroVar}}"
	}
	/return

Sub LootCheck
	/declare j int local
	/if (${AdvLoot.SCount}>0) {
		/for j 0 to ${AdvLoot.SCount}
			/if (${AdvLoot.SList[${j}].AutoRoll}!=TRUE) /advloot shared ${j} autoroll
		/next j
		}
	/return
	
Sub MA1Dead
|========================================
|Idea based on Nytemyst's AFCleric
|========================================
	/if (!${Spawn[ID ${MainTankID}] || ${Spawn[ID ${MainTankID}].Type.Equal[Corpse]}) {
		/call AnnounceMessage "${ChatChannel}" 3 r "OH NO! ${MA1} is dead!" m "${MA2}" g "Time to step up!"
		/if (${ChangeTank}==TRUE && ${UseGroupMA}==FALSE && ${UseRaidMA}==FALSE) {
			/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${Spawn[${MA2}].CleanName}"
			/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "${Spawn[${MA3}].CleanName}"
            /if (${UseGroupTank}) {
                /call Event_ToggleVar Turning off GroupTank usage (/usegrouptank)!,UseGroupTank,GeneralStuff,UseGroupTank,
				}
			}
		}
	/return	
	
Sub MercStuff
	/if (!${RDPause} && ${DoMercStance} && ${Mercenary.State.Equal[ACTIVE]} && ${MercStanceTimer}<10) {
		/if (${Me.CombatState.NotEqual[COMBAT]} && ${Mercenary.Class.Name.NotEqual[Warrior]} && ${Mercenary.Stance.NotEqual[Balanced]}) /stance Balanced
		/if (${Mercenary.Stance.NotEqual[Balanced]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]}) && (${Spawn[${MATarget}].PctHPs}>80 || ${Group.Member[${Me.Mercenary.CleanName}].PctAggro}>85)) /stance Balanced
		/if ((${Target.Level}>=${Me.Level}+2 || ${Target.Named} || ${Me.XTarget}>1) && ${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[PC]} && ${Mercenary.Stance.NotEqual[Reactive]} && ${Mercenary.Class.Name.Equal[Cleric]}) /stance reactive
		/if (${Mercenary.Stance.NotEqual[Burn]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]}) && ${Spawn[${MATarget}].PctHPs}<95 && ${Group.Member[${Me.Mercenary.CleanName}].PctAggro}<85 && ${MATarget}!=999999 && ${Spawn[${MATarget}].Type.NotEqual[PC]}) /stance Burn
		
		/if (${DoMercAssist} && ${Me.CombatState.Equal[COMBAT]} && ${Mercenary.Stance.NotEqual[Passive]} && ${Mercenary.Class.Name.NotEqual[Cleric]} && ${Spawn[${MATarget}].PctHPs}<${MercEngageHPs} && ${Spawn[${MATarget}].Distance}<${NPCRadius}) /mercassist
		/varset MercStanceTimer 6s
		}
	/if (${DoMercAssist}) {
		/if (!${Defined[MercAssistTimer]}) /call CreateTimer MercAssistTimer
		/if (${Window[MMGW_ManageWnd].Child[MMGW_AssistModeCheckbox].Checked}) /notify MMGW_ManageWnd MMGW_AssistModeCheckbox LeftMouseUp
		/if (${DoMercAssist} && ${Bool[!${MercAssistTimer}]} && ${Me.CombatState.Equal[COMBAT]} && ${Mercenary.Stance.NotEqual[Passive]} && ${Mercenary.Class.Name.NotEqual[Cleric]} && ${Spawn[${MATarget}].PctHPs}<${MercEngageHPs} && ${Spawn[${MATarget}].Distance}<${NPCRadius}) {
			/mercassist
			/varset MercAssistTimer 10s
			}
		}
	/if (!${RDPause} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) {
		/notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
		/delay 10s ${Mercenary.State.Equal[ACTIVE]}
		}
	/return		
	
Sub MemSongs
	/declare i          int    local
	/declare j          int    local
	/declare TwistState bool   local ${Twist}
	/if (${TwistState}) /squelch /twist stop
	/if (${DebuffTotal}) {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==2 && ${DebuffSpell${i}.NotEqual[${Me.Gem[${DebuffGem${i}.Right[-3]}]}]}) {
				/memorize "${DebuffSpell${i}}" ${DebuffGem${i}.Right[-3]} 
				/delay 5s ${Window[SpellBookWnd].Open}
				/delay 30s !${Window[SpellBookWnd].Open}
			}
		/next i
	}
	/for i 1 to ${Math.Calc[${MaxGems}*2]}
		/if (${SongsArray${i}.NotEqual[Song Name]} && !${Bool[${Me.Gem[${SongsArray${i}}]}]}) {
			/for j 1 to ${MaxGems}
				/if (!${Gems[${j}]}) {
					/if (${Cursor.ID}) /call ClearCursor
					/memorize "${SongsArray${i}}" ${j} 
					/varset Gems[${j}] 1
					/varset j ${MaxGems}
					/delay 5s ${Window[SpellBookWnd].Open}
					/delay 30s !${Window[SpellBookWnd].Open}
				}
			 /next j
		}
	/next i
	/if (${TwistState}) /squelch /twist start
	/return
	
Sub MoveStuff
	/call DoMelee
	/if (${FollowFlag} && ${Spawn[${FollowGuy}].ID} && ${Spawn[${FollowGuy}].Distance}>${LeashDistance} && !${Me.Moving} && !${Melee.Combat}) {
		/target targetable id ${FollowGuy}
		/delay 1s ${Target.ID}==${FollowGuy}
		/squelch /stick hold uw
		}
	/if (${Stick.Status.Equal[ON]} && ${FollowFlag} && ${TravelMode} && !${Me.Invis} && !${Me.CombatState.Equal[COMBAT]}) {
		/if ((${FindItem[${InvisibilitySpell}].ID} && ${InvisibilityGem.Equal[item]}) || (${InvisibilityGem.Equal[alt]} && ${Me.AltAbilityReady[${InvisibilitySpell}]})|| ${Me.Book[${InvisibilitySpell}]}) {
			/squelch /target targetable id ${Me.ID}
			/delay 1s ${Target.ID}==${Me.ID}
			/call MQ2Cast "${InvisibilitySpell}" ${InvisibilityGem} 5s Check4Pad
			} else {
			/squelch /stick off
			/varset FollowFlag FALSE
			/varset FollowGuy 0
			}
		}
	/if (${Stick.Status.Equal[ON]} && !${Me.Moving} && ${FollowFlag} && ${Spawn[${FollowGuy}].ID} && ${Target.ID}!=${Spawn[${MATarget}].ID} && ${Spawn[${FollowGuy}].Distance}<${LeashDistance}) /call AutoSit
	/return
	
Sub Named
	/call DoStuff Named
	/return	

Sub Nukeit
	/if (${Debug}) /echo \ag Entering \ao Nukeit sub
	/if (${Cursor.ID}) /autoinventory
	/declare i int local
	/for i 1 to ${NukeTotal}
		/if (!${Spawn[${MATarget}].ID} || ${MATarget}==999999) {
			/if (${Debug}) /echo \ar stopping Nukes, no target!!
			/break
			}
		/if (${Debug}) /echo \ay starting for loop with \ao ${Nuke${i}}
		/if (${PetAttack} && ${Spawn[${MATarget}].PctHPs}<${EngageHPs} && !${AssistTimer}) {
			/call PetAttackStuff
			/if (${Debug}) /echo \ay Return from pet attack is ${Macro.Return}
			}
		/if (${DoDebuffs} || ${DoDoTs} || ${DoManaTaps} || ${DoMez}) {
			/call DebuffIt
			/if (${Debug}) /echo \ay Return from Debuffit is ${Macro.Return}
			}
		/if (${HealGroup} && !${CheckGroupTimer}) {
			/call EvaluateGroup
			/if (${Debug}) /echo \ay Return from EvaluateGroup is ${Macro.Return}
			}
|-----Check to be sure your toon has the Nuke spell, item, or AA		
		/if (!${Select[${NukeGem${i}},alt,item,comb]} && !${Me.Book[${Me.Book[${Spell[${Nuke${i}}].RankName}]}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} not in spellbook.
			/goto :nukeend
			}
		/if (${NukeGem${i}.Equal[item]} && !${FindItem[${Nuke${i}}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} is marked as an item and not in inventory.
			/goto :nukeend
			}
		/if (${NukeGem${i}.Equal[alt]} && !${Me.AltAbility[${Nuke${i}}].ID}) {
			/echo \ar Nuke ${i} ${Nuke${i}} is marked as an AA, you don't appear to have.
			/goto :nukeend
			}
|-----
		/if (${Debug}) /echo \ay Passed spell/alt/item check
		/if (!${Select[${NukeGem${i}},alt,item,comb]} && !${Me.Gem[${Nuke${i}}]}) {
			/memorize "${Nuke${i}}" ${NukeGem${i}.Right[-3]}
			}
		/if (${Target.ID}!=${MATarget} && ${Spawn[id ${MATarget}].ID} && ${Spawn[${MATarget}].Type.NotEqual[corpse]}) {
			/target targetable id ${MATarget}
			/delay 5s ${Target.ID}==${MATarget}
			/if (${Debug}) /echo \ay targeting ${Spawn[${MATarget}].CleanName}
			}
		/call EvaluateCondition "${NukeCondition${i}}"
		/if (${Debug}) /echo \ay evaluating condition ${Macro.Return}
|		/if (!${RDPause} && ${Macro.Return} && (${NukeSpellSet${i}}==${WhichNuke} || !${NukeSpellSet${i}}) && ((${Me.SpellReady[${Nuke${i}}]} || (!${Me.Gem[${Nuke${i}}]} && ${Me.Book[${Nuke${i}}]})) || ${Me.AltAbilityReady[${Nuke${i}}]} || ${NukeGem${i}.Equal[item]}) && ${Target.PctHPs}>${NukeStopHPs${i}} && ${Target.PctHPs}<${NukeStartHPs${i}} && ${Me.PctMana}<=${NukeMaxMana${i}} && ${Me.PctMana}>=${NukeMinMana${i}} && (!${SitTimer} || ${Me.Gem[${Nuke${i}}]} || ${Me.Mount.ID}) && ${Target.ID}==${MATarget} && ${Target.LineOfSight} && ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]} && ${Target.Type.Equal[NPC]}) {
		/if (${Debug}) /echo \ag Entering \ao Nuke cast call checks
		/if (!${RDPause} && ${Macro.Return}) {
			/if (${Debug}) /echo \ay The nuke is listed as spell set \ag ${NukeSpellSet${i}} \ay we are using \ag ${WhichNuke}
			/if (${NukeSpellSet${i}}==${WhichNuke} || !${NukeSpellSet${i}}) {
				/if (${Debug} && !${Select[${NukeGem${i}},alt,item,comb]}) /echo \ay is the spell ready? \ao ${Me.SpellReady[${Nuke${i}}]}
				/if (${Debug} && ${NukeGem${i}.Equal[alt]}) /echo \ay is the AA ready ${Me.AltAbilityReady[${Nuke${i}}]}
				/if (${Debug} && ${NukeGem${i}.Equal[item]}) /echo \ay is an item an timer is ${FindItem[${Nuke${i}}].TimerReady}
				/if (${Me.SpellReady[${Nuke${i}}]} || ${Me.AltAbilityReady[${Nuke${i}}]} || (${NukeGem${i}.Equal[item]} && !${FindItem[${Nuke${i}}].TimerReady})) {
					/if (${Debug}) /echo \ay Passed ready check
					/if (${Target.PctHPs}>${NukeStopHPs${i}}) {
						/if (${Debug}) /echo \ay  Target HPs to nuke stop HPs \ao ${Target.PctHPs}>${NukeStopHPs${i}}
						/if (${Target.PctHPs}<${NukeStartHPs${i}}) {
							/if (${Debug}) /echo \ay Target HPs to Nuke Start HPs \ao ${Target.PctHPs}<${NukeStartHPs${i}}
							/if (${Me.PctMana}<=${NukeMaxMana${i}}) {
								/if (${Debug}) /echo \ay My mana to Nuke Max Mana \ao ${Me.PctMana}<=${NukeMaxMana${i}}
								/if (${Me.PctMana}>=${NukeMinMana${i}}) {
									/if (${Debug}) /echo \ay My mana to Nuke min mana \ao ${Me.PctMana}>=${NukeMinMana${i}}
									/if (!${SitTimer} || ${Me.Gem[${Nuke${i}}]} || ${Me.Mount.ID}) {
										/if (${Debug}) /echo \ay Sit Timer \ao ${SitTimer} \ay || Nuke is loaded in gem \ag ${Me.Gem[${Nuke${i}}]} \ao || My mount ID is  \ao ${Me.Mount.ID}
										/if (${Target.ID}==${MATarget}) {
											/if (${Debug}) /echo \ay my target ID compared to MATarget ID is \ao ${Target.ID}==${MATarget}
											/if (${Target.LineOfSight} && ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]}) {
												/if (${Debug}) /echo \ay Target line of sight is \ao ${Target.LineOfSight} \ao and Target distance compared to spell range \ao ${Target.Distance}<${Int[${Spell[${NukeID[${i}]}].MyRange}]}
												/if (${Target.Type.Equal[NPC]}) {
													/if (${Debug}) /echo \ay is target a NPC? \ao ${Target.Type.Equal[NPC]}
													/if (${Debug}) /echo \ay  Ready to cast \ao ${Nuke${i}}
													/if (${Me.Class.ShortName.Equal[WIZ]}) {
														/if (${Debug}) /echo \ay I am a \ao wizard
														/if (!${Select[${NukeGem${i}},alt,item,comb]}) {
															/if (${Debug}) /echo \ay Activating appropriate "mancy"
															/if (${Spell[${Nuke${i}}].ResistType.Equal[Magic]} && ${Me.AltAbilityReady[3734]} && !${Me.Buff[Acromancy].ID}) /alt activate 3734
															/if (${Spell[${Nuke${i}}].ResistType.Equal[Cold]} && ${Me.AltAbilityReady[640]} && !${Me.Buff[Cyromancy].ID}) /alt activate 640
															/if (${Spell[${Nuke${i}}].ResistType.Equal[Fire]} && ${Me.AltAbilityReady[514]} && !${Me.Buff[Pyromancy].ID}) /alt activate 514
															}
														}
													/call MQ2Cast "${Nuke${i}}" ${NukeGem${i}} 5s Check4Pad 3
													/if (${Debug}) /echo \ay called for cast of \ao ${Nuke${i}} \ag ${NukeGem${i}}
													/if (${castReturn.Equal[CAST_SUCCESS]} && ${DoConcussion}) {
														/if ((!${SitTimer} || ${Me.Gem[${ConcussionSpell}]} || ${Me.Mount.ID}) || ${Select[${ConcussionGem},item,alt]}) /call MQ2Cast "${ConcussionSpell}" ${ConcussionGem} 5s Check4Pad
														}
													/if (${Debug}) /echo \ay cast return = \ao ${castReturn}
													/varset NukeTimer ${NukeDelay}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	/if (${Debug}) /echo \ay ending for loop of Nuke \ao ${i} ${Nuke${i}}
	:nukeend	
	/next i
	/call MoveStuff
	/if (${Debug}) /echo \am Exiting \ao Nuke sub
	/return

Sub OpenInvSlot
	/if (${BagNum}) /return
	/declare i int local
	/varset BagNum 0
	/for i 1 to 10
	/if (${InvSlot[pack${i}].Item.Container}) /goto :NextSlot
	/if (!${InvSlot[pack${i}].Item.Container} || ${InvSlot[pack${i}].Item.ID}==0) {
|========================================	
| Must have at least 2 inv slots open in order to swap bags and items
|========================================
		/if (${Me.FreeInventory}>=2) /varset BagNum ${i}
		|/if (${InvSlot[pack${i}].Item.ID}==0) /varset BagNum ${i}
		}    
	/if (${BagNum}) {
		/echo Inventory slot ${i} is empty using that one.
		/delay .5
		/return
		}
	:NextSlot
        /next i
	/return	

Sub ParseMessage(Replace,NewText)
	/declare Lefttext  string local
	/declare Righttext string local
	/if (!${Parse.Find[${Replace}]}) /return
	:Recheck
	/if (${Parse.Find[${Replace}]}) {
		/if (${Parse.Find[${Replace}]}>1) /varset Lefttext ${Parse.Left[${Math.Calc[${Parse.Find[${Replace}]}-1]}]}
		/if (${Parse.Find[${Replace}]}<${Math.Calc[${Parse.Length}-(${Replace.Length}+1)]}) /varset Righttext ${Parse.Right[${Math.Calc[${Parse.Length}-(${Parse.Find[${Replace}]}+${Replace.Length})]}]}
		/varset Parse ${Lefttext}${NewText}
		/varset Lefttext ${Parse} ${Righttext}
		/varset Parse ${Lefttext}
		/goto :Recheck
	}
	/return
	
Sub PetAttackStuff
	/if (!${Me.Pet.ID}) /return
	/if (${MATarget}!=999999 && ${Target.ID}==${Spawn[${MATarget}].ID} && !${RDPause} && !${Me.Pet.Combat} && ${Target.PctHPs}<(${EngageHPs}-2)) {
		/pet attack 
		}
	/if (${Mercenary.State.Equal[ACTIVE]}) /call MercStuff
	/return 1

Sub PetStuff
	/declare SusMinion 		bool 	local FALSE
	/declare SwapItemBack 	int    	local 0
	/declare OldItemName  	string 	local NOTFOUND
	/declare SlotName     	string 	local NOTFOUND
	/if (${Debug}) /echo \ag Entering \ao PetStuff
	/if (!${RDPause} && ${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]}) {
		/if (${Debug}) {
			/echo I am number \ag ${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]} \ao in accepted pet list
			/echo UsePet is \ay ${UsePet} ${If[${Me.Pet.ID},\ao I have a pet,\ay I do not have a pet]}
			}
		/if (${UsePet} && (!${Me.Pet.ID} && !${KillFlappy}) || (${KillFlappy} && !(${Me.Buff[${PetSpell}].ID} || ${Me.Buff[Familiar: ${PetSpell}].ID}))) {
			/if (${Debug}) /echo pet ID ${Me.Pet.ID} , if NULL we proceed
			/if (${Me.Combat} && ${Me.ID}==${Group.MainTank.ID}) /return
			| See if we have a suspended pet
	|		/if (${Me.AltAbilityReady[suspended minion]}) /call MQ2Cast "suspended minion" alt 3s SpellFiller 3
	|		/delay 5s ${Me.Pet.ID}
			/if (${Me.Pet.ID}) /return
			/if (${FindItem[${PetFocus}].InvSlot}>21) {
				/varset SwapItemBack int    local 1
				/varset OldItemName  string local ${InvSlot[${FindItem[${PetFocus}].WornSlot[1].ID}].Item.Name}
				/varset SlotName     string local ${FindItem[${PetFocus}].WornSlot[1].Name}
				/call SwapItem "${PetFocus}" ${SlotName}
				}
			/if (${Debug}) /echo Casting pet spell ${PetSpell}
			/if (!${Me.Book[${Me.Book[${Spell[${PetSpell}].RankName}]}].ID}) {
				/call AnnounceMessage ${ChatChannel} 3 r "ERROR casting pet spell" y "${PetSpell}" r "not in spellbook"
				/return
				}
			/call MQ2Cast "${PetSpell}" ${PetGem} 35s Check4Pad
			/if (${SwapItemBack}) /call SwapItem "${OldItemName}" ${SlotName}
			/delay 2s ${Me.Pet.ID}
			}
		/if (${Me.Pet.ID}) {
			/if (${PetShrink}) {
				/if (${Target.ID}!=${Me.Pet.ID}) /squelch /target targetable id ${Me.Pet.ID}
				/delay 1s ${Target.ID}==${Me.Pet.ID}
				/if ((!${Me.Book[${Me.Book[${Spell[${PetShrinkSpell}].RankName}]}].ID} && ${PetShrinkGem.NotEqual[item]}) || (!${FindItem[${PetShrinkSpell}].ID} && ${PetShrinkGem.Equal[item]})) {
					/if (${PetShrinkGem.NotEqual[item]}) /call AnnounceMessage ${ChatChannel} 3 r ERROR! m "${PetSrinkSpell" y "marked as SPELL and not in spellbook"
					/if (${PetShrinkGem.Equal[item]}) /call AnnounceMessage ${ChatChannel} 3 r ERROR! m "${PetShrinkSpell" y "marked as ITEM and not in inventory"
					/goto :skippetshrink
					}
				/call MQ2Cast "${PetShrinkSpell}" ${PetShrinkGem} 6s Check4Pad
				/call MQ2Cast "${PetShrinkSpell}" ${PetShrinkGem} 6s Check4Pad	
				/varset PetShrink FALSE 
				}
			:skippetshrink
			/if (${Me.Class.ShortName.Equal[MAG]}) {
				/if (${DoPetToys} && !${Me.Pet.Primary}) /call PetToys ${Me.Pet.ID}	
				}
			}
		}
	/if (!${RDPause} && ${DoPetBuffs} && ${Me.Pet.ID}) {
		/if (${Debug}) /echo  \ag Entering \ao Pet Buff, \ay PetBuffTotal = \ag ${PetBuffTotal}
		/declare i int local
		/for i 1 to ${PetBuffTotal}
			/if (${Debug}) /echo Checking pet buff ${i} : \ag ${PetBuff${i}}
			/if (${Spell[${PetBuffIcon${i}}].StacksPet[0]}) /return
			/if (${Me.PctMana}<${PetMana} && !${Select[${PetBuffGem${i}},alt,item]}) {
				/if (${Debug}) /echo \ar mana = ${Me.PctMana}<${PetMana} , buff is a spell
				/return
				}
			/if (!${RestrictedList.Find[|${PetBuffID[${i}]}|]} && (${Me.Pet.Distance}<${Int[${Spell[${PetBuffID[${i}]}].MyRange}]} || ${Me.Pet.Distance}<${Spell[${PetBuffID[${i}]}].AERange}) && ${Spell[${PetBuffIcon${i}}].StacksPet[0]} && ((!${SitTimer} || ${Me.Gem[${PetBuff${i}}]} || ${Me.Mount.ID}) && (!${Me.Gem[${PetBuff${i}}]} || ${Me.SpellReady[${Spell[${PetBuff${i}}].RankName}]}) || (${PetBuffGem${i}.Equal[item]} && !${FindItem[${PetBuff${i}}].Timer}) || (${PetBuffGem${i}.Equal[alt]} && ${Me.AltAbilityReady[${PetBuff${i}}]}))) {
				/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
				/if (${Target.ID}!=${Me.Pet.ID}) /squelch /target targetable id ${Me.Pet.ID}
				/delay 1s ${Target.ID}==${Me.Pet.ID}
				/if (${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Buffing" m "${Me.Pet.CleanName}" g "with" o "${PetBuff${i}}"
				/doevents flush Restricted
				/if (${Debug}) /echo  CASTING \ay ${PetBuff${i}} \ao from \ay ${PetBuffGem${i}}
				/call MQ2Cast "${PetBuff${i}}" ${PetBuffGem${i}} 10s Check4Pad
				/call DoRestrictedEvents ${PetBuffID[${i}]}
				/return
			}
		/next i
		/varset PetBuffTimer ${PetBuffRecheck}
	}
	/if (${KillFlappy} && ${Me.Pet.ID}) /pet get lost
	/call MoveStuff
	/if (${Debug}) /echo \am Exiting pet buff
	/return


Sub PetToys(int ThePetID)
	/if (${Debug}) /echo \ag Entering \ao Pet Toys sub
	/if (${Spawn[${ThePetID}].Distance3D}>250) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "is to far away"
		/goto :SkipPetToy
		}
	/if (!${Spawn[${ThePetID}].LineOfSight}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "can't be seen from here"		
		/goto :SkipPetToy
		}
	/if (!${Spawn[${ThePetID}].ID}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "doesn't appear to exist"		
		/goto :SkipPetToy
		}
	/if (${Spawn[${ThePetID}].Type.NotEqual[pet]}) {
		/call AnnounceMessage "${ChatChannel}" 3 r error m "${Spawn[${ThePetID}]}" y "doesn't appear to be a pet"		
		/goto :SkipPetToy
		}		
	/declare i int local
	/declare j int local
	/declare GrabItem int local 0
	/declare PetToySpell string local 0
	/declare FullText string local
	/declare 2ndPart string local
	/declare 3rdPart string local
	/declare PetToysTemp string local ${PetToysGave}
	/call OpenInvSlot
	/if (${BagNum}==0) {
		/call AnnounceMessage ${ChatChannel} 2 r "Error," y "You must have an empty Top Inventory slot for Pet Toys to work."
		/varset DoPetToys 0
		/return
        }
	/if (!${InvSlot[pack${BagNum}].Item.Container} && !${Me.FreeInventory}) {
		/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 y "Inventory is" r "FULL"
		/varset DoPetToys 0
		/return
        }
	/for i 1 to ${PetToys.Size}
		/if (${Debug}) {
			/echo PetToys.Size = ${PetToys.Size}
			/echo 1: ${PetToys${i}}
			/echo 2: ${PetToysTemp}
			/echo 3: ${PetToys${i}.Equal[Null]} || ${PetToysTemp.Find[${Me.Pet.CleanName}]} && ${PetToysTemp.Find[${PetToys${i}}]})
			}
		/if (${PetToys${i}.Equal[Null]} || ${PetToysTemp.Find[${Me.Pet.CleanName}]} && ${PetToysTemp.Find[${PetToys${i}}]}) /goto :SkipPetToy
		|========================================
		| Are we handing weapons to the pet
		|========================================
		/if (${PetToys${i}.Arg[2,|].Length}) {
			/varset FullText ${PetToys${i}}
			/varset PetToySpell ${PetToys${i}.Arg[1,|]}
			/varset 2ndPart ${PetToys${i}.Arg[2,|]}
			/varset 3rdPart ${PetToys${i}.Arg[3,|]}
			} else {
			/varset PetToySpell ${PetToys${i}}
			}
		/if (${2ndPart.Length} && ${PetToysTemp.Find[${2ndPart}1]} || ${3rdPart.Length} && ${PetToysTemp.Find[${3rdPart}2]}) /goto :SkipPetToy
		|========================================
		| Check for pet toy spells in book to prevent double casting of items
		|========================================
		/if (!${Me.Book[${Me.Book[${Spell[${PetToySpell}].RankName}]}].ID} && ${PetToySpell.NotEqual[NULL]}) {
			/call AnnounceMessage "${ChatChannel}" 2 y "${PetToySpell}" r "NOT IN SPELLBOOK!!"
			/goto :SkipPetToy
			}
		/if (${Spell[${PetToySpell}].RankName.ID}) {
			/target ${Me}
			/delay 1s
			/call MQ2Cast "${PetToySpell}" ${BuffGem} 5 SpellFiller 3
			/if (!${PetToysTemp.Find[${Me.Pet.CleanName}]}) {
				/ini "${IniFileName}" "Pet" "PetToysGave" "${Me.Pet.CleanName}"
				/varset PetToysTemp ${Ini[${IniFileName},Pet,PetToysGave]}
				}
			/if (${Macro.Return.Equal[CAST_SUCCESS]} && ${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 g "Summoning pet toy " o "${PetToySpell}"
			/delay 100 ${Me.SpellReady[${Spell[${PetToySpell}].RankName}]}
			/delay 5s ${Cursor.ID}
			/if (!${Cursor.ID}) /return
		|========================================
		| Check if spell has summoned a bag or folded pack
		|========================================
			/if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
		|========================================
		| If item is in Inv Slot exchange it with bag on cursor
		|========================================
				/if (${InvSlot[pack${i}].Item.ID}) /nomodkey /itemnotify pack${BagNum} leftmouseup
		:Unfolded
				/delay 2s ${Cursor.ID}
		|========================================
		| Drop exchanged item into inventory
		|========================================
				/autoinventory
				/delay 1s
		|========================================
		| If folded pack right click to convert to phantom satchel
		|========================================
				/if (${InvSlot[pack${BagNum}].Item.Name.Find[folded]}) {
					/nomodkey /itemnotify pack${BagNum} rightmouseup
					/if (${ReportPetToys}==TRUE) /call AnnounceMessage "${PetToysChannel}" 2 g "Opening" o "${InvSlot[pack${BagNum}].Item.Name}"
					/delay 3s
		|========================================
		| Return to top to drop bag into inventory
		|========================================
					/goto :Unfolded
					}
				}
			/if (${InvSlot[pack${BagNum}].Item.Container} && (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]})) {
		| Open the bag
				/nomodkey /itemnotify pack${BagNum} rightmouseup
				/delay 10
				/if (${Debug}) /echo ${i} ${PetToySpell} ${2ndPart} ${3rdPart}
				/if (${2ndPart.Length} && ${FindItemCount[${2ndPart}]} && !${PetToysTemp.Find[${2ndPart}1]}) {
					/call GiveTo "${2ndPart}" ${ThePetID}
					/varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
					/ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
					}
				/if (${3rdPart.Length} && ${FindItemCount[${3rdPart}]} && !${PetToysTemp.Find[${3rdPart}2]}) {
					/call GiveTo "${3rdPart}" ${ThePetID}
					/varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${3rdPart}2
					/ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
					}
				/if (!${2ndPart.Length}) {
					/for j 0 to ${InvSlot[pack${BagNum}].Item.Container}
					/if (${InvSlot[pack${BagNum}].Item.Item[${j}].ID} && ${InvSlot[pack${BagNum}].Item.Item[${j}].Name.Length}) {
						/call GiveTo "${InvSlot[pack${BagNum}].Item.Item[${j}].Name}" ${ThePetID}
						}
					/delay 10
					/next j
					/if (${j}>=8 && !${PetToysTemp.Find[${PetToySpell}]}) {
						/varset PetToysTemp ${PetToysTemp}|${PetToySpell}
						/ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
						}
					}
				}
			/if (${Cursor.Name.Find[Summoned:]}) {
				/call GiveTo "${Cursor.Name}" ${ThePetID}
				/varset PetToysTemp ${PetToysTemp}|${PetToySpell}
				/ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
				}
			/if (${InvSlot[pack${BagNum}].Item.Name.Find[Phantom Satchel]} || ${InvSlot[pack${BagNum}].Item.Name.Find[Pouch of Quellious]}) /call DestroyBag
			/if (${Window[InventoryWindow].Open}) /keypress inventory
			/goto :SkipPetToy
			}
:SkipPetToy
    |========================================
    | Reset spell vars
    |========================================
	/if (${FullText.Arg[2,|].Length}) {
		/varset FullText
		/varset 2ndPart
		/varset 3rdPart
		}
	/if (!${DoPetToys}) /return
		/next i
        /if (${Window[InventoryWindow].Open}) /keypress inventory
        /varset PetToysDone 1
	/doevents flush
	/return
	
Sub PopulateNPCs
	/varset LastSpawnCount ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1]}
	/if (${Me.Pet.ID} && ${PetID}!=${Me.Pet.ID}) /varset PetID ${Me.Pet.ID}
	/if (!${Spawn[${PetID}].ID} || ${Spawn[${PetID}].Type.Equal[corpse]}) /varset PetID 0
	/call RemoveNPCs
	/varset VarOldNPCCount ${VarNPCCount}
	/declare NPCID       int local
	/declare a           int local
	/declare b           int local
	/declare Compare     int local
	/declare NPCsInRange int local ${SpawnCount[npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4]}
	/for b 1 to ${NPCsInRange}
		/if (${VarNPCCount}>=${MaxMobs}) /return
		/varset NPCID 0
		/varset NPCID ${NearestSpawn[${b},npc targetable radius ${NPCRadius} zradius ${NPCZRadius} noalert 1 playerstate 4].ID}
		/if (${NPCID} && !${Spawn[${NPCID}].Master.Type.Equal[PC]} && ${Spawn[${NPCID}].Type.NotEqual[corpse]} && (${Spawn[${NPCID}].ConColor.NotEqual[GREEN]} || ${DebuffGreens})) {
			/varset Compare 0
			/for a 1 to ${MaxMobs}
				/if (${NPCID}==${MobList[${a}]}) /varset Compare 1
			/next a
			/if (!${Compare}) /call AddToMobList ${NPCID}
		}
	/next b
	/return

Sub PortUs(Line)
|--------------
|  Credit demonstar55
|--------------
/declare PortSpell string local
    /if (${Me.Class.ShortName.Equal[DRU]}) {
        /if (${Line.Equal[alra]}) /varset PortSpell Circle of Alra
        /if (${Line.Equal[arcstone]}) /varset PortSpell Circle of Arcstone
        /if (${Line.Equal[barindu]}) /varset PortSpell Circle of Barindu
        /if (${Line.Equal[blightfire]}) /varset PortSpell Circle of Blightfire Moors
        /if (${Line.Equal[brell]}) /varset PortSpell Circle of Brell's Rest
        /if (${Line.Equal[buriedsea]} || ${Line.Equal[buried]}) /varset PortSpell Circle of Buried Sea		
        /if (${Line.Equal[butcher]}) /varset PortSpell Circle of Butcher
        /if (${Line.Equal[cobalt]}) /varset PortSpell Circle of Cobalt Scar
        /if (${Line.Equal[commons]}) /varset PortSpell Circle of Commons
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset PortSpell Circle of the Combines		
        /if (${Line.Equal[dawnshroud]}) /varset PortSpell Circle of Dawnshroud
        /if (${Line.Equal[direwind]}) /varset PortSpell Circle of Direwind
        /if (${Line.Equal[domain]}) /varset PortSpell Circle of the Domain
		/if (${Line.Equal[east]} || ${Line.Equal[ekarana]}) /varset PortSpell Succor: East
        /if (${Line.Equal[feerrott]}) /varset PortSpell Circle of Feerrott
        /if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset PortSpell Circle of Great Divide
        /if (${Line.Equal[grimling]}) /varset PortSpell Circle of Grimling
        /if (${Line.Equal[grounds]}) /varset PortSpell Circle of the Grounds
        /if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset PortSpell Circle of Karana
        /if (${Line.Equal[iceclad]}) /varset PortSpell Circle of Iceclad		
        /if (${Line.Equal[lavastorm]}) /varset PortSpell Circle of Lavastorm
		/if (${Line.Equal[Lceanium]}) /varset PortSpell Circle of Lceanium 
        /if (${Line.Equal[loping]}) /varset PortSpell Circle of Loping Plains
        /if (${Line.Equal[misty]}) /varset PortSpell Circle of Misty
        /if (${Line.Equal[moors]}) /varset PortSpell Circle of Blightfire Moors		
        /if (${Line.Equal[natimbi]}) /varset PortSpell Circle of Natimbi		
        /if (${Line.Equal[nexus]}) /varset PortSpell Circle of the Nexus
        /if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset PortSpell Circle of Knowledge		
        /if (${Line.Equal[ro]} || ${Line.Equal[sro]}) /varset PortSpell Circle of Ro
        /if (${Line.Equal[shards]}) /varset PortSpell Circle of the Landing
        /if (${Line.Equal[skyfire]}) /varset PortSpell Wind of the North
		/if (${Line.Equal[slaughter]} || ${Line.Equal[wall of slaughter]}) /varset PortSpell Circle of Slaughter
        /if (${Line.Equal[south]} || ${Line.Equal[ej]} || ${Line.Equal[emerald]}) /varset PortSpell Wind of the South
        /if (${Line.Equal[steamfont]}) /varset PortSpell Circle of Steamfont
        /if (${Line.Equal[steppes]}) /varset PortSpell Circle of The Steppes
        /if (${Line.Equal[stonebrunt]}) /varset PortSpell Circle of Stonebrunt
        /if (${Line.Equal[succor]} || ${Line.Equal[evac]}) /varset PortSpell succor
        /if (${Line.Equal[surefall]}) /varset PortSpell Circle of Surefall Glade
        /if (${Line.Equal[tempest]}) /varset PortSpell Circle of the Tempest
        /if (${Line.Equal[time]}) /varset PortSpell Circle of Plane of Time
        /if (${Line.Equal[tox]}) /varset PortSpell Circle of Toxxulia
        /if (${Line.Equal[twilight]}) /varset PortSpell Circle of Twilight
        /if (${Line.Equal[undershore]}) /varset PortSpell Circle of Undershore
        /if (${Line.Equal[wakening]}) /varset PortSpell Circle of Wakening Lands
		/if (${Line.Equal[bind]}) /varset PortSpell Teleport Bind
		/if (${Line.Equal[hall]}) /varset PortSpell Teleport to Guild Hall Anchor
		/if (${Line.Equal[succor]} || ${Line.Equal[evac]}) {
			/if (${Me.AltAbilityReady[Exodus]}) {
				/varset PortSpell Succor
				} else {
				/if (${Me.Level}>=57) {
					/varset PortSpell Succor
				} else { 
					/varset PortSpell Lesser Succor
					}
				}
			}
		}
	/if (${Me.Class.ShortName.Equal[WIZ]}) {
		/if (${Line.Equal[alra]}) /varset PortSpell Alra Portal
		/if (${Line.Equal[arcstone]}) /varset PortSpell Arcstone Portal
        /if (${Line.Equal[barindu]}) /varset PortSpell Barindu Portal
		/if (${Line.Equal[blightfire]} || ${Line.Equal[moors]}) /varset PortSpell Blightfire Moors Portal
		/if (${Line.Equal[bloodfields]}) /varset PortSpell Bloodfields Portal
		/if (${Line.Equal[brell]}) /varset PortSpell Brell's Rest Portal		
        /if (${Line.Equal[cazic]}) /varset PortSpell Cazic Portal
        /if (${Line.Equal[cobalt]}) /varset PortSpell Cobalt Scar Portal
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset PortSpell Combine Portal
		/if (${Line.Equal[commons]}) /varset PortSpell Common Portal
        /if (${Line.Equal[dawnshroud]}) /varset PortSpell Dawnshroud Portal
		/if (${Line.Equal[dragonscale]}) /varset PortSpell Dragonscale Hills Portal		
		/if (${Line.Equal[ej]} || ${Line.Equal[emerald]}) /varset PortSpell Markar's Relocation		
		/if (${Line.Equal[gfay]}) /varset PortSpell Fay Portal
		/if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset PortSpell Great Divide Portal
		/if (${Line.Equal[grimling]}) /varset PortSpell Grimling Portal
        /if (${Line.Equal[grounds]}) /varset PortSpell Grounds Portal		
		/if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset PortSpell North Portal
        /if (${Line.Equal[katta]}) /varset PortSpell Katta Castrum Portal        
		/if (${Line.Equal[iceclad]}) /varset PortSpell Iceclad Portal
		/if (${Line.Equal[icefall]}) /varset PortSpell Icefall Glacier Portal
		/if (${Line.Equal[lceanium]}) /varset PortSpell Blightfire Lceanium Portal		
        /if (${Line.Equal[natimbi]}) /varset PortSpell Natimbi Portal		
		/if (${Line.Equal[nek]}) /varset PortSpell Nek Portal
		/if (${Line.Equal[nexus]}) /varset PortSpell Nexus Portal
		/if (${Line.Equal[nro]}) /varset PortSpell Ro Portal		
		/if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset PortSpell Knowledge Portal		
		/if (${Line.Equal[sarith]}) /varset PortSpell Sarith Portal
		/if (${Line.Equal[skyfire]}) /varset PortSpell Tishan's Relocation
		/if (${Line.Equal[shards]}) /varset PortSpell Shard's Landing Portal
        /if (${Line.Equal[slaughter]}) /varset PortSpell Slaughter Portal
		/if (${Line.Equal[sro]} || ${Line.Equal[ro]} || ${Line.Equal[nro]}) /varset PortSpell Evacuate Ro
        /if (${Line.Equal[sunderock]}) /varset PortSpell Sunderock Springs Portal		
		/if (${Line.Equal[tempest]} || ${Line.Equal[temple]} || ${Line.Equal[tempesttemple]}) /varset PortSpell Tempest Temple Portal
		/if (${Line.Equal[time]}) /varset PortSpell Plane of Time Portal
		/if (${Line.Equal[tox]}) /varset PortSpell Tox Portal
        /if (${Line.Equal[twilight]}) /varset PortSpell Twilight Portal
		/if (${Line.Equal[twk]} || ${Line.Equal[westkarana]}) /varset PortSpell West Karana Portal
		/if (${Line.Equal[undershore]}) /varset PortSpell Undershore Portal
		/if (${Line.Equal[wakening]}) /varset PortSpell Wakening Lands Portal
        /if (${Line.Equal[wkarana]}) /varset PortSpell West Portal
		/if (${Line.Equal[primary]} || ${Line.Equal[panchor]} || ${Line.Equal[primaryanchor]}) /varset PortSpell Primary Anchor Portal
		/if (${Line.Equal[secondary]} || ${Line.Equal[sanchor]} || ${Line.Equal[secondaryanchor]}) /varset PortSpell Secondary Anchor Portal
        /if (${Line.Equal[succor]} || ${Line.Equal[evac]}) {
            /if (${Me.Level}>=57) {
                /varset PortSpell Evacuate
            } else { 
                /varset PortSpell Lesser Evacuate
            }
        }
    }
	/if (!${Me.Book[${PortSpell}]} && !${Me.AltAbilityReady[${PortSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		/return
		}
    /if (${Me.Book[${PortSpell}]} || ${Me.AltAbilityReady[${PortSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 g "Porting with" o "${PortSpell}"
        /target id ${Me.ID}
		/if (${Me.AltAbilityReady[${PortSpell}]}) {
			/call MQ2Cast "${PortSpell}" ALT 25s SpellFiller 3
			/return
			}
		/if (${Cursor.ID}) /autoinventory
        /call MQ2Cast "${PortSpell}" ${PortGem} 25s SpellFiller 3
		} else {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		}
	/return
	
Sub SendUs(Line,Client)
|--------------
|  Credit: Based on code from demonstar55
|--------------
/declare SendSpell string local
    /if (${Me.Class.ShortName.Equal[DRU]}) {
        /if (${Line.Equal[alra]}) /varset SendSpell Zephyr: Pillars of Alra
        /if (${Line.Equal[arcstone]}) /varset SendSpell Zephyr: Arcstone
        /if (${Line.Equal[barindu]}) /varset SendSpell Zephyr: Barindu
        /if (${Line.Equal[blightfire]}) /varset SendSpell Zephyr: Blightfire Moors
		/if (${Line.Equal[bloodfields]} || ${Line.Equal[bloodfield]}) /varset SendSpell Zephyr: Bloodfields
        /if (${Line.Equal[brell]}) /varset SendSpell Zephyr: Brell's Rest
        /if (${Line.Equal[buriedsea]} || ${Line.Equal[buried]}) /varset SendSpell Zephyr: Buried Sea		
        /if (${Line.Equal[butcher]}) /varset SendSpell Zephyr: Butcherblock
        /if (${Line.Equal[cobalt]}) /varset SendSpell Zephyr: Cobalt Scar
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset SendSpell Zephyr: the Combines
        /if (${Line.Equal[commons]}) /varset SendSpell Zephyr: Commonlands
		/if (${Line.Equal[dawnshroud]}) /varset SendSpell Zephyr: Dawnshroud
        /if (${Line.Equal[direwind]}) /varset SendSpell Zephyr: Direwind
        /if (${Line.Equal[domain]} || ${Line.Equal[beasts domain]} || ${Line.Equal[beast]} || ) /varset SendSpell Zephyr: Beasts' Domain
        /if (${Line.Equal[feerrott]}) /varset SendSpell Zephyr: Feerrott
        /if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset SendSpell Zephyr: Great Divide
        /if (${Line.Equal[grimling]}) /varset SendSpell Zephyr: Grimling
        /if (${Line.Equal[grounds]}) /varset SendSpell Zephyr: the Grounds
        /if (${Line.Equal[karana]} || ${Line.Equal[nkarana]}) /varset SendSpell Zephyr: Karana
        /if (${Line.Equal[iceclad]}) /varset SendSpell Zephyr: Iceclad		
        /if (${Line.Equal[lavastorm]}) /varset SendSpell Zephyr: Lavastorm
        /if (${Line.Equal[loping]}) /varset SendSpell Zephyr: Loping Plains
        /if (${Line.Equal[misty]}) /varset SendSpell Zephyr: Misty
        /if (${Line.Equal[moors]}) /varset SendSpell Zephyr: Blightfire Moors		
        /if (${Line.Equal[natimbi]}) /varset SendSpell Zephyr: Natimbi		
        /if (${Line.Equal[nexus]}) /varset SendSpell Zephyr: the Nexus
        /if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset SendSpell Zephyr: Knowledge		
        /if (${Line.Equal[ro]} || ${Line.Equal[sro]}) /varset SendSpell Zephyr: Ro
        /if (${Line.Equal[shards]}) /varset SendSpell Zephyr: Shard's Landing
        /if (${Line.Equal[steamfont]}) /varset SendSpell Zephyr: Steamfont
		/if (${Line.Equal[slaughter]} || ${Line.Equal[wos]}) /varset SendSpell Zephyr: Slaughter
        /if (${Line.Equal[steppes]}) /varset SendSpell Zephyr: The Steppes
        /if (${Line.Equal[stonebrunt]}) /varset SendSpell Zephyr: Stonebrunt
        /if (${Line.Equal[surefall]}) /varset SendSpell Zephyr: Surefall Glade
        /if (${Line.Equal[tempest]}) /varset SendSpell Zephyr: Tempest Temple
        /if (${Line.Equal[time]}) /varset SendSpell Zephyr: Plane of Time
        /if (${Line.Equal[tox]}) /varset SendSpell Zephyr: Toxxulia
        /if (${Line.Equal[twilight]}) /varset SendSpell Zephyr: Twilight
        /if (${Line.Equal[undershore]}) /varset SendSpell Zephyr: Undershore
        /if (${Line.Equal[wakening]}) /varset SendSpell Zephyr: Wakening Lands
		/if (${Line.Equal[twk]} || ${Line.Equal[wkarana]}) /varset SendSpell Zephyr: West Karana
		} 
	/if (${Me.Class.ShortName.Equal[WIZ]}) {
		/if (${Line.Equal[arcstone]}) /varset SendSpell Translocate Arcstone 
        /if (${Line.Equal[barindu]}) /varset SendSpell Translocate Barindu 
		/if (${Line.Equal[bind]} || ${Line.Equal[translocate]}) /varset SendSpell Translocate
		/if (${Line.Equal[bloodfields]}) /varset SendSpell Translocate Bloodfields 
		/if (${Line.Equal[brell]}) /varset SendSpell Translocate Brell's Rest 		
        /if (${Line.Equal[cazic]}) /varset SendSpell Translocate Cazic 
        /if (${Line.Equal[cobalt]}) /varset SendSpell Translocate Cobalt Scar 
        /if (${Line.Equal[combine]} || ${Line.Equal[dreadlands]}) /varset SendSpell Translocate Combine 
		/if (${Line.Equal[commons]}) /varset SendSpell Translocate Common 		
        /if (${Line.Equal[dawnshroud]}) /varset SendSpell Translocate Dawnshroud 
		/if (${Line.Equal[dragonscale]}) /varset SendSpell Translocate Dragonscale Hills
		/if (${Line.Equal[gfay]}) /varset SendSpell Translocate Fay 
		/if (${Line.Equal[greatdivide]} || ${Line.Equal[gd]}) /varset SendSpell Translocate Great Divide 
		/if (${Line.Equal[grimling]}) /varset SendSpell Translocate Grimling 
        /if (${Line.Equal[grounds]}) /varset SendSpell Translocate the Grounds 		
        /if (${Line.Equal[katta]}) /varset SendSpell Translocate Katta Castrum         
		/if (${Line.Equal[iceclad]}) /varset SendSpell Translocate Iceclad 
		/if (${Line.Equal[icefall]}) /varset SendSpell Translocate Icefall Glacier 
		/if (${Line.Equal[moors]}) /varset SendSpell Translocate Blightfire Moors 		
        /if (${Line.Equal[natimbi]}) /varset SendSpell Translocate Natimbi 		
		/if (${Line.Equal[nek]}) /varset SendSpell Translocate Nek 
		/if (${Line.Equal[nexus]}) /varset SendSpell Translocate Nexus 
		/if (${Line.Equal[nro]}) /varset SendSpell Translocate Ro 
		/if (${Line.Equal[alra]} || ${Line.Equal[pillars]}) /varset SendSpell Translocate Pillars of Alra		
		/if (${Line.Equal[pok]} || ${Line.Equal[knowledge]}) /varset SendSpell Translocate Knowledge
        /if (${Line.Equal[panchor]} || ${Line.Equal[primary]}) /varset SendSpell Translocate Primary Anchor
		/if (${Line.Equal[sanchor]} || ${Line.Equal[secondary]}) /varset SendSpell Translocate Primary Anchor
		/if (${Line.Equal[ro]} || ${Line.Equal[nro]}) /varset SendSpell Translocate Ro
		/if (${Line.Equal[sarith]}) /varset SendSpell Translocate Sarith 
		/if (${Line.Equal[shards]}) /varset SendSpell Translocate Shard's Landing 
        /if (${Line.Equal[slaughter]}) /varset SendSpell Translocate Slaughter 
		/if (${Line.Equal[stonebrunt]}) /varset SendSpell Translocate Stonebrunt
        /if (${Line.Equal[sunderock]}) /varset SendSpell Translocate Sunderock Springs 
		/if (${Line.Equal[tempest]} || ${Ling.Equal[temple]}) /varset SendSpell Translocate Tempest Temple
		/if (${Line.Equal[time]}) /varset SendSpell Translocate Plane of Time 
		/if (${Line.Equal[tox]}) /varset SendSpell Translocate Tox 
        /if (${Line.Equal[twilight]}) /varset SendSpell Translocate Twilight 
		/if (${Line.Equal[twk]} || ${Line.Equal[west karana]} || ${Line.Equal[wkarana]}) /varset SendSpell Translocate West Karana 
		/if (${Line.Equal[undershore]}) /varset SendSpell Translocate Undershore 
		/if (${Line.Equal[wakening]}) /varset SendSpell Translocate Wakening Lands
		}
	/if (!${Me.Book[${SendSpell}]} && !${Me.AltAbilityReady[${SendSpell}]}) {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		/return
		}
    /if (${Me.Book[${SendSpell}]} || ${Me.AltAbilityReady[${SendSpell}]}) {
		/if (${Spawn[${Spawn[${Client}].Pet.ID}].Distance3D}>100) {
			/call AnnounceMessage "${ChatChannel}" 3 m "${Client}" g "is to far away to cast" o "${SendSpell}"
			/return
			}
		/invoke ${Spawn[${Client}].DoTarget}
		/call AnnounceMessage "${ChatChannel}" 2 g "Porting with" o "${SendSpell}"
        /if (${Cursor.ID}) /autoinventory
        /if (${Me.AltAbilityReady[${SendSpell}]}) {
			/call MQ2Cast "${SendSpell}" ALT 25s SpellFiller 3
			/return
			}
		/call MQ2Cast "${SendSpell}" ${PortGem} 25s SpellFiller 3
		} else {
		/call AnnounceMessage "${ChatChannel}" 2 y "I do not have a port spell for" o "${Line}"
		}
	/return	
	
	
Sub QuietMiracle
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]} && ${Group} && ${Me.AltAbilityReady[Quiet Miracle]}) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance} < 100 && ${Group.Member[${i}].CurrentMana} <40 && ${Group.Member[${i}].Class.CanCast}) {
				/target targetable id ${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Quiet Miracle!" g "on" m "${Target.CleanName}"
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for QM"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
                	/if (${Target.Buff[Shroud of the Miracle].ID}) {
                        /call CreateTimer QM${Target.ID} 1m
						/return
						}
                    /call MQ2Cast "Quiet Miracle" alt 0 SpellFiller 3
					/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Quiet Miracle"
					/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Quiet Miracle"
					}
				}
		/next i
		}
	/return	

Sub ParagonOfSpirit
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (${Debug}) /echo \ag Entering \ao Paragon sub
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.Equal[COMBAT]} && ${Group} && (${Me.AltAbilityReady[Paragon of Spirit]} || ${Me.AltAbilityReady[Focused Paragon of Spirit]})) {
		 /for i 0 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance} < 100 && ${Group.Member[${i}].CurrentMana} <40 && ${Group.Member[${i}].Class.CanCast}) {
				/target targetable id ${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Paragon of Spirit!" g "on" m "${Target.CleanName}"
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for Paragon of Spirit"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Me.AltAbilityReady[Paragon of Spirit]}) {
						/call MQ2Cast "Paragon of Spirit" alt 0 SpellFiller 3
						/if (${castReturn.Equal[CAST_SUCCESS]}) {
							/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Paragon of Spirit"
							/return
							}
						/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Paragon of Spirit"
						}
					/if (${Me.AltAbilityReady[Focused Paragon of Spirits]} && !${Me.Song[Paragon of spirit].ID} && !${Me.AltAbilityReady[Paragon of Spirit]}) {
						/call MQ2Cast "Focused Paragon of Spirits" alt 0 SpellFiller 3
						/if (${castReturn.Equal[CAST_SUCCESS]}) {
							/call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is blessed with a" o "Focused Paragon of Spirit"
							/return
							}
						/if (${castReturn.NotEqual[CAST_SUCCESS]}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Focused Paragon of Spirit"						
						}
					}
				}
		/next i
		}
	/return		

Sub PetHealing
	/if (!${Me.Pet.ID}) /return
	/if (${SelfPetHealing}) {
		/if (!${Me.Book[${Me.Book[${Spell[${SelfPetHeal}].RankName}]}].ID}) {
			/call AnnounceMessage ${ChatChannel} 2 m "${{SelfPetHeal}" r "not in spellbook"
			/varset SelfPetHealing FALSE
			/return
			}
		/if (!${Me.Gem[${SelfPetHeal}]}) {
			/memorize "${Spell[${SelfPetHeal}].RankName}" ${SelfPetHealGem}
			/delay 5s ${Me.SpellReady[${Spell[${SelfPetHeal}].RankName}]}
			}
		/if (${Me.Pet.PctHPs}<${SelfPetHealPct}) {
			/if (${Me.SpellReady[${Spell[${SelfPetHeal}].RankName}]}) {
				/call MQ2Cast "${Spell[${SelfPetHeal}].RankName}" ${SelfPetHealGem} 10s Check4Pad 3	
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfully healed ->" m "${Me.Pet.CleanName}" g with o "${Spell[${SelfPetHeal}].RankName}"
					/if (!${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 1 r "Problem trying to heal pet!"
					}
				}
			}
		}
	/return

Sub PetDelayedHealing	
	/if (!${Me.Pet.ID}) /return
	/if (${PetDelayedHealing}) {
		/if (!${Me.Book[${Me.Book[${Spell[${PetDelayedHeal}].RankName}]}].ID}) {
			/call AnnounceMessage ${ChatChannel} 2 m "${PetDelayedHeal}" r "not in spellbook"
			/varset PetDelayedHealing FALSE
			/return
			}
		/if (!${Me.Gem[${PetDelayedHeal}]}) {
				/memorize "${Spell[${PetDelayedHeal}].RankName}" ${PetDelayedHealGem}
				/delay 5s ${Me.SpellReady[${Spell[PetDelayedHeal].RankName}]}
				}
		/if (${Me.Pet.PctHPs}<${PetDelayedHealPct}) {
			/if (${Me.SpellReady[${Spell[${PetDelayedHeal}].RankName}]}) {
				/call MQ2Cast "${Spell[${PetDelayedHeal}].RankName}" ${PetDelayedHealGem} 10s Check4Pad 3	
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Me.Pet.CleanName}" g has o "${Spell[${PetDelayedHeal}].RankName}"
					/if (!${castReturn.Equal[CAST_SUCCESS]} && ${ReportPetBuffs}) /call AnnounceMessage "${ChatChannel}" 2 o "${Spell[${PetDelayedHeal}].RankName}" r "wont take hold!!"
					}
				}
			}
		}
	/return	
	
Sub SpellFiller
	/return
	
Sub RallyingCall
	/declare i int local
	/if (!${RDPause} && ${Me.CombatState.NotEqual[COMBAT]} && ${Group} && ${Me.AltAbilityReady[Rallying Call]}) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<100 && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG]} && ${Group.Member[${i}].CurrentMana}<30 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<30)) {
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "Rallying Call!" g "on" m "${Group.Member[${i}].CleanName}"
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for RC"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Twist.Twisting}) /squelch /twist stop	
                    /call MQ2Cast "Rallying Call" alt 0 SpellFiller 3
					/if (${castReturn.Equal[CAST_SUCCESS]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is renewed with a" o "Rallying Call"
					/if (${castReturn.NotEqual[CAST_SUCCESS]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Rallying Call"
					/squelch /twist start
					}
				}
		/next i
		}
	/return	

Sub DichotomicPsalm
	/declare i int local
	/if (!${RDPause} && ${Group} && ${Cast.Ready[Dichotomic Psalm]} && ${Me.PctEndurance}>10) {
		 /for i 1 to ${Group}
			/if (${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Distance}<100 && (${Select[${Group.Member[${i}].Class.ShortName},SHM,CLR,DRU,WIZ,MAG,ENC,NEC,PAL,SK,BRD,RNG,BST]} && ${Group.Member[${i}].CurrentMana}<50 || ${Select[${Group.Member[${i}].Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]} && ${Group.Member[${i}].PctEndurance}<50)) {
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /target ID ${Group.Member[${i}].ID}
				/delay 1 ${Target.ID}==${Group.Member[${i}].ID}
				/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting a" o "DoDichotomic!" g "on" m "${Group.Member[${i}].CleanName}"
				/if (${Target.ID}!=${Group.Member[${i}].ID}) {
					/if (${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 3 y "failed to target" m "${Group.Member[${i}].CleanName} (${Group.Member[${i}].ID}" y "for Dichiotomic Psalm"
					/target clear
					/return
					}
				/if (${Target.ID}==${Group.Member[${i}].ID}) {
					/if (${Twist.Twisting}) /squelch /twist stop
                    /squelch /twist once ${Me.Gem[Dichotomic Psalm]}
					/delay 7s !${Cast.Timing}
					/if (!${Cast.Ready[Dichotomic Psalm]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ is renewed with a" o "Dichotomic Psalm"
					/if (${Cast.Ready[Dichotomic Psalm]} && ${ReportHeals}) /call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "Dichotomic Psalm"
					/squelch /twist start
					}
				}
		/next i
		}
	/return	
	
	
Sub RefreshAlerts
	/declare i int local
	/call LoadVar IgnoreNPCList ${Zone.ShortName} | IgnoreNPCList RDCommon.ini LOAD string
	/call LoadVar IgnoreNPCList AllZones | IgnoreNPCListCommon RDCommon.ini LOAD string
	/echo ${IgnoreNPCListCommon}
	/alert clear 1
	/declare alertlistlen int local ${Math.Calc[${IgnoreNPCList.Count[|]}-1].Int}
	/declare alertlistlen2 int local ${Math.Calc[${IgnoreNPCListCommon.Count[|]}-1].Int}
	/echo NPC Ignore List for : ${Zone.Name} ( Total NPC: ${alertlistlen} )
	/if (${alertlistlen} > 0) {
		/for i 1 to ${alertlistlen}
			/alert add 1 ${IgnoreNPCList.Arg[${i},|]}
		/next i
	} else {
		/echo No npcs are ignored in ${Zone.Name}, use /ignorenpc <Name> to add NPCs
	}
	/echo NPC Ignore List for : Common ( Total NPC: ${alertlistlen2} )
	/if (${alertlistlen2} > 0) {
		/for i 1 to ${alertlistlen2}
			/alert add 1 ${IgnoreNPCListCommon.Arg[${i},|]}
		/next i
	} else {
		/echo No npcs are ignored in Common, use /ignorenpc <Name> to add NPCs
	}
	/return
		

Sub RemoveFromQueue(int Buffee,int BuffNumber)
	/if (${Debug}) /echo \ag Entering: \ao Remove from que Start \am ${Spawn[${Buffee}].CleanName} \ao Buff number \ay ${BuffNumber} \ao Queue Count = \ag ${QueueCount}
	/doevents IRC
	/doevents Chat
	/declare m int local
	/for m 1 to 25
		/if (((!${Spawn[${DoBuffQueue[${m},1]}].ID}) || ((${DoBuffQueue[${m},1]}==${Buffee} || (!${Buffee} && (${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].CleanName}].Index} || ${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].Master}].Index} )) || ${Select[${Spell[${DoBuffID[${DoBuffQueue[${m},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) && (${DoBuffID[${DoBuffQueue[${m},2]}]}==${BuffNumber} || ${DoBuffQueue[${m},2]}==${BuffNumber}))) && ${DoBuffQueue[${m},1]}) {
			/if (${Debug}) {
				/echo First remove from que check good, removing ${DoBuffQueue[${m},1]} and ${DoBuffQueue[${m},2]}
				/echo (((!${Spawn[${DoBuffQueue[${m},1]}].ID}) || ((${DoBuffQueue[${m},1]}==${Buffee} || (!${Buffee} && (${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].CleanName}].Index} || ${Group.Member[${Spawn[${DoBuffQueue[${m},1]}].Master}].Index} )) || ${Select[${Spell[${DoBuffID[${DoBuffQueue[${m},2]}]}].TargetType},"Group v2","AE PC v2","Group v1","AE PC v1"]}) && (${DoBuffID[${DoBuffQueue[${m},2]}]}==${BuffNumber} || ${DoBuffQueue[${m},2]}==${BuffNumber}))) && ${DoBuffQueue[${m},1]})
				}
			/varset DoBuffQueue[${m},1] 0
			/varset DoBuffQueue[${m},2] 0
			/if (${QueueCount}>0)  {
				/varcalc QueueCount ${QueueCount}-1
				}
		}
		/if (${Defined[RezBuff${DoBuffQueue[${m},2]}]}) {
			/if (!(${Spawn[${DoBuffQueue[${m},1]}].Type.Equal[Corpse]} ^^ ${RezBuff${DoBuffQueue[${m},2]}})) {
				/if (${Debug}) /echo second REZ heck good, removing ${DoBuffQueue[${m},1]} and ${DoBuffQueue[${m},2]}
				/varset DoBuffQueue[${m},1] 0
				/varset DoBuffQueue[${m},2] 0
				/if (${QueueCount}>0)  {
					/varcalc QueueCount ${QueueCount}-1
					}
				}
			}
	/next m
	/if (${Debug}) /echo \am Exiting: Remove From Que \ao Queue count = \af ${QueueCount}
	/return
	
Sub RemoveNPCs
	/declare a int local
	/declare b int local
	/for a 1 to ${MaxMobs}
		/if ((${Spawn[${MobList[${a}]}].Type.Equal[Corpse]} || ${Spawn[${MobList[${a}]}].Master.Type.Equal[PC]} || !${Spawn[${MobList[${a}]}].ID} || ${Spawn[${MobList[${a}]}].Distance}>${NPCRadius}) && ${MobList[${a}]}) {
			/varset MobList[${a}] 0
			/for b 1 to ${DebuffTotal}
				/varset DebuffArray[${a},${b}] 0
			/next b
			/if (${VarNPCCount}) /varcalc VarNPCCount ${VarNPCCount}-1
		}
	/next a
	/return
	
Sub Retort
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[RetortTimer]}) /call CreateTimer RetortTimer
	/if (${Me.SpellReady[${Spell[${RetortSpell}].RankName}]}) {
		/if (!${RetortTimer}) {
			/if (${Spawn[ID ${MainTankID}].Distance}<=200) {
				/if (${MainTankID}) {
					/if (!${Target.Buff[${Spell[${RetortSpell}].RankName}].ID}) {
						/if (${Me.PctMana}>10) {
							/if (${HealDebug}) /echo casting ${RetortSpell} from Gem ${RetortSpellGem} at ${Target.CleanName}
							/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
							/call MQ2Cast "${Spell[${RetortSpell}].RankName}" ${RetortSpellGem} 1s Check4Pad
							/delay 5s !${Me.Casting}
							/if (${castReturn.Equal[CAST_SUCCESS]}) {
								/varset RetortTimer 90s
								/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 t "RETORT to ->" m "${Target.CleanName}" g "<- using" o "${Spell[${RetortSpell}].RankName}"
								}
							}
						}
					}
				}
			}
		/if (${HealDebug} && ${castReturn.Equal[CAST_SUCCESS]}) /echo Casting successful
		/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
			/varset RetortTimer 30s	
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 r "Failed!->" m "${Target.CleanName}" y "<- has something blocking" o "${Spell[${RetortSpell}].RankName}"
			}
		}
	/return	

Sub Ward
|========================================
|code based on Nytemyst's AFCleric
|========================================
	/if (!${Defined[WardTimer]}) /call CreateTimer WardTimer
	/if (${Me.SpellReady[${Spell[${WardSpell}].RankName}]} && !${WardTimer} && ${Spawn[ID ${MainTankID}].Distance} <= 200 && ${MainTankID} && ${DoWard} && ${Me.CombatState.Equal[COMBAT]} && !${Target.Buff[${Spell[${WardSpell}].RankName}].ID} && ${Me.PctMana}>10) {
		/if (${Debug}) /echo casting ${WardSpell} from Gem ${WardSpellGem} at ${Target.CleanName}
		/if (${Target.ID}!=${MainTankID}) /target targetable id ${MainTankID}
		/call MQ2Cast "${Spell[${WardSpell}].RankName}" ${WardSpellGem} 1s Check4Pad
		/if (${castReturn.Equal[CAST_SUCCESS]}) {
			/varset WardTimer 180s
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 t "Warding ->" o "${Target.CleanName}" g "<- with" o "${Spell[${WardSpell}].RankName}"
			}
		/if (${Debug} && ${castReturn.Equal[CAST_SUCCESS]}) /echo \ao Casting successful
		/if (${castReturn.Equal[CAST_TAKEHOLD]} || ${castReturn.Equal[CAST_NOTHOLD]}) {
			/varset WardTimer 30s	
			/if (${ReportHeals}) /call AnnounceMessage "${HealChannel}" 4 r "FAILED! ->" m "${Target.CleanName}" y "<-has something blocking" o "${Spell[${WardSpell}].RankName}"
			}
		}
	/return	

Sub SetTwists
	/declare i int local 1
	/varset CombatTwist None
	/for i 1 to ${MaxGems}
		/if (${SongsArray${i}.NotEqual[Song Name]}) {
			/if (${i}>1) {
				/if (${CombatTwist.Equal[None]}) /varset CombatTwist
				/varset CombatTwist ${CombatTwist} ${Me.Gem[${Spell[${SongsArray${i}}].RankName}]}
			} else {
				/if (${CombatTwist.Equal[None]}) /varset CombatTwist
				/varset CombatTwist ${Me.Gem[${Spell[${SongsArray${i}}].RankName}]}
			}
		}
	/next i
	/varset RestTwist None
	/for i ${Math.Calc[${MaxGems}+1]} to ${Math.Calc[${MaxGems}*2]}
		/if (${SongsArray${i}.NotEqual[Song Name]}) {
		/if (${i}>${Math.Calc[${MaxGems}+1]}) {
			/if (${RestTwist.Equal[None]}) /varset RestTwist
			/varset RestTwist ${RestTwist} ${Me.Gem[${Spell[${SongsArray${i}}].RankName}]}
		} else {
			/if (${RestTwist.Equal[None]}) /varset RestTwist
			/varset RestTwist ${Me.Gem[${Spell[${SongsArray${i}}].RankName}]}
			}
		}
	/next i
	/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs 1
	/return
	
Sub ShouldIHeal
	/if (!${RDPause} && ${HealFD} && ${Target.State.NotEqual["FEIGN"]} && ${Select[${Target.Class.ShortName},MNK,NEC,SHD]}) /return
	/if (!${RDPause} && ${Target.Type.NotEqual[NPC]} && ${Target.PctHPs}<${HealPct} && ${Target.Distance}<${Int[${Spell[${FastHealID}].MyRange}]}) /call DoHeal ${Target.ID} Fast
	/if (!${CheckGroupTimer} && ${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) /call CheckGroup
	/return

Sub ShrinkStuff
	/declare i int local
    /if (${ShrinkSelfOnly} && ${Me.Height}>1.89) {
        /target ${Me}
        /call MQ2Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
        /call MQ2Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
		} else {
        /for i 0 to ${Math.Calc[${Group.GroupSize}-1]}
            /if (${Group.Member[${i}].Height}>1.89 && ${Group.Member[${i}].Distance}<50) {
                /target ${Group.Member[${i}]}
                /call MQ2Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
                /call MQ2Cast "${ShrinkSpell}" ${ShrinkGem} 1s Check4Pad
				}
			/next i
		}
	/return	
	
Sub SingSongs(bool NewTwist)
	/if (!${RDPause} && ${Me.Standing}) {
		/if (${Twist} && ((!${Melee.Combat} && ${RestTwist.Equal[None]}) || (${Melee.Combat} && ${CombatTwist.Equal[None]}) || (${SpawnCount[npc targetable radius ${AutoRestRadius} zradius 50 noalert 1]} && ${AutoRestOff} && !${Melee.Combat} && !${SpawnCount[npc radius ${NPCRadChk} zradius 50 noalert 1]}))) {
			/squelch /twist stop
			/return
		}
		/if (!${Melee.Combat} && !${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]} && (!${Twist} || ${Twist.List.NotEqual[${RestTwist} ]} || ${NewTwist}) && (!${SpawnCount[npc targetable radius ${AutoRestRadius} zradius 50 noalert 1]} || !${AutoRestOff})) /squelch /twist ${RestTwist}
		/if ((${Melee.Combat} || ${SpawnCount[npc targetable radius ${NPCRadChk} zradius 50 noalert 1]}) && (!${Twist} || ${Twist.List.NotEqual[${CombatTwist} ]} || ${NewTwist})) /squelch /twist ${CombatTwist}
	}
	/varset TwistTimer 3s
	/return
	
Sub SummonStuff
   |I am not paused
   |I am a mage
   |I do not have a rod in inventory
   |I do not have something on cursor
   |Summon a rod
	/if (!${RDPause} && ${Me.Class.ShortName.Equal[MAG]} && !${Cursor.ID} && ${Me.Level}>43) {
		/if (!${FindItem[Wand of Pelagic Transvergence].ID} && !${FindItem[Wand of Pelagic Modulation].ID} && !${FindItem[Want of Phantasmal Transvergence].ID} && !${FindItem[Wand of Phantasmal Modulation].ID} && !${FindItem[Rod of Arcane Transvergence].ID} && !${FindItem[Rod of Spectral Transvergence].ID} && !${FindItem[Wand of Temporal Mastery].ID} && !${FindItem[Rod of Mechamagical Mastery].ID} && !${FindItem[Rod of Ethereal Transvergence].ID} && !${FindItem[Rod of Prime Transvergence].ID} && !${FindItem[Wand of Elemental Transvergence].ID} && !${FindItem[Rod of Mystical Transvergence].ID} && !${FindItem[Summoned: Modulating Rod].ID}) {
			/target myself
			/call MQ2Cast "${Spell[${RodSpell}].RankName}" ${RodGem} 5s SpellFiller 3
			/delay 10s ${Cursor.ID}
			/autoinv
			}
		/if (!${Bool[${FindItem[Summoned: Giant Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Large Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Medium Modulation Shard].ID}]} && !${Bool[${FindItem[Summoned: Small Modulation Shard].ID}]} && ${Me.AltAbility[Summon Modulation Shard].ID}) {
			/call MQ2Cast "Summon Modulation Shard" ALT 10s SpellFiller 3
			/delay 10s ${Cursor.ID}			
			/autoinv
			}
		}
	|79497 = Summoned: Giant Modulation Shard
	|99782 = Wand of Pelagic Modulation
	|79322 = Summoned: Large Modulation Shard
	|79321 = Summoned: Medium Modulation Shard
	|79320 = Summoned: Small Modulation Shard
	|99783 = Wand of Pelagic Transvergence
	|76503 = Wand of Phantasmal Transvergence
	|76502 = Wand of Phantasmal Modulation
	|64951 = Rod of Arcane Transvergence
	|57264 = Rod of Spectral Transvergence
	|52888 = Wand of Temporal Mastery
	|52803 = Rod of Mechamagical Mastery
	|52709 = Rod of Prime Transvergence
	|52674 = Wand of Elemental Transvergence   
	|18745 = Rod of Ethereal Transvergence
	|6346 = Summoned: Modulating Rod   
	|3426 = Rod of Mystical Transvergence
	/if (${Select[${Cursor.ID},99783,99782,79497,79322,79321,79320,76503,76502,64951,57264,52888,52803,52709,52674,18745,6346,3426]}) /autoinv
	/if (${UseAmmoClicky}) {
			/if (!${FindItem[${AmmoItem}].ID} && ${FindItem[${AmmoClicky}].TimerReady}==0 && ${Me.FreeInventory}>1) {
			/call MQ2Cast "${AmmoClicky}" ${AmmoGem} 7s Check4Pad
			/delay 20s !${Me.Casting.ID}
			/if (${castReturn.Equal[CAST_SUCCESS]}) /autoinv
			}
		}
	/return
	
Sub Trader
	/if (!${Bool[${Plugin[MQ2AutoLogin]}]}) {
		/call AnnounceMessage ${ChetChannel} 1 r "You need MQ2AutoLogin to switch to trader"
		}
	/if (${TraderName.Equal[NULL]} || ${TraderName.Equal[Put the name of your Trader here]}) {
		/if (${Me.Class.ShortName.Equal[BRD]}) {
			/if (${Twist.Twisting}) /twist off
			/delay 5s ${Twist.Twisting}
			}
		/camp desktop
		/end
		}
	/if (${TraderName.NotEqual[NULL]}) {
		/if (${Twist.Twisting}) /twist off
		/switchchar ${TraderName}
		/return
		}
	/return

Sub XPCommon
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
	/if (${ReportMana} && ${Me.PctMana}<${ReportManaPct}) {
		/call AnnounceMessage "${ChatChannel}" 2 g "Medding, " T "${Me.PctMana}m"
		/varset ReportFM TRUE
		}
	/if (${DebuffTotal}) /call PopulateNPCs
	/varset AssistTimer 0
	/varset MATarget 999999
	/call MoveStuff
	:CampCheck
	/if (${MakeCamp.Status.Equal[ON]} && ${Me.XTarget}<1) /makecamp return
	/if (${MakeCamp.Status.Equal[ON]} && ${MakeCamp.CampDist}>10 && ${Me.XTarget}<1) /goto :CampCheck
|	/if (${FollowFlag} && !${Me.Moving} && !${Melee.Combat} && ${Spawn[${FollowGuy}].Distance}<${LeashDistance} ) /target clear
	/call MercStuff
	/return
|---------------
|	EVENTS
|---------------

	
Sub Event_AddAlert(line,MobName)
	/if (!(${IgnoreNPCList.Find[${MobName}]})) {
		/alert add 1 ${MobName}
		/varset IgnoreNPCList ${IgnoreNPCList}${MobName}|
		/ini RDCommon.ini IgnoreNPCList ${Zone.ShortName} "${IgnoreNPCList}"
|		/call RefreshAlerts
	} else {
		/echo The NPC ( ${MobName} ) is already on the /ignorenpc List
	}
	/return

Sub Event_AddAlertCommon(line,MobName)
	/if (!(${IgnoreNPCListCommon.Find[${MobName}]})) {
		/alert add 1 ${MobName}
		/varset IgnoreNPCListCommon ${IgnoreNPCListCommon}${MobName}|
		/ini RDCommon.ini IgnoreNPCList AllZones "${IgnoreNPCListCommon}"
		/call RefreshAlerts
	} else {
		/echo The NPC ( ${MobName} ) is already on the /ignorenpccommon List
	}
	/return	

Sub Event_AddCombatSong(Line,Song)
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
	/call AddSong 1 ${MaxGems} Combat ${Song}
	/return	
	
	
Sub Event_AddRestSong(Line,Song)
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
	/call AddSong ${Int[${Math.Calc[${MaxGems}+1]}]} ${Int[${Math.Calc[${MaxGems}*2]}]} Rest ${Song}
	/return

Sub Event_Campout
	/if (${Me.Class.ShortName.Equal[BRD]}) /twist off
	/echo You forgot to end the macro, DOH!
	/end
	/return	

Sub Event_CanNotSee
|	/if (${Guard} && ${MakeCamp.Status.Equal[ON]}) {
|		/target clear
|		/varset MATarget NULL
|		}		
	/if (${Target.ID} && ${MakeCamp.Status.Equal[ON]}) {
		/squelch /face fast nolook
		}
	/return
	
Sub Event_ChangeTank(Line,NewTank)
|========================================
|Idea based on Nytemyst's AFCleric
|========================================
	/if (${ChangeTank}==TRUE && ${UseGroupMA}==FALSE && ${UseRaidMA}==FALSE) {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${NewTank}"
		/call AnnounceMessage "${ChatChannel}" 2 y "Changing tank to" m "${NewTank}"
		}
	/return
	
Sub Event_Chat(ChatType,Sender,ChatText)
	/if (${ChatType.Equal[tell]} && ${Sender.Left[1].Compare[ ]}<0) /varset Sender ${Sender.Right[-2].Left[-1]}
	/if (${ChatType.Equal[tell]} && ${RelayTells} && (${Spawn[${Sender}].Type.Equal[PC]} || !${Spawn[${Sender}].ID})) /call AnnounceMessage "${ChatChannel}" 3 m "${Sender}" g "told me" w "${ChatText}" "--"
	/if (${ChatText.Find[has been updated.]}) /call AnnounceMessage "${ChatChannel}" 2 o "Task" y "Updated!"
	/if (${Defined[UseFranticHeal]}) {
		/if (${ChatText.Find[Frantic Heal Now!]} && ${UseFranticHeal} && ${Spawn[${Sender}].ID}==${MainTankID}) /call FranticHeal
		}
	/if (${ChatText.Find[change tank]} && ${Spawn[pc ${ChatText.Arg[3]}].ID} && ${Raid.Members}) /varset MA1 ${ChatText.Arg[3]}
	/if (${DoBuffTotal} && ${DoBuffs} && ${Sender.NotEqual[${Me.CleanName}]} && (${Spawn[pc ${Sender}].ID} || ${Spawn[corpse ${Sender}].ID})) /call CheckDoBuffs "${Sender}" "${ChatText}"
	/if (${Defined[DoPetToys]}) {
		/if (${ChatText.Find[pet toys]} && ${DoPetToys} && ${Me.Class.ShortName.Equal[MAG]}) {
			/if (${Spawn[${Sender}].Pet.ID}) {
				/call PetToys ${Spawn[${Sender}].Pet.ID}
				/goto :pettoysend
				} else /if (!${Spawn[${Sender}].Pet.ID}) {
					/if (${Spawn[${ChatText.Arg[3]}].ID} && ${Spawn[${ChatText.Arg[3]}].Type.Equal[pet]}) {
						/call PetToys ${Spawn[${ChatText.Arg[3]}].ID}
						/goto :pettoysend
						}
					} else /if (!${Spawn[${Sender}].Pet.ID} && (!${Spawn[${ChatText.Arg[3]}].ID} || ${Spawn[${ChatText.Arg[3]}].Type.NotEqual[pet]}) /call AnnounceMessage "${ChatChannel}" 3 r error m "${Sender}" y "has no pet"
			}
		:pettoysend						
		}		
	/if (${Defined[DoPorts]}) {
		/if (${ChatText.Find[send me to]} && ${DoPorts} && ${Select[${Me.Class.ShortName},DRU,WIZ]}) {
			/call SendUs ${ChatText.Arg[4]} ${Sender}
			/return
			}
		}
	/if (${ChatText.Find[open door]} || ${ChatText.Find[click door]}) {
		/doortarget
		/delay 1s
		/face door
		/if (${DoorTarget.Distance}>20) {
			/call AnnounceMessage ${ChatChannel} 2 r ERROR y "Door to far away"
			} else {
			/click left door
			}
		}
	/if (${MasterList.Find[${Sender}]} || ${MasterList2.Find[${Sender}]} || ${MasterList3.Find[${Sender}]} || ${MasterList4.Find[${Sender}]} || ${MasterList5.Find[${Sender}]}) {
		/if (${ChatText.Find[check ini]}) /call INICheck1
		/if (${ChatText.Find[Add to Masterlist]}) /call AddMaster ${ChatText.Arg[4]}
		/if (${ChatText.Find[mount up]} && !${Me.Mount.ID} && !${Me.Invis} && !${RDPause} && !${Me.FeetWet} && !${RestrictedList.Find[|NoMount|]}) /call MQ2Cast "${MountItem}" item 10s Check4Pad
		/if (${Defined[DoPorts]}) {
			/if (${ChatText.Find[portto]} && ${DoPorts} && ${Select[${Me.Class.ShortName},DRU,WIZ]}) {
				/call PortUs ${ChatText.Arg[2]}
				/return
				}
			}
		/if (${ChatText.Left[1].Equal[/]}) /docommand ${ChatText}
		/if ((${ChatText.Find[move up]} || ${ChatText.Find[camp here]} || ${ChatText.Find[follow me]}) && !${Me.Standing}) /stand
		/if (${ChatText.Find[move up]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${MakeCamp.Status.Equal[ON]}) /makecamp loc ${Spawn[pc ${Sender}].Y} ${Spawn[pc ${Sender}].X}
            /delay ${Math.Rand[30]}
			/moveto loc ${Math.Calc[${Spawn[pc ${Sender}].Y}-${MoveUpJitter}+${Math.Rand[${MoveUpJitter}*2]}]} ${Math.Calc[${Spawn[pc ${Sender}].X}-${MoveUpJitter}+${Math.Rand[${MoveUpJitter}*2]}]} loose
            /delay 10
            /face id ${Spawn[pc ${Sender}].ID}
			}
		/if (${ChatText.Find[camp here]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${MakeCamp.Status.Equal[ON]}) /makecamp off
			/makecamp loc ${Spawn[${Sender}].Y} ${Spawn[${Sender}].X}
			/varset CampX ${Spawn[${Sender}].X}
			/varset CampY ${Spawn[${Sender}].Y}
			}
		/if (${ChatText.Find[follow me]} && ${Sender.NotEqual[${Me.CleanName}]}) {
			/if (${ChatText.Arg[3].Length} && ${Spawn[pc ${ChatText.Arg[3]}].ID}) /varset FollowGuy ${Spawn[pc ${ChatText.Arg[3]}].ID}
			/if ((!${ChatText.Arg[3].Length} || !${Spawn[pc ${ChatText.Arg[3]}].ID}) && ${Spawn[pc ${Sender}].ID}) /varset FollowGuy ${Spawn[pc ${Sender}].ID}
			/target targetable id ${FollowGuy}
			/if (${MakeCamp.Status.Equal[ON]}) {
				/makecamp off ${MakeCamp.Status.Equal[OFF]}
				/delay 10s 
				}
			/delay 1s ${Target.ID}==${FollowGuy}
			/squelch /stick hold uw
			/varset FollowFlag TRUE
			/varset TravelMode ${ChatText.Find[travel]}
			/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 2 g Following m ${Target.CleanName}
			}
		/if (${ChatText.Find[stop]}) {
			/squelch /stick off
			/varset FollowFlag FALSE
			/varset FollowGuy 0
			}
		/if (${ChatText.Find[Current mana]} && ${Me.MaxMana}) /call AnnounceMessage "${ChatChannel}" 2 g "Mana: " w "${Me.PctMana}%" "--" "--"
		/if (${ChatText.Find[medtime]} && ${Me.PctMana}<100 && ${Me.MaxMana}) /call AnnounceMessage "${ChatChannel}" 2 g "FM in:" w "${Int[${Math.Calc[(${Me.MaxMana}-${Me.CurrentMana})/(${Me.ManaRegen}|1)/10]}]}m${Int[${Math.Calc[(${Me.MaxMana}-${Me.CurrentMana})/(${Me.ManaRegen}|1)%10*6]}]}s" "--" "--"
		/if (${ChatText.Find[buffqueue]} && ${QueueCount}) /call AnnounceMessage "${ChatChannel}" 3 g "I have" y "${QueueCount}" g "waiting to be served." "--"
		/if (${ChatText.Find[break]}) /call BreakInvis
		/if (${ChatText.Find[calm them]}) {
			/declare Puller int local 0
			/if (${ChatText.Arg[2].Length} && ${Spawn[pc ${ChatText.Arg[2]}].ID}) /varset Puller ${Spawn[pc ${ChatText.Arg[2]}].ID}
			/if ((!${ChatText.Arg[2].Length} || !${Spawn[pc ${ChatText.Arg[2]}].ID}) && ${Spawn[pc ${Sender}].ID}) /varset Puller ${Spawn[pc ${Sender}].ID}
			/call CalmGroup ${Puller}
			}
		/if (${ChatText.Find[create a campfire]}) /call CreateCampfire
		/if (${ChatText.Find[go to campfire]}) /call GoToCampfire
		/if (${ChatText.Find[campfire click]}) /call GoToCampfire
		/if (${ChatText.Find[go to trader]}) /call Trader
		/if (${ChatText.Find[guard here]} && ${Guard}) {
			/makecamp on
			/delay 1s
			/makecamp radius 10
			/delay 1s
			/makecamp leash 50
			/call AnnounceMessage "${ChatChannel}" 1 g "Guarding HERE Mastah!" 
			}
		/if (${ChatText.Find[use keyword]}) {
			/if (${Debug}) /echo ${ChatText.Arg[3]} ${ChatText.Arg[4]}
			/if (!${Spawn[${ChatText.Arg[4]}].ID}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR m "${ChatText.Arg[4]}" y not in zone
:distancecheck1		
			/if (${Spawn[${ChatText.Arg[4]}].ID} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>20) {
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR m "${ChatText.Arg[4]}" y "is ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance} far away, moving closer..."
				/if (!${Me.Moving} && !${Target.ID} && ${Bool[${Plugin[MQ2AdvPath]}]}) {
					/afollow spawn ${Spawn[${ChatText.Arg[4]}].ID}
					/delay 30s !{Me.Moving}
					/goto :distancecheck1
					}
				/stick id ${Spawn[${ChatText.Arg[4]}].ID} hold
				/delay 30s ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>21
				/if (!${Me.Moving} && ${Target.ID} && ${Stick.Active} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}>21) {
					/target clear
					/delay 10s !${Target.ID}
					/goto :distancecheck1
					}		
				}
			/target ID ${Spawn[${ChatText.Arg[4]}].ID}
			/delay 5s ${Target.ID}==${Spawn[${ChatText.Arg[4]}].ID}
			/if (${Target.ID}!=${Spawn[${ChatText.Arg[4]}].ID}) {
				/if (${ReportEvents}) /call AnnounceMessage "${ChatChannel}" 3 r ERROR y targeting m "${ChatText.Arg[4]}"
				}				
			/if (${Target.ID}==${Spawn[${ChatText.Arg[4]}].ID} && ${Spawn[${Spawn[${ChatText.Arg[4]}].ID}].Distance}<20) {
				/if (${Me.Invis}) {
					/squelch /makemevisible
					/delay 5s !${Me.Invis}
					}
				/face 
				/say ${ChatText.Arg[3]}
				}
			}
		}
	/if (${ChatText.Find[rez me]} && ${Spawn[${Sender}].Type.Find[Corpse]} && ${Spawn[${Sender}].ID}!=${Me.ID} && ${Select[${Me.Class.ShortName},CLR,SHM,DRU]} && !${RDPause}) {
		/if (${DoBuffTells} && !${SpamTimer}) /tell ${Sender} Rezz inc!
		/squelch /target ${Sender}'s Corpse
		/if (${Target.ID} && ${Target.Distance}>20) /corpse
		/if (${Target.ID} && ${Target.Distance}>150) /return
		/if (!${Target.ID} && ${ReportHeals}) /call AnnounceMessage "${HealChannel}" 2 y "I can't target" o "${Sender}'s corpse"
		/if (!${Target.ID} && ${DoBuffTells} && !${SpamTimer}) /tell ${Sender} I can't target your corpse
		/if (${Target.Type.Equal[Corpse]} ${ReportHeals}) /call AnnounceMessage "${HealChannel}" 2 y "I am attempting to Rez" o "${Sender}"
		/if (${Me.Class.ShortName.Equal[CLR]}) {
			/if (${Me.AltAbility[Blessing of Resurrection]} && ${Me.AltAbilityReady[Blessing of Resurrection]}) {
				/call MQ2Cast "Blessing of Resurrection" alt 10s SpellFiller 3
				} else /if (${FindItem[Water Sprinkler of Nem Ankh].ID}) {
				/call MQ2Cast "Water Sprinkler of Nem Ankh" item 6s SpellFiller 3
				} else {
				/call MQ2Cast "Reviviscence" ${BuffGem} 3s SpellFiller 3
				} else /call AnnounceMessage "${HealChannel}" 1 r "I have no way to rez?!?"
				/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
				/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]}) /call AnnounceMessage ${HealChannel} 1 r "Rez failed!"
			}
		/if ((${Me.Class.ShortName.Equal[DRU]} || ${Me.Class.ShortName.Equal[SHM]}) && !${SpawnCount[PC Group Cleric Radius 50]}) {
			/if (${Me.AltAbility[Rejuvenation of Spirit]}) {
:RezDelay
				/if (${Me.CombatState.Equal[COOLDOWN]}) {
					/delay 5s ${Me.CombatState.Equal[RESTING]}
					/if (${Me.CombatState.Equal[COMBAT]}) /return
					}
				/if (${Me.AltAbilityTimer[Rejuvenation of Spirit]} && ${Me.CombatState.Equal[RESTING]}) {
					/delay ${Me.AltAbilityTimer[Rejuvenation of Spirit]} ${Me.AltAbilityReady[Rejuvenation of Spirit]}
					/call MQ2Cast "Rejuvenation of Spirit" alt 10s SpellFiller 3
					/if (${castReturn.Equal[CAST_NOTREADY]}) {
						/call AnnounceMessage ${HealChannel} 1 y "Rez not ready yet, waiting..."
						/goto RezDelay
						}
					/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
					/return
					}
				}
			/if (${Me.Book[${Me.Book[Incarnate Anew]}].ID})	/call MQ2Cast "Incarnate Anew" ${BuffGem} 10s SpellFiller 3
			/if (${castReturn.Equal[CAST_SUCCESS]}) /call AnnounceMessage ${HealChannel} 1 g "${Sender} is rezzed!"
			/if (${Select[${castReturn},CAST_INTERRUPTED,CAST_CANCELLED]}) /call AnnounceMessage ${HealChannel} 1 r "Rez failed!"
			}
		/return
		}
	/if (${Defined[RofGem]} && ${Defined[RodSpell]}) {
		/if ((${ChatText.Find[mod rod please]} || ${ChatText.Find[mod rod pls]}) && !${RDPause} && ${Me.Class.ShortName.Equal[MAG]} && ${DoBuffs} && (${RodGem.Equal[alt]} && ${Me.AltAbilityReady[${RodSpell}]} || ${RodGem.NotEqual[alt]} && ${Me.SpellReady[${Spell[${RodSpell}].RankName}]})) {
			/invoke ${Spawn[${Sender}].DoTarget}
			/call MQ2Cast "${RodSpell}" ${RodGem} 5s SpellFiller 3
			/delay 10s !${Me.Casting.ID}
			/call AnnounceMessage ${If[${castReturn.Equal[CAST_SUCCESS]} "${ChatChannel}" 4 g "Sucessfull! ->" m "${Target.CleanName}" g "<_ has a new" o "${RodSpell}",/call AnnounceMessage "${ChatChannel}" 4 r "FAILURE!! ->" m "${Target.CleanName}" y "<- did not recieve a" o "${RodSpell}"]}
			}
		}
	/if (${ChatText.Find[who has]}) /call  check_who_has ${Sender} "${ChatText.Right[-8]}"
	/return	
	
Sub Event_CombatGem(Line,LineArg)
	/call Event_ToggleString "Stuff" "CombatGems" "CombatTwist" "Bard" "CombatTwist" "${LineArg}"
	/return	
	
Sub Event_Dead
	/delay 3s
	/call AnnounceMessage "${ChatChannel}" 1 y "rez me please"
	/call Wait4Rez
	/delay 2s
	/call Event_NewZone
	/doevents flush Dead
	/return
	
Sub Event_DelCombatSong(Line,Song)
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
	/call DelSong 1 ${MaxGems} Combat ${Song}
	/return

Sub Event_DelRestSong(Line,Song)
	/if (${Me.Class.ShortName.NotEqual[BRD]}) /return
	/call DelSong ${Int[${Math.Calc[${MaxGems}+1]}]} ${Int[${Math.Calc[${MaxGems}*2]}]} Rest ${Song}
	/return
	
Sub Event_Experience
	/if (!${RDPause} && ${DoMercStance} && ${Mercenary.State.Equal[ACTIVE]} && ${Mercenary.Stance.NotEqual[Balanced]} && (${Mercenary.Class.Name.Equal[Rogue]} || ${Mercenary.Class.Name.Equal[Wizard]} || ${Mercenary.Class.Name.Equal[Cleric]})) /stance Balanced
	/if (!${RDPause} && ${AutoNinja}) /call LootMobs
	/if (${Group.MasterLooter.ID}==${Me.ID} || ${Group.Leader.ID}==${Me.ID}) /call LootCheck
	/if (${Me.Class.ShortName.Equal[BRD]}) /squelch /twist stop
	/delay 5s !${Me.Casting.ID}
	/delay 1s
	/if (${MakeCamp.Status.Equal[ON]}) /makecamp return
|	/if (${Bool[${Plugin[MQ2AAPurchase]}]}) /aapurchase now
	/call XPCommon
	/return	
	
Sub Event_Faded
	/if (${Twist}) /squelch /twist off
	/if (${Melee.Combat}) /squelch /target clear
	/call XPCommon
	/return
	
Sub Event_ImHit(Line, MobName)
	/if (!${Defined[MobName]}) {
		/if (${Me.XTarget}) /declare MobName string local ${Me.XTarget[1]}
		/if (!${Me.XTarget}) /declare MobName string local Bob
		}
	/if (!${RDPause} && ${UseDiscs}) /call DiscStuff 0
	/if (${DoHolyShit}) /call HolyShit "${MobName}"
	/if (${ReportEvents} && !${Select[${Me.Class.ShortName},WAR,PAL,SHD,BER,RNG,MNK]}) /docommand /bc [+r+]I'm being attacked!!
	/if (!${RDPause} && ${Target.Type.Equal[corpse]}) /target clear
	/if (${Me.ID}==${Spawn[${MA1}].ID} && !${RDPause} && ${Select[${Me.Class.ShortName},WAR,PAL,SHD]} && !${Melee.Combat} && ${Target.Type.NotEqual[Mercenary]}) /killthis
	/varset SitTimer 10s
	/doevents flush ImHit
	/return

Sub Event_Invite(Line,Inviter)
	/if (${Twist}) /twist off
	/if (${Me.Casting.ID}) /delay 10s !${Me.Casting.ID}
	/if (${MasterList.Find[${Inviter}]} || ${MasterList2.Find[${Inviter}]} || ${MasterList3.Find[${Inviter}]} || ${MasterList4.Find[${Inviter}]} || ${MasterList5.Find[${Inviter}]}) {
		/if (${Window[ConfirmationDialogBox].Open}) /notify ConfirmationDialogBox CD_Yes_Button leftmouseup
		/invite
		/delay 1s
		}
	/return

Sub Event_IRC(IRCSay,IRCSender,IRCCommand)
	/if (${IRCCommand.Left[1].Equal[/]} && (${MasterList.Find[${IRCSender}]} || ${MasterList2.Find[${IRCSender}]} || ${MasterList3.Find[${IRCSender}]} || ${MasterList4.Find[${IRCSender}]} || ${MasterList5.Find[${IRCSender}]})) {
		/docommand ${IRCCommand}
		} else {
		/if (!${IRCCommand.Find[told me]} && !${IRCCommand.Find[debuffed with]} && !${IRCCommand.Find[@]} && ${IRCCommand.Left[4].NotEqual[I am]} && ${IRCCommand.Left[7].NotEqual[Buffing]}) /call Event_Chat "irc" "${IRCSender}" "${IRCCommand}"
		}
	/return

Sub Event_IRCNoChan
	/if (${IRCConnect}>0) /return
	/if (${UseIRC}==TRUE && ${Irc}==FALSE) {
		/i quit
		/call Connect
	}
	/return	

Sub Event_ListSpells
	/declare a int local
	/for a 1 to ${SpellSetTotal}
		/if (${ReportToggles}) /call AnnounceMessage "${ChatChannel}" 2 y "${a}." o "${SpellSet${a}}"
	/next a
	/return	

Sub Event_ListSongs(Line,ListType)
	/declare i int local
	/if (${ListType.Equal[Combat]} || ${ListType.Equal[All]}) {
		/if (${Bool[${SongsArray1}]}) /call AnnounceMessage "${ChatChannel}" 2 y "Combat" o "Songs" 
		/if (${SongsArray${i}.Equal[Song Name]}) /call AnnounceMessage "${ChatChannel}" 3 r "No" y "Combat Songs" r "Defined"
		/for i 1 to ${MaxGems}
			/if (${SongsArray${i}.NotEqual[Song Name]}) /call AnnounceMessage "${ChatChannel}" 2 y "${i} -" o "${SongsArray${i}}"
		/next i
		}
	/if (${ListType.Equal[Rest]} || ${ListType.Equal[All]}) {
		/if (${Bool[${SongsArray${Int[${Math.Calc[${MaxGems}+1]}]}}]}) /call AnnounceMessage "${ChatChannel}" 2 g "Rest" o "Songs:"
		/if (${SongsArray${Int[${Math.Calc[${MaxGems}+1]}]}.Equal[Song Name]}) /call AnnounceMessage "${ChatChannel}" 3 r "No" g "Rest Songs" y "defined"
		/for i ${Math.Calc[${MaxGems}+1]} to ${Math.Calc[${MaxGems}*2]}
			/if (${SongsArray${i}.NotEqual[Song Name]}) /call AnnounceMessage "${ChatChannel}" 2 y "${Int[${Math.Calc[${i}-${MaxGems}]}]} - " o "${SongsArray${i}}"
		/next i
		}
	/if (${ListType.Equal[Mez]} || ${ListType.Equal[All]}) {
		/if (${Bool[${MezSong}]}) /call AnnounceMessage "${ChatChannel}" 1 y "Mez Songs"
		/if (${Bool[${MezSong}]}) /call AnnounceMessage "${ChatChannel}" 1 o "${MezSong}"
		/if (!${Bool[${MezSong}]}) /call AnnounceMessage "${ChatChannel}" 2 r "No" y "Mez Songs defined"
		}
	/return

Sub Event_LoadAlert
	/call RefreshAlerts
	/return
	
Sub Event_LoadIni(Line,LineArg)
	/call LoadIni "RD1_${Me.CleanName}${LineArg}.ini" LOAD
	/return	

Sub Event_Lootall
	/call LootMobs
	/return	
	
Sub Event_MakeStuff(Line,Stuff1,Stuff2)
	/if (${SummonFood}==TRUE) {
	   /declare i int local
	   /for i 1 to 2
		/if (${Me.FreeInventory}>=2 && !${RDPause} && ((${Me.Gem[${${Stuff${i}}Spell}]} || (!${SitTimer} && ${Spell[${${Stuff${i}}Spell}].RankName.ID})) || (${${Stuff${i}}Gem.Equal[alt]} && ${Me.AltAbilityReady[${${Stuff${i}}Gem}]}) || ${${Stuff${i}}Gem.Equal[item]}) && !${SpawnCount[npc targetable radius 25 noalert 1]}) {
			/call MQ2Cast "${${Stuff${i}}Spell}" ${${Stuff${i}}Gem} 5s Check4Pad
			/call ClearCursor
		}
	   /next i
	}
	/return

Sub Event_MezBroke(meztext,mezmob,mezbreaker)
	/if (${Spawn[id ${MATarget}].ID}!=${Spawn[id ${mezmob}].ID} && ${Mezbroke}) /call AnnounceMessage "${ChatChannel}" 4 m "-->" o "${mezbreaker}" r "has awakened" Y "** ${mezmob} **" ""
	/return	
	
Sub Event_MezIt(Line,MobName)
	/declare i int local
	/declare oldTarget int local 0
	/if (!${RDPause} && ${DoMez} && ${Spawn[${MobName}].Type.Equal[npc]}) {
		/for i 1 to ${DebuffTotal}
			/if (${SpellType${i}}==2 && ${Me.Casting.ID}!=${DebuffID[${i}]}) {
				/if (!${Me.Class.ShortName.Equal[BRD]} && ${Me.Casting.ID}) {
					/bc Mezit Interrupt 1
					}
				/varset oldTarget ${Target.ID}
				/if (${Target.ID}!=${NearestSpawn[npc targetable ${MobName} noalert 1].ID}) {
					/target targetable id ${NearestSpawn[npc targetable ${MobName} noalert 1].ID}
					}
				/delay 1s ${Target.ID}==${NearestSpawn[npc targetable ${MobName} noalert 1].ID}
				/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${Select[${DebuffGem${i}},item,alt]} && ${Me.Gem[${DebuffSpell${i}}]}) {
					/squelch /twist once ${Me.Gem[${DebuffSpell${i}}]}
					/varset castReturn CAST_SUCCESS
					/delay ${Spell[${DebuffSpell${i}}].MyCastTime.TotalSeconds}s
					/delay 1s
					/call DoCastingEvents
				} else /call MQ2Cast "${DebuffSpell${i}}" ${DebuffGem${i}} 5s SpellFiller 3
				/if (${ReportMez} && ${castReturn.Equal[CAST_SUCCESS]} && ${Target.ID}) {
					/call AnnounceMessage "${ChatChannel}" 2 y "Interupted" O "${Target.CleanName"
					}
				/varset castReturn CAST_CANCELLED
			}
		/next i
	}
	/if (${oldTarget}) /target targetable id ${oldTarget}
	/return

Sub Event_NeedStuff(Line,Need)
	/if (!${Defined[NeedStuffTimer]}) /call CreateTimer NeedStuffTimer
	/if (${ReportEvents} && !${Need.Find[stick]} && !${NeedStuffTimer}) {
		/call AnnounceMessage "${ChatChannel}" "2" "g" "I am" "y" "${Need}"
		}
	/varset NeedStuffTimer 3s
	/return

Sub Event_NewZone
	/declare i int local
	/declare a int local
	| Filter out false zone event matches
	/if (${Zone.Name.Equal[${ZoneName}]}) /return
	/echo Zone detected: Entering ${Zone.Name}...Loading NPC ignore list...
	/delay 120s ${Me.ID}
	/delay 5s
	/if ((${Zone.ShortName.Equal[guildlobby]} || ${Select[${Zone.ID},345,344,202,203,279]}) && !${RDPause}) /rdpause on
	/if (${ChatChannel.Equal[BC]}) /call AnnounceMessage "${ChatChannel}" 1 g "Ready boss!"
	/squelch /stick off
	/squelch /stick off
	/if (${MakeCamp.Status.Equal[ON]}) /makecamp off
	/keypress forward
	/keypress back
	/keypress left
	/keypress right
	/if (${DebuffTotal}) {
		/for i 1 to ${MaxMobs}
			/varset MobList[${i}] 0
			/for a 1 to ${DebuffTotal}
				/varset DebuffArray[${i},${a}] 0
				/next a
			/next i
		/varset VarNPCCount 0
		/for i 1 to ${DebuffTotal}
			/call LoadVar ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune | ${DebuffID[${i}]}Immune RDCommon.ini LOAD string
		/next i
	}
	/if (${DoBuffTotal}) {
		/for i 1 to 25
			/varset DoBuffQueue[${i},1] 0
			/varset DoBuffQueue[${i},2] 0
		/next i
		/varset QueueCount 0
	}
	/varset MATarget 999999
	/varset FollowGuy 999999
	/varset FollowFlag FALSE
	/varset PetID 0
	/call LoadVar RestrictedList ${Zone.ShortName} | RestrictedList RDCommon.ini LOAD string
	/if (${DoBardSwap} && !${BardSwap.Swapping}) /bardswap
	/if (${DoBardMeleeSwap} && !${BardSwap.MeleeSwap}) /bardswap melee
	/varset ZoneName ${Zone.Name}
	/call RefreshAlerts
	/doevents flush
	/return

Sub Event_NoLuclin
	/varset UseMount 0
	/return

Sub Event_NoMount
	/if (${UseMount}) {
		/varset RestrictedList ${RestrictedList}NoMount|
		/ini RDCommon.ini RestrictedList ${Zone.ShortName} "NoMount|"
	}
	/return	

Sub Event_RaidExperience
	/call XPCommon
	/return

Sub Event_Rampage
	/if (!${RDPause} && ${DoRamp}) {
		/if (${Me.CurrentMana}>${Spell[${FastHealID}].Mana}) {
			/target targetable pc ${RampTank}
			/delay 5
			/if (${Target.ID}==${Spawn[pc ${RampTank}].ID} && ${Target.PctHPs}<${CancelPct} && ${Target.Distance}<${Int[${Spell[${FastHealID}].MyRange}]}) {
				/delay 10s !${Me.Casting.ID}
				/if (${ReportHeals} && ${Target.ID}) /call AnnounceMessage "${ChatChannel}" 4 g "Rampage Healing ->" m "${Target.CleanName}" g "<- with" t "${Spell[${FastHeal}].RankName}"
				/call MQ2Cast "${FastHeal}" ${FastHealGem} 3s CheckHP SpellFiller 3
			}
			/if (${Target.ID}!=${MATarget}) /call assistMA1
		}
	}
	/return


Sub Event_Recovered
	/if (${Me.Class.ShortName.Equal[BRD]} && !${RecoveredTimer} ${Twist}) /twist off
	/delay 5s !${Me.Casting.ID}
	/doevents flush Recovered
	/varset RecoveredTimer 5s
	/return	

Sub Event_RemoveAura
	/if (!${Me.Aura[1].Equal[NULL]}) /removeaura ${Me.Aura[1]}
	/delay 1s
	/if (!${Me.Aura[2].Equal[NULL]}) /removeaura ${Me.Aura[2]}
	/return	

Sub Event_RestGem(Line,LineArg)
	/call Event_ToggleString "Stuff" "RestGems" "RestTwist" "Bard" "RestTwist" "${LineArg}"
	/return
	
Sub Event_Restricted
	/if (${LastCast.NotEqual[BLAH]} && ${LastCast.Length}) {
		/varset RestrictedList ${RestrictedList}${LastCast}|
		/ini RDCommon.ini RestrictedList ${Zone.ShortName} "${RestrictedList}"
	}
	/return

Sub Event_SaveIni(Line,LineArg)
	/if (!${Defined[${LineArg}]}) /varset LineArg ${RDIni}
	/call LoadIni ${LineArg} SAVE
	/return

Sub Event_SetBuff(Line,LineArg)
	/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID} || (${Line.Arg[3].Equal[${FindItem[${Line.Arg[3]}]}]} && ${FindItem[${Line.Arg[3]}].ID}) || ${Me.AltAbilityReady[${Line.Arg[3]}]}) {
		/if (${Line.Arg[4].Equal[group]}) {
			/declare i int local
			/for i ${Group} downto 0 
				/target targetable id ${Group.Member[${i}].ID}
				/delay 1s ${Target.ID}==${Group.Member[${i}].ID}
				/if (${Target.ID}!=${Group.Member[${i}].ID}) /next i
				/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
				/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call MQ2Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
				/if (${FindItem[${Line.Arg[3]}].ID}) /call MQ2Cast "${Line.Arg[3]}" item 10s SpellFiller 3
				/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call MQ2Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
			/next i
			/return
			}
			/if (${Line.Arg[4].Equal[raid]}) {
				/declare i int local
				/for i ${Raid.Members} downto 1
					/if (${i}==0) /return
					/if (!${Raid.Member[${i}].GroupLeader}) /continue
					/target targetable id ${Raid.Member[${i}].ID}
					/delay 1s ${Target.ID}==${Raid.Member[${i}].ID}
					/if (${Target.ID}!=${Raid.Member[${i}].ID}) /continue
					/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
					/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call MQ2Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
					/if (${FindItem[${Line.Arg[3]}].ID}) /call MQ2Cast "${Line.Arg[3]}" item 10s SpellFiller 3
					/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call MQ2Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
				/next i
				/return
			}
			/if (${Spawn[pc ${Line.Arg[4]}].ID}) {
				/target targetable id ${Spawn[pc ${Line.Arg[4]}].ID}
				/delay 1s ${Target.ID}==${Spawn[pc ${Line.Arg[4]}].ID}
			} else {
				/if (${Spawn[${Line.Arg[4]}].ID}) {
				/target targetable id ${Spawn[${Line.Arg[4]}].ID}
				/delay 1s ${Target.ID}==${Spawn[${Line.Arg[4]}].ID}
			}
		}
		/if (${ReportDoBuffs}) /call AnnounceMessage "${ChatChannel}" 4 g "Casting" o "${Line.Arg[3]}" g "on" m "${Target.CleanName}"
		/if (${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}].ID}) /call MQ2Cast "${Me.Book[${Me.Book[${Spell[${Line.Arg[3]}].RankName}]}]}" ${BuffGem} 10s SpellFiller 3
		/if (${FindItem[${Line.Arg[3]}].ID}) /call MQ2Cast "${Line.Arg[3]}" item 10s SpellFiller 3
		/if (${Me.AltAbilityReady[${Line.Arg[3]}]}) /call MQ2Cast "${Line.Arg[3]}" alt 10s SpellFiller 3
		/if (${Me.Class.ShortName.Equal[BRD]} && !${Me.Invis} && !${TwistTimer}) /call SingSongs
		/return
	}
	/if (${Line.Arg[4].Equal[group]}) {
		/declare i int local
		/for i ${Group} downto 0
			/call CheckDoBuffs "${Group.Member[${i}].Name}" "${Line.Arg[3]}"
		/next i
		/return
		}
	/if (${Line.Arg[4].Equal[raid]}) {
		/declare i int local
		/for i ${Raid.Members} downto 1
			/if (${i}==0) /return
			/if (!${Raid.Member[${i}].GroupLeader}) /continue
			/call CheckDoBuffs "${Raid.Member[${i}].Name}" "${Line.Arg[3]}"
		/next i
		/return
		}
	/if (${Line.Arg[4].Length} && ${Spawn[pc ${Line.Arg[4]}].ID}) /call CheckDoBuffs "${Spawn[pc ${Line.Arg[4]}].CleanName}" "${Line.Arg[3]}"
	/if (${Line.Arg[4].Length} && ${Spawn[${Line.Arg[4]}].Type.NotEqual[npc]} && ${Spawn[${Line.Arg[4]}].ID}) /call CheckDoBuffs "${Spawn[${Line.Arg[4]}].CleanName}" "${Line.Arg[3]}"
	/return
	
Sub Event_SetMA1(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #1" "MA1" "GeneralStuff" "MA1" "NULL"
		}
	/return

Sub Event_SetMA2(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #2" "MA2" "GeneralStuff" "MA2" "NULL"
		}
	/return

Sub Event_SetMA3(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Main Assist #3" "MA3" "GeneralStuff" "MA3" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Main Assist #3" "MA3" "GeneralStuff" "MA3" "NULL"
		}
	/return

Sub Event_SetRampTank(Line,LineArg)
	/if (${Spawn[${LineArg}].Type.Equal[pc]} || ${Spawn[${LineArg}].Type.Equal[Mercenary]}) {
		/call Event_ToggleString "Stuff" "Rampage Tank" "RampTank" "HealStuff" "RampTank" "${LineArg}"
		} else {
		/call Event_ToggleString "Stuff" "Rampage Tank" "RampTank" "HealStuff" "RampTank" "NULL"
		}
	/return	
	
Sub Event_ShowDebuffs(line,NPCID)
	/if (!${DebuffTotal}) /return
	/declare a           int local
	/declare b           int local
	/for a 1 to ${MaxMobs}
		/if (${NPCID}==${MobList[${a}]}) {
			/for b 1 to ${DebuffTotal}
				/if (1) /${DebuffChannel} Spell ${DebuffSpell${b}}: ${Math.Calc[${DebuffArray[${a},${b}]}-${Macro.RunTime}]}s
			/next b
			/return 
		}
	/next a
	/if (1) /${DebuffChannel} ${Spawn[${NPCID}]} is not on MobList (${VarNPCCount} / ${MaxMobs}), calling PopulateNPCs
	/call PopulateNPCs
	/return 

Sub Event_SongAlias(Line,AliasName,FullName)
	/ini ${RDIni} "Bard-Aliases" "${AliasName}" "${FullName}"
	/if (${Defined[FullName]}) /call AnnounceMessage "${ChatChannel}" 4 g Alias y "${AliasName}" g "set for" 0 "${FullName}"
	/return	
	
Sub Event_Stand
	/if (!${Me.Standing} && ${Me.State.NotEqual[FEIGN]}) /stand
	/return	

Sub Event_ToggleAABuy
	/echo ToggleVar Auto AABuy,AABuy,Settings,AABuy,
	/if (${AABuy})	/call AAInit
	/return

Sub Event_ToggleString(Stuff,TempMessage,TempVar,IniSection,IniEntry,Line)
	/if (${Defined[${TempVar}]}) {
		/if (${Line.Length}) {
			/varset ${TempVar} ${Line}
			/ini "${RDIni}" ${IniSection} ${IniEntry} "${${TempVar}}"
			}
		/if (${ReportToggles}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" y "${${TempVar}}"
		}
	/return

Sub Event_ToggleVar(Stuff,TempMessage,TempVar,IniSection,IniEntry,Line)
	/if (${Defined[${TempVar}]}) {
		/if (!${Line.Length}) {
			/if (${${TempVar}}) {
				/varset ${TempVar} 0
			} else {
				/varset ${TempVar} 1
			}
		}
		/if (${Line.Arg[1].Equal[ON]} || ${Line.Arg[1].Equal[TRUE]} || ${Line.Arg[1].Equal[1]}) /varset ${TempVar} 1
		/if (${Line.Arg[1].Equal[OFF]} || ${Line.Arg[1].Equal[FALSE]} || ${Line.Arg[1].Equal[0]}) /varset ${TempVar} 0
		/if (${ReportToggles} && ${${TempVar}}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" Y "ON"
		/if (${ReportToggles} && !${${TempVar}}) /call AnnounceMessage "${ChatChannel}" 3 O "${TempMessage}" g "is now" Y "OFF"
		/if (${IniSection.NotEqual[NULL]} && ${IniEntry.NotEqual[NULL]}) /ini "${RDIni}" ${IniSection} ${IniEntry} ${${TempVar}}
	}
	/if (${RDPause} && ${Me.Class.ShortName.Equal[BRD]} && ${Twist}) /squelch /twist off
	/return

Sub Event_TooClose
	/if (${Me.AutoFire}) /autofire off
	/if (${Target.ID}==${MATarget} && !${Me.Moving} && ${DoMelee} && ${Target.Type.NotEqual[Mercenary]}) /killthis
	/return

Sub Event_TooFar
	/if (${Target.ID}==${MATarget} && !${Me.Moving} && ${DoMelee}) {
		/if (${Target.Distance}<10 && ${Target.Distance}>100) {
			/squelch /stick off
			/squelch /melee reset
			} else {
			/stick -10
			}
		/if (${Target.Distance}<${NPCRadChk} && ${Guard} && ${MakeCamp.Status.Equal[ON]}) {
			/target clear
			/varset MATarget NULL
			}
		}
	/doevents flush TooFar
	/return

Sub Event_WornOff(Line,SpellName,Dude)
	/declare i int local
	/declare j int local
	/if (${DoBuffTotal} && ${RefreshBuffs} && ${Select[${Spawn[${Dude}].Type},PC,Pet,Mercenary]}) {
		/for i 1 to ${DoBuffTotal}
			/if (${SpellName.Equal[${Spell[${DoBuffID[${i}]}].Name}]} && ${DoBuffRefresh${i}}) {
				/for j 1 to ${SpawnCount[${Dude}]}
				/if (${NearestSpawn[${j}, ${Dude}].CleanName.Equal[${Dude}]}) /call AddToQueue ${NearestSpawn[${j}, ${Dude}].ID} ${i}
                /next j
				}
			/next i
		}
	/return	

	
	
Sub LoadIni(MyIni,Function)
	/declare i int local
	/call LoadVar RestrictedList ${Zone.ShortName} | RestrictedList RDCommon.ini ${Function} string
	/call LoadVar IgnoreNPCList ${Zone.ShortName} | IgnoreNPCList RDCommon.ini ${Function} string
	/call RefreshAlerts
	
	/call LoadVar GeneralStuff ChatChannel echo ChatChannel "${MyIni}" ${Function} string
	/call LoadVar Settings MasterList "Put your list of master bots here" MasterList "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList2 "Put your list of master bots here" MasterList2 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList3 "Put your list of master bots here" MasterList3 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList4 "Put your list of master bots here" MasterList4 "RDCommon.ini" ${Function} string
	/call LoadVar Settings MasterList5 "Put your list of master bots here" MasterList5 "RDCommon.ini" ${Function} string
	/call LoadVar GeneralStuff AssistMA FALSE AssistMA "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff TargetLock FALSE TargetLock "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff AssistDelay 5s AssistDelay "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA1 "Main Assist 1" MA1 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA2 "Main Assist 2" MA2 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff MA3 "Main Assist 3" MA3 "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff ChangeTank FALSE ChangeTank "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff EngageHPs 98 EngageHPs "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff StopHPs 10 StopHPs "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff UseEpic 1 UseEpic "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff Epic "Put the name of your epic here" Epic "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff InvisibilitySpell "Put the name of your invis spell or item here" InvisibilitySpell "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff InvisibilityGem "Put gem# for spells, or item for items" InvisibilityGem "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff CalmSpell "Put the name of your calm spell or item here" CalmSpell "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff CalmGem "Put gem# for spells, or item for items" CalmGem "${MyIni}" ${Function} string
	/call LoadVar GeneralStuff Mezbroke FALSE Mezbroke "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff MaxMezLvl 93 MaxMezLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff MaxCharmLvl 89 MaxCharmLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff MaxCalmLvl 90 MaxCalmLvl "${MyIni}" ${Function} int
	/call LoadVar GeneralStuff ReportEvents FALSE ReportEvents "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff ReportToggles FALSE ReportToggles "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff RelayTells FALSE RelayTells "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff UseGroupMA TRUE UseGroupMA "${MyIni}" ${Function} bool
    /call LoadVar GeneralStuff UseGroupTank FALSE UseGroupTank "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff UseRaidMA FALSE UseRaidMA "${MyIni}" ${Function} bool
	/call LoadVar GeneralStuff TraderName "Put the name of your Trader here" TraderName "${MyIni}" ${Function} string
	/if (${Select[${Me.Class.ShortName},DRU,WIZ]}) {
		/call LoadVar GeneralStuff DoPorts FALSE DoPorts "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff PortGem "gem12, change for your tastes" PortGem "${MyIni}" ${Function} string
	}
	/if (!${Defined[ASRadius]}) /declare ASRadius int outer 20
	/if (!${Defined[ASZRadius]}) /declare ASZRadius int outer 50
	/call LoadVar Settings LeashLength 25 LeashDistance "${MyIni}" ${Function} int
	/call LoadVar Settings NPCRadius 75 NPCRadius "${MyIni}" ${Function} int
	/call LoadVar Settings NPCzradius 50 NPCZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings PCRadius 200 PCRadius "${MyIni}" ${Function} int
	/call LoadVar Settings PCzradius 50 PCZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings AutoNinja FALSE AutoNinja "${MyIni}" ${Function} bool
	/call LoadVar Settings AABuy "FALSE" AABuy "${MyIni}" ${Function} bool
	/call LoadVar Settings UseIRC "FALSE" UseIRC "${MyIni}" ${Function} bool
	/call LoadVar Settings IRCAddress "IRC Server URL" IRCAddress "${MyIni}" ${Function} string
	/call LoadVar Settings IRCPort "6667" IRCPort "${MyIni}" ${Function} int
	/call LoadVar Settings IRCChannel "#Name of Chat with Pound sign" IRCChannel "${MyIni}" ${Function} string
	/call LoadVar Settings AutoSit FALSE AutoSit "${MyIni}" ${Function} bool
	/call LoadVar Settings ASRadius 20 ASRaidus "${MyIni}" ${Function} int
	/call LoadVar Settings ASZRadius 50 AZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings SitDelay 3s SitDelay "${MyIni}" ${Function} string
	/call LoadVar Settings EndMedPct 80 EndMedPct "${MyIni}" ${Function} int
	/call LoadVar Settings UseMount FALSE UseMount "${MyIni}" ${Function} bool
	/call LoadVar Settings MountItem "Put the name of your mount summoning item here" MountItem "${MyIni}" ${Function} string
	/call LoadVar Settings DoShrink FALSE DoShrink "${MyIni}" ${Function} bool
	/call LoadVar Settings ShrinkSpell "Put the name of your shrink spell or item here" ShrinkSpell "${MyIni}" ${Function} string
	/call LoadVar Settings ShrinkGem "item or gemNumber or alt" ShrinkGem "${MyIni}" ${Function} string
    /call LoadVar Settings ShrinkSelfOnly TRUE ShrinkSelfOnly "${MyIni}" ${Function} bool
    /call LoadVar Settings MoveUpJitter 10 MoveUpJitter "${MyIni}" ${Function} int
	/call LoadVar SummonStuff SummonFood "FALSE" SummonFood "${MyIni}" ${Function} bool
	/call LoadVar SummonStuff FoodSpell "Put the name of your food summoning spell/item here" foodSpell "${MyIni}" ${Function} string
	/call LoadVar SummonStuff FoodGem "Put gem# for spells, or item for items" foodGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff DrinkSpell "Put the name of your drink summoning spell/item here" drinkSpell "${MyIni}" ${Function} string
	/call LoadVar SummonStuff DrinkGem "Put gem# for spells, or item for items" drinkGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff UseAmmoClicky "FALSE" UseAmmoClicky "${MyIni}" ${Function} bool
	/call LoadVar SummonStuff AmmoGem "item, alt, or gemX" AmmoGem "${MyIni}" ${Function} string
	/call LoadVar SummonStuff AmmoClicky "Put the name of your Ammo Clicky here" AmmoClicky "${MyIni}" ${Function} string
	/call LoadVar SummonStuff AmmoItem "Put the name of the item to summon here" AmmoItem "${MyIni}" ${Function} string
	/call LoadVar MeleeStuff DoDefense FALSE DoDefense "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff DoMelee FALSE DoMelee "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff DoRanged FALSE DoRanged "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff RangeDist 30 RangeDist "${MyIni}" ${Function} int
	/call LoadVar MeleeStuff DoMercStance FALSE DoMercStance "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff MercEngageHPs 98 MercEngageHPs "${MyIni}" ${Function} int 
	/call LoadVar MeleeStuff DoMercAssist TRUE DoMercAssist "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff Guard FALSE Guard "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff Status TRUE Status "${MyIni}" ${Function} bool
	/call LoadVar MeleeStuff ReportDefense FALSE ReportDefense "${MyIni}" ${Function} bool
	/if (${Select[${Me.Class.ShortName},WAR,MNK,ROG,BER,SHD,PAL,RNG,BRD,BST]}) {
		/call LoadVar MeleeStuff DiscTotal 1 DiscTotal ${MyIni} ${Function} int
		/if (${DiscTotal}) {
			/call LoadVar MeleeStuff UseDiscs FALSE UseDiscs ${MyIni} ${Function} bool
			/for i 1 to ${DiscTotal}
				/call LoadVar MeleeStuff DiscName${i} "Put the name of Discipline #${i} here" DiscName${i} ${MyIni} ${Function} string
				/call LoadVar MeleeStuff DiscType${i} 0 DiscType${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscEndurance${i} 100 DiscEndurance${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscMinHPs${i} 0 DiscMinHPs${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscMaxHPs${i} 0 DiscMaxHPs${i} ${MyIni} ${Function} int
				/call LoadVar MeleeStuff DiscSpawnCount${i} 1 DiscSpawnCount${i} ${MyIni} ${Function} int
			 /next i
			}
		}

	/call LoadVar HealStuff BegFrantic FALSE BegFrantic "${MyIni}" ${Function} bool
	/call Loadvar HealStuff BegFranticPct 35 BegFranticPct "${MyIni}" ${Function} int
	/call LoadVar HealStuff BegFranticChannel "bc" BegFranticChannel "${MyIni}" ${Function} string
	/if (${Select[${Me.Class.ShortName},CLR,DRU,SHM,BST,PAL,RNG]}) {
		/if (!${Defined[DAArray]})         /declare DAArray[6,2]    int    outer
		/if (!${Defined[StartHPs]})        /declare StartHPs        int    outer
		/if (!${Defined[TankLastPct]})     /declare TankLastPct     int    outer
		/if (!${Defined[TankPPS]})         /declare TankPPS         int    outer
		/if (!${Defined[TankTTL]})         /declare TankTTL         int    outer
		/if (!${Defined[TotalTankHits]})   /declare TotalTankHits   int    outer
		/if (!${Defined[TotalTankTime]})   /declare TotalTankTime   int    outer
		/if (!${Defined[TankTimeArray]})   /declare TankTimeArray[30]  int    outer
		/if (!${Defined[TankHitsArray]})   /declare TankHitsArray[30]  int    outer
		/if (!${Defined[TankHitsIndex]})   /declare TankHitsIndex   int   outer 1
		/if (!${Defined[WorstHPs]})        /declare WorstHPs        int    outer 100
		/if (!${Defined[WorstID]})         /declare WorstID         int    outer
		/if (!${Defined[WorstMember]})     /declare WorstMember     int    outer
		/if (!${Defined[GroupHurtCount]})  /declare GroupHurtCount  int    outer
		/if (!${Defined[TankPPSTimer]})    /declare TankPPSTimer    timer  outer
		/call LoadVar HealStuff ReportHeals FALSE ReportHeals "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealMessage "%Spell @ %Target" HealMessage "${MyIni}" ${Function} string
		/call LoadVar HealStuff ReportInterrupts FALSE ReportInterrupts "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealChannel echo HealChannel "${MyIni}" ${Function} string
		/call LoadVar HealStuff StayOnHeal 5s StayOnHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff HealMeFirst FALSE HealMeFirst "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealFD FALSE HealFD "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealXTarget FALSE HealXTarget "${MyIni}" ${Function} bool
		/call LoadVar HealStuff GroupHealing FALSE HealGroup "${MyIni}" ${Function} bool
		/call LoadVar HealStuff CheckGroupInterval 5 CheckGroupInterval "${MyIni}" ${Function} string
		/call LoadVar HealStuff AutoInterrupt FALSE Stop4Pad "${MyIni}" ${Function} bool
		/call LoadVar HealStuff RampHealing FALSE DoRamp "${MyIni}" ${Function} bool
		/call LoadVar HealStuff RampTank "Rampage Tank" RampTank "${MyIni}" ${Function} string
		/call LoadVar HealStuff AEHealing FALSE AEHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff AssistHealing FALSE AssistHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HealPct 70 HealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff CancelPct 90 CancelPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff WaitToCancel FALSE WaitToCancel "${MyIni}" ${Function} bool
		/call LoadVar HealStuff DelayedHeal "Put the name of your delayed heal spell here" DelayedHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff DelayedHealGem "Put the spell gem you want to cast your delayed heal from here" DelayedHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff DelayedHealPct 90 DelayedHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseDelayedHeal TRUE UseDelayedHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff UseCH FALSE UseCH "${MyIni}" ${Function} bool
		/call LoadVar HealStuff TankHealPct 70 TankHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff TankHeal "Put the name of your tank heal spell here" TankHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff TankHealGem "Put the spell gem you want to cast your tank heal from here" TankHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff PetHealing FALSE HealPets "${MyIni}" ${Function} bool
		/call LoadVar HealStuff PetHealPct 50 PetHealPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff PetHeal "Put the name of your pet heal spell here" PetHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff PetHealGem "Put the spell gem you want to cast your pet heal from here" PetHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff FastHeal "Put the name of your fast heal spell here" FastHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff FastHealGem "Put the spell gem you want to cast your fast heal from here" FastHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHeal "Put the name of your group heal spell here" GroupHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHealGem "Put the spell gem you want to cast your group heal from here" GroupHealGem "${MyIni}" ${Function} string
		/call LoadVar HealStuff GroupHealCount 3 GroupHealCount "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseFranticHeal FALSE UseFranticHeal "${MyIni}" ${Function} bool
		/call LoadVar HealStuff FranticHeal "Put the name of your Frantic emergancy heal here" FranticHeal "${MyIni}" ${Function} string
		/call LoadVar HealStuff FranticHealGem "Put the spell gem that FranticHeal is cast from here" FrantHealGem "${MyIni}" ${Function} string
		/if (!${Defined[FastHealID]})     /declare FastHealID    int outer ${Me.Book[${Me.Book[${Spell[${FastHeal}].RankName}]}].ID}
		/if (!${Defined[GroupHealID]})    /declare GroupHealID   int outer ${Me.Book[${Me.Book[${Spell[${GroupHeal}].RankName}]}].ID}
		/if (!${Defined[TankHealID]})     /declare TankHealID    int outer ${Me.Book[${Me.Book[${Spell[${TankHeal}].RankName}]}].ID}
		/if (!${Defined[PetHealID]})      /declare PetHealID     int outer ${Me.Book[${Me.Book[${Spell[${PetHeal}].RankName}]}].ID}
		/if (!${Defined[DelayedHealID]})  /declare DelayedHealID int outer ${Me.Book[${Me.Book[${Spell[${DelayedHeal}].RankName}]}].ID}
		/if (!${Defined[FranticHealGem]}) /declare FranticHealGem string outer Gem8
		}
	/call LoadVar CureStuff CureTotal 1 CureTotal "${MyIni}" ${Function} int
	/call LoadVar SelfBuffStuff SelfBuffTotal 1 SelfBuffTotal "${MyIni}" ${Function} int
	/call LoadVar DoBuffStuff DoBuffTotal 1 DoBuffTotal "${MyIni}" ${Function} int
	/call LoadVar DebuffStuff DebuffTotal 1 DebuffTotal "${MyIni}" ${Function} int
	/call LoadVar RestStuff RestTotal 1 RestTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/if (!${Defined[RestStuffTimer]}) /declare RestStuffTimer timer  outer
		/call LoadVar RestStuff DoRestStuff FALSE DoRestStuff "${MyIni}" ${Function} bool
		/call LoadVar RestStuff RestStuffRecheck 10s RestStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${RestTotal}
			/call LoadVar RestStuff RestCommand${i} "Insert the command to execute" RestCommand${i} "${MyIni}" ${Function} string
			/call LoadVar RestStuff RestCondition${i} "Insert the condition to execute the command" RestCondition${i} "${MyIni}" ${Function} string
		/next i	
		}
	/call LoadVar CombatStuff CombatTotal 1 CombatTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/call LoadVar CombatStuff DoCombatStuff FALSE DoCombatStuff "${MyIni}" ${Function} bool
		/call LoadVar CombatStuff CombatStuffRecheck 10s CombatStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${CombatTotal}
			/call LoadVar CombatStuff CombatCommand${i} "Insert the command to execute" CombatCommand${i} "${MyIni}" ${Function} string
			/call LoadVar CombatStuff CombatCondition${i} "Insert the condition to execute the command" CombatCondition${i} "${MyIni}" ${Function} string
		/next i	
		}
	/call LoadVar NamedStuff NamedTotal 1 NamedTotal "${MyIni}" ${Function} int
	/if (${RestTotal}) {
		/if (!${Defined[NamedStuffTimer]}) /declare NamedStuffTimer timer  outer
		/call LoadVar NamedStuff DoNamedStuff FALSE DoNamedStuff "${MyIni}" ${Function} bool
		/call LoadVar NamedStuff NamedStuffRecheck 10s NamedStuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${NamedTotal}
			/call LoadVar NamedStuff NamedCommand${i} "Insert the command to execute" NamedCommand${i} "${MyIni}" ${Function} string
			/call LoadVar NamedStuff NamedCondition${i} "Insert the condition to execute the command" NamedCondition${i} "${MyIni}" ${Function} string
		/next i	
		}	
	/if (${CureTotal}) {
		/if (!${Defined[DoCures]}) /declare DoCures bool outer FALSE
		/call LoadVar CureStuff DoCures FALSE DoCures "${MyIni}" ${Function} bool
		/call LoadVar CureStuff ReportCures FALSE ReportCures "${MyIni}" ${Function} bool
		/for i 1 to ${CureTotal}
			/call LoadVar CureStuff CureSpell${i} "Cure Item/Spell #${i}" CureSpell${i} "${MyIni}" ${Function} string
			/call LoadVar CureStuff CureGem${i} "Cure #${i} Gem, or put Item if an item, or ALT if an AA" CureGem${i} "${MyIni}" ${Function} string
			/call LoadVar CureStuff CurseCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" CurseCounters${i} "${MyIni}" ${Function} int
			/call LoadVar CureStuff DiseaseCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" DiseaseCounters${i} "${MyIni}" ${Function} int
			/call LoadVar CureStuff PoisonCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" PoisonCounters${i} "${MyIni}" ${Function} int
            /call LoadVar CureStuff CorruptionCounters${i} "Set this to the # of debuf counters you want this to react to (For example if the spell cures 25 counters and you want it to only cure if it can do it in 2 casts or less, set it to 50)" CorruptionCounters${i} "${MyIni}" ${Function} int
			/if (${CureGem${i}.NotEqual[item]} && ${CureGem${i}.NotEqual[alt]}) /varset CureSpell${i} ${Spell[${CureSpell${i}}].RankName}
		/next i
		}
	/if (${SelfBuffTotal}) {
		/if (!${Defined[SelfBuffID]})      /declare SelfBuffID[${SelfBuffTotal}]      int    outer
		/if (!${Defined[SelfBuffTimer]})   /declare SelfBuffTimer                     timer  outer
		/call LoadVar SelfBuffStuff SelfBuffs FALSE SelfBuffs "${MyIni}" ${Function} bool
		/call LoadVar SelfBuffStuff ReportSelfBuffs FALSE ReportSelfBuffs "${MyIni}" ${Function} bool
		/call LoadVar SelfBuffStuff SelfBuffRecheck 10s SelfBuffRecheck "${MyIni}" ${Function} string
		/for i 1 to ${SelfBuffTotal}
			/call LoadVar SelfBuffStuff SelfBuff${i} "Self Buff Item/Spell #${i}" SelfBuff${i} "${MyIni}" ${Function} string
			/call LoadVar SelfBuffStuff SelfBuffGem${i} "Self Buff #${i} Gem, or put ITEM if an item, or COMB if it is a disc, or put ALT if it is an AA" SelfBuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar SelfBuffStuff SelfBuffCount${i} 30 SelfBuffCount${i} "${MyIni}" ${Function} int
			/call LoadVar SelfBuffStuff SelfBuffAura${i} FALSE SelfBuffAura${i} "${MyIni}" ${Function} bool
			/call LoadVar SelfBuffStuff SelfBuffIcon${i} NOTFOUND SelfBuffIcon${i} "${MyIni}" ${Function} string
			/if (${SelfBuffGem${i}.Equal[ALT]} && ${Me.AltAbility[${SelfBuff${i}}]}) /varset SelfBuffID[${i}] ${Me.AltAbility[${SelfBuff${i}}]}
			/if (${SelfBuffGem${i}.Equal[ITEM]} && ${FindItem[${SelfBuff${i}}].ID}) /varset SelfBuffID[${i}] ${FindItem[${SelfBuff${i}}].ID}
			/if (${SelfBuffGem${i}.NotEqual[ALT]}  && ${SelfBuffGem${i}.NotEqual[item]} && ${SelfBuffGem${i}.NotEqual[comb]} && ${Spell[${SelfBuff${i}}].RankName.ID} && !${SelfBuffAura${i}}) {
				/varset SelfBuff${i} ${Spell[${SelfBuff${i}}].RankName}
				/varset SelfBuffID[${i}] ${Spell[${SelfBuff${i}}].RankName.ID}
				/varset SelfBuffIcon${i} ${Spell[${SelfBuffIcon${i}}].RankName}
				}
			/if (${SelfBuffGem${i}.Equal[COMB]} && ${Me.CombatAbility[${SelfBuff${i}}]}) /varset SelfBuffID[${i}] ${Spell[${SelfBuff${i}}].ID}
|			/if (!${SelfBuffAura${i}}) {
|				/if (${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset SelfBuffID[${i}] ${Spell[${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND]}].ID}
|			}
			/if (${SelfBuffAura${i}} && ${Ini[${RDIni},SelfBuffStuff,SelfBuffIcon${i},NOTFOUND].Equal[NOTFOUND]}) /varset SelfBuffIcon${i} ${SelfBuff${i}}
		/next i
		}
	/if (${DoBuffTotal}) {
		/if (!${Defined[RezBuff]}) 		  /declare RezBuff[${DoBuffTotal}]  int   outer	
		/if (!${Defined[DoBuffID]})       /declare DoBuffID[${DoBuffTotal}] int   outer
		/call LoadVar DoBuffStuff DoBuffs FALSE DoBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff ReportDoBuffs FALSE ReportDoBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff DoBuffTells FALSE DoBuffTells "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff RefreshBuffs FALSE RefreshBuffs "${MyIni}" ${Function} bool
		/call LoadVar DoBuffStuff DoBuffMana 0 DoBuffMana "${MyIni}" ${Function} int
		/for i 1 to ${DoBuffTotal}
			/call LoadVar DoBuffStuff DoBuff${i} "Do Buff Item/Spell #${i}" DoBuff${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffGem${i} "Do Buff #${i} Gem or put Item if an item" DoBuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffMana${i} 0 DoBuffMana${i} "${MyIni}" ${Function} int
			/call LoadVar DoBuffStuff DoBuffAliases${i} "Put the keywords you want to respond to for this buff" DoBuffAliases${i} "${MyIni}" ${Function} string
			/call LoadVar DoBuffStuff DoBuffRefresh${i} FALSE DoBuffRefresh${i} "${MyIni}" ${Function} bool
			/call LoadVar DoBuffStuff BattleBuff${i} 0 BattleBuff${i} "${MyIni}" ${Function} int
			/call LoadVar DoBuffStuff RezBuff${i} FALSE RezBuff${i} "${MyIni}" ${Function} bool
			/if (${DoBuffGem${i}.Equal[alt]} && ${Me.AltAbility[${DoBuff${i}}].Spell.ID}) /varset DoBuffID[${i}] ${Me.AltAbility[${DoBuff${i}}].Spell.ID}
			/if (${DoBuffGem${i}.Equal[ITEM]} && ${FindItem[${DoBuff${i}}].ID}) /varset DoBuffID[${i}] ${FindItem[${DoBuff${i}}].ID}
			/if (${DoBuffGem${i}.NotEqual[alt]} && ${DoBuffGem${i}.NotEqual[item]} && ${Spell[${DoBuff${i}}].RankName.ID}) {
				/varset DoBuff${i} ${Spell[${DoBuff${i}}].RankName}
				/varset DoBuffID[${i}] ${Spell[${DoBuff${i}}].RankName.ID}
				}
|			/if (${Ini[${RDIni},DoBuffStuff,DoBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset DoBuffID[${i}] ${Spell[${Ini[${RDIni},DoBuffStuff,DoBuffIcon${i},NOTFOUND]}].ID}
			/if (${BattleBuff${i}} && !${Defined[BattleBuffFlag]}) /declare BattleBuffFlag bool outer TRUE
			/if (${DoBuffLowest}>${DoBuffMana${i}}) /varset DoBuffLowest ${DoBuffMana${i}}
		/next i
		}
	/if (${DebuffTotal}) {
		/if (!${Defined[DebuffID]})       /declare DebuffID[${DebuffTotal}] int  outer
		/if (!${Defined[LastSpawnCount]}) /declare LastSpawnCount           int  outer
		/if (!${Defined[VarNPCCount]})    /declare VarNPCCount              int  outer
		/if (!${Defined[VarOldNPCCount]}) /declare VarOldNPCCount           int  outer
		/if (!${Defined[DebuffLowest]})   /declare DebuffLowest             int  outer 100
		/if (!${Defined[MADebuffed]})     /declare MADebuffed               bool outer
		/if (!${Defined[MADebuffOnly]})   /declare MADebuffOnly             bool outer TRUE
		/if (!${Defined[ProcessResist]})  /declare ProcessResist            bool outer TRUE
		/if (!${Defined[DoCharm]}) /declare DoCharm bool outer FALSE
		/if (!${Defined[DoDebuffs]}) /declare DoDebuffs bool outer FALSE
		/call LoadVar DebuffStuff DoDebuffs FALSE DoDebuffs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoDoTs FALSE DoDoTs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoMez FALSE DoMez "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoCharm FALSE DoCharm "${MyIni}" ${Function} bool
		/if (${Select[${Me.Class.ShortName},ENC,NEC,SHD]}) /call LoadVar DebuffStuff DoManaTaps FALSE DoManaTaps "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportDebuffs FALSE ReportDebuffs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportDoTs FALSE ReportDoTs "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff ReportMez FALSE ReportMez "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffChannel echo DebuffChannel "${MyIni}" ${Function} string
		/call LoadVar DebuffStuff UseHoTT FALSE UseHoTT "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff MaxMobs 5 MaxMobs "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff AllDebuffsFirst TRUE AllDebuffsFirst "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffMAFirst TRUE DebuffMAFirst "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DebuffGreens FALSE DebuffGreens "${MyIni}" ${Function} bool
		/call LoadVar DebuffStuff DoTDurFocus 26 DoTDurFocus "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff DoTDurAASecs 0 DoTDurAASecs "${MyIni}" ${Function} int
		/call LoadVar DebuffStuff MezDurAASecs 0 MezDurAASecs "${MyIni}" ${Function} int
		/for i 1 to ${DebuffTotal}
			/call LoadVar DebuffStuff DebuffSpell${i} "Debuff Item/Spell #${i}" DebuffSpell${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff DebuffGem${i} "Debuff #${i} Spell Gem or put Item if an item" DebuffGem${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff DebuffMana${i} 0 DebuffMana${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffHPs${i} 100 DebuffHPs${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffStopHPs${i} 0 DebuffStopHPs${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffRecast${i} 0 DebuffRecast${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffSpellSet${i} 0 DebuffSpellSet${i} "${MyIni}" ${Function} int
			/call LoadVar DebuffStuff DebuffMAOnly${i} TRUE DebuffMAOnly${i} "${MyIni}" ${Function} bool
			/call LoadVar DebuffStuff DebuffCondition${i} TRUE DebuffCondition${i} "${MyIni}" ${Function} string
			/if (!${DebuffMAOnly${i}}) /varset MADebuffOnly ${DebuffMAOnly${i}}
			/call LoadVar DebuffStuff DebuffNamedOnly${i} FALSE DebuffNamedOnly${i} "${MyIni}" ${Function} bool
			/call LoadVar DebuffStuff DebuffMessage${i} "%Target Debuffed by %Spell" DebuffMessage${i} "${MyIni}" ${Function} string
			/call LoadVar DebuffStuff SpellType${i} 0 SpellType${i} "${MyIni}" ${Function} int
			/if (${DebuffGem${i}.Equal[alt]} && ${Me.AltAbility[${DebuffSpell${i}}].Spell.ID}) /varset DebuffID[${i}] ${Me.AltAbility[${DebuffSpell${i}}].Spell.ID}
			/if (${DebuffGem${i}.Equal[item]} && ${FindItem[${DebuffSpell${i}}].ID}) /varset DebuffID[${i}] ${FindItem[${DebuffSpell${i}}].ID}
			/if (${DebuffGem${i}.NotEqual[alt]} && ${DebuffGem${i}.NotEqual[item]} && ${Spell[${DebuffSpell${i}}].RankName.ID}) {
				/varset DebuffSpell${i} ${Spell[${DebuffSpell${i}}].RankName}
				/varset DebuffID[${i}] ${Spell[${DebuffSpell${i}}].RankName.ID}
				}
			/if (${DebuffLowest}>${DebuffMana${i}}) /varset DebuffLowest ${DebuffMana${i}}
			/call LoadVar ImmuneList_${Zone.ShortName} ${DebuffID[${i}]}Immune | ${DebuffID[${i}]}Immune RDCommon.ini ${Function} string
		/next i
		/if (!${Defined[DebuffArray]}) /declare DebuffArray[${MaxMobs},${DebuffTotal}] int outer
		/if (!${Defined[MobList]})     /declare MobList[${MaxMobs}]                    int outer
		}
	/call LoadVar Settings AutoSit FALSE AutoSit "${MyIni}" ${Function} bool
	/call LoadVar Settings ASRadius 20 ASRaidus "${MyIni}" ${Function} int
	/call LoadVar Settings ASZRadius 50 AZRadius "${MyIni}" ${Function} int
	/call LoadVar Settings SitDelay 3s SitDelay "${MyIni}" ${Function} string
	/call LoadVar Settings EndMedPct 80 EndMedPct "${MyIni}" ${Function} int

	/if (!${Select[${Me.Class.ShortName},MNK,WAR,BER,ROG]}) {
		/if (!${Defined[ReportFM]})   /declare ReportFM bool outer
		/call LoadVar DoBuffStuff BuffGem "Buff Gem you would like to cast /buff requests from" BuffGem "${MyIni}" ${Function} string
		/call LoadVar Settings MedPct 80 MedPct "${MyIni}" ${Function} int
		/call LoadVar Settings UseRods FALSE UseRods "${MyIni}" ${Function} bool
		/call LoadVar Settings RodMana 80 RodMana "${MyIni}" ${Function} int
		/call LoadVar GeneralStuff ReportMana FALSE ReportMana "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff ReportManaPct 50 ReportManaPct "${MyIni}" ${Function} int
		/call LoadVar GeneralStuff SpellSetTotal 1 SpellSetTotal "${MyIni}" ${Function} int
		/if (${SpellSetTotal}) {
			/for i 1 to ${SpellSetTotal}
				/call LoadVar GeneralStuff SpellSet${i} "Put the name of the Spell Set you want to memorize when you die while using this spell set here" SpellSet${i} "${MyIni}" ${Function} string
			/next i
		}
		/call LoadVar NukeStuff NukeTotal 1 NukeTotal "${MyIni}" ${Function} int
		/if (${NukeTotal}) {
			/if (!${Defined[NukeID]})     /declare NukeID[${NukeTotal}] int   outer
			/if (!${Defined[NukeLowest]}) /declare NukeLowest           int   outer 100
			/if (!${Defined[NukeTimer]})  /declare NukeTimer            timer outer
			/call LoadVar NukeStuff DoNukes FALSE DoNukes "${MyIni}" ${Function} bool
			/call LoadVar NukeStuff NukeDelay 0 NukeDelay "${MyIni}" ${Function} string
			/call LoadVar NukeStuff WhichNuke 1 WhichNuke "${MyIni}" ${Function} int
			/if (${Me.Class.ShortName.Equal[WIZ]}) {
				/call LoadVar NukeStuff DoMancy TRUE DoMancy "${MyIni}" ${Function} bool
				}
			/for i 1 to ${NukeTotal}
				/call LoadVar NukeStuff Nuke${i} "Put the name of nuke #${i} here" Nuke${i} "${MyIni}" ${Function} string
				/call LoadVar NukeStuff NukeGem${i} "Put the spell gem you want to cast nuke #${i} from here" NukeGem${i} "${MyIni}" ${Function} string
				/call LoadVar NukeStuff NukeSpellSet${i} 1 NukeSpellSet${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeStartHPs${i} 90 NukeStartHPs${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeStopHPs${i} 40 NukeStopHPs${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeMaxMana${i} 100 NukeMaxMana${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff NukeMinMana${i} 30 NukeMinMana${i} "${MyIni}" ${Function} int
				/call LoadVar NukeStuff GoMNuke${i} FALSE GoMNuke${i} "${MyIni}" ${Function} bool
				/call LoadVar NukeStuff NukeCondition${i} TRUE NukeCondition${i} "${MyIni}" ${Function} string
				/if (${NukeGem${i}.Equal[alt]} && ${Me.AltAbility[${Nuke${i}}].Spell.ID}) /varset NukeID[${i}] ${Me.AltAbility[${Nuke${i}}].Spell.ID}
				/if (${NukeGem${i}.Equal[ITEM]} && ${FindItem[${Nuke${i}}].ID}) /varset NukeID[${i}] ${FindItem[${Nuke${i}}].Spell.ID}
				/if (${NukeGem${i}.NotEqual[alt]} && ${NukeGem${i}.NotEqual[item]} && ${Spell[${Nuke${i}}].RankName.ID}) /varset Nuke${i} ${Spell[${Nuke${i}}].RankName}
				/if (${NukeGem${i}.NotEqual[alt]} && ${NukeGem${i}.NotEqual[item]} && ${Spell[${Nuke${i}}].RankName.ID}) /varset NukeID[${i}] ${Spell[${Nuke${i}}].RankName.ID}
				/if (${NukeMinMana${i}}<${NukeLowest}) /varset NukeLowest ${NukeMinMana${i}}
			/next i
			}
		}
	/if (${Me.Class.ShortName.Equal[MAG]}) {
		/call LoadVar SummonStuff RodSpell "Put the Name of the spell or item you use to cast mod rods here" RodSpell "${MyIni}" ${Function} string
		/call LoadVar SummonStuff RodGem "Put the spell gem number or put item if its an item you want to cast mod rods from here" RodGem "${MyIni}" ${Function} string
		/call LoadVar SummonStuff DoPetToys FALSE DoPetToys "${MyIni}" ${Function} bool
		/call LoadVar SummonStuff ReportPetToys FALSE ReportPetToys "${MyIni}" ${Function} bool
		/call LoadVar SummonStuff PetToysChannel echo PetToysChannel "${MyIni}" ${Function} string
		/call LoadVar SummonStuff PetToysTotal 1 PetToysTotal "${MyIni}" ${Function} int
		/if (${PetToysTotal}) {
			/for i 1 to ${PetToysTotal}
			/call LoadVar SummonStuff PetToys${i} "PetToys Summon spell here|With Individual items here (omit for give all)" PetToys${i} "${MyIni}" ${Function} string
			/next i
|			/call LoadVar SummonStuff PetToysGave "PetToysGiven" PetToysGave "${MyIni} ${Function} string
			}
		/if (!${Defined[PetToysGave]}) /declare PetToysGave string outer PetToysGiven
		}
	/if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,BST]}) {
		/call LoadVar HealStuff DoSotW FALSE DoSotW "${MyIni}" ${Function} bool
		/call LoadVar HealStuff ReportSotW FALSE ReportSotW "${MyIni}" ${Function} bool
		/call LoadVar HealStuff SotWAA "Put the name of your AE Healing AA here" SotWAA "${MyIni}" ${Function} string
		/call LoadVar HealStuff SotWPct 75 SotWPct "${MyIni}" ${Function} int
		/call LoadVar HealStuff QM FALSE QM "${MyIni}" ${Function} bool
		}
	/if (${Select[${Me.Class.ShortName},WIZ,SHM,NEC,MAG,ENC,CLR,BST]}) {
		/call LoadVar GeneralStuff CanniTotal 1 CanniTotal "${MyIni}" ${Function} int
		/if (${CanniTotal}<1) /varset CanniTotal 1
		/if (${CanniTotal}) {
			/call LoadVar GeneralStuff DoCanni FALSE DoCanni "${MyIni}" ${Function} bool
			/for i 1 to ${CanniTotal}
				/call LoadVar GeneralStuff CanniSpell${i} "Put the name of your Cannibalization Spell or Item here" CanniSpell${i} "${MyIni}" ${Function} string
				/call LoadVar GeneralStuff CanniGem${i} "Put the Gem you want to cast your Cannibalization Spell from here, or put item if its an item, or alt if it's an AA" CanniGem${i} "${MyIni}" ${Function} string
				/call LoadVar GeneralStuff CanniHPs${i} 0 CanniHPs${i} "${MyIni}" ${Function} int
				/call LoadVar GeneralStuff CanniMana${i} 70 CanniMana${i} "${MyIni}" ${Function} int
			/next i
			/call LoadVar GeneralStuff DoCanniHeal "Heal after using Canni?" CanniHeal "${MyIni}" ${Function} bool
			/call LoadVar GeneralStuff CanniHealSpell "Put the name of your Cannibalization Heal Spell or Item here" CanniHealSpell "${MyIni}" ${Function} string
			/call LoadVar GeneralStuff CanniHealGem "Put the Spell Gem you want to cast your Cannibalization Heal Spell from here, or put item if its an item, or alt if it's an AA" CanniHealGem "${MyIni}" ${Function} string
			/call LoadVar GeneralStuff CanniHealHPs 60 CanniHealHPs "${MyIni}" ${Function} int
			}
		}
	/if (${Me.Class.ShortName.Equal[DRU]}) {
		/call LoadVar GeneralStuff DoWoW FALSE DoWoW "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff ReportWoW FALSE ReportWoW "${MyIni}" ${Function} bool
		}
	/if (${Select[${Me.Class.ShortName},CLR,PAL]}) {
		/call LoadVar GeneralStuff DoYaulp FALSE DoYaulp "${MyIni}" ${Function} bool
		/call LoadVar GeneralStuff YaulpSpell "Put the name of your Yaulp Spell here" YaulpSpell "${MyIni}" ${Function} string
		/call LoadVar GeneralStuff YaulpGem "Put the Spell Gem you want to cast your Yaulp Spell from here" YaulpGem "${MyIni}" ${Function} string
		}
	/if (${Select[${Me.Class.ShortName},CLR,SHM]}) {
		/call LoadVar HealStuff UseDivArb FALSE UseDivArb "${MyIni}" ${Function} bool
		/call LoadVar HealStuff DivArbHPs 20 DivArbHPs "${MyIni}" ${Function} int
		/call LoadVar HealStuff UseTankHoT FALSE UseTankHoT "${MyIni}" ${Function} bool
		/call LoadVar HealStuff HotSpell "Put the name of your Heal over Time Spell here" HotSpell "${MyIni}" ${Function} string
		/call LoadVar HealStuff HotSpellGem "Put the Spell Gem you want to cast your Heal over Time Spell from here" HotSpellGem "${MyIni}" ${Function} string
		/varset HotSpell ${Spell[${HotSpell}].RankName}
		/if (!${Defined[HotSpellID]})  /declare HotSpellID int outer ${Spell[${HotSpell}].RankName.ID}
		/if (!${Defined[HotGem]}) /declare HotGem string outer ${HotSpellGem}
		}
	/if (${Me.Class.ShortName.Equal[CLR]}) {
		/call LoadVar HealStuff DoRetort 		FALSE 							DoRetort 		"${MyIni}" ${Function} bool
		/call LoadVar HealStuff RetortSpell 	"Retort Spell here" 			RetortSpell 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff RetortSpellGem 	"Spell Gem for Retort Spell" 	RetortSpellGem 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbSpell 	"Divine Arbitration" 			DivArbSpell 	"${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbGem 		alt 							DivArbGem 		"${MyIni}" ${Function} string
		/call LoadVar HealStuff DoWard 			FALSE 							DoWard 			"${MyIni}" ${Function} bool		
		/call LoadVar HealStuff WardSpell 		"Ward Spell here" 				WardSpell 		"${MyIni}" ${Function} string
		/call LoadVar HealStuff WardSpellGem 	"Spell Gem for Ward Spell" 		WardSpellGem 	"${MyIni}" ${Function} string
		/if (!${Defined[RetortSpell]}) 		/declare RetortSpell 	string 	outer Erud's Retort
		/if (!${Defined[RetortSpellGem]})	/declare RetortSpellGem string 	outer Gem8
		/if (!${Defined[RetortTimer]}) 		/declare RetortTimer 	timer 	outer 0
		/if (!${Defined[DivArbSpell]}) 		/declare DivArbSpell 	string 	outer Divine Arbitration
		/if (!${Defined[DivArbGem]}) 		/declare DivArbGem		string 	outer ALT
		/if (!${Defined[DoWard]}) 			/declare DoWard 		bool 	outer FALSE
		/if (!${Defined[WardSpell]}) 		/declare WardSpell 		string 	outer "Ward of Certitude"
		/if (!${Defined[WardSpellGem]}) 	/declare WardSpellGem 	string 	outer Gem12
		/if (!${Defined[DivineArbTimer]}) 	/declare DivArbTimer 	timer 	outer 0
		/if (!${Defined[DivArbSpellID]}) 	/declare DivArbSpellID 	int		outer ${Me.Book[${Me.Book[${Spell[${DivArbSpell}].RankName}]}].ID}
		}
	/if (${Me.Class.ShortName.Equal[SHM]}) {
		/call LoadVar HealStuff DivArbSpell "Put the name of your divine arbitration spell or item" DivArbSpell "${MyIni}" ${Function} string
		/call LoadVar HealStuff DivArbGem "Put the Spell Gem you want to cast your Pet Spell from here" DivArbGem "${MyIni}" ${Function} string
		/if (!${Defined[DivArbTimer]})   /declare DivArbTimer timer  outer
		/if (!${Defined[DivArbSpellID]})  /declare DivArbSpellID int outer ${Me.Book[${Me.Book[${Spell[${DivArbSpell}].RankName}]}].ID}
		}
	/if (${Me.Class.ShortName.Equal[CLR]}) /call LoadVar HealStuff UseBDA FALSE UseBDA "${MyIni}" ${Function} bool
	/if (${Me.Class.ShortName.Equal[ENC]}) /call LoadVar Settings GatherPct 10 GatherPct "${MyIni}" ${Function} int

	/if (${Select[${Me.Class.ShortName},DRU,SHM,BST,BRD,ENC,MAG,NEC,SHD,WIZ]}) {
		/call LoadVar PetStuff UsePet FALSE UsePet "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetAttack FALSE PetAttack "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetMana 0 PetMana "${MyIni}" ${Function} int
		/call LoadVar PetStuff KillFlappy FALSE KillFlappy "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetFocus "Put the name of your pet focus buff item here" PetFocus "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetSpell "Put the name of your pet Spell here" PetSpell "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetGem "Put the Spell Gem you want to cast your Pet Spell from here" PetGem "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetShrink FALSE PetShrink "${MyIni}" ${Function} bool
		/call LoadVar PetStuff PetShrinkSpell "Put the name of your pet shrinking AA/Item/Spell here" PetShrinkSpell "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetShrinkGem "Put gem# for spells, item for items, and alt for AAs" PetShrinkGem "${MyIni}" ${Function} string
		/call LoadVar PetStuff PetBuffTotal 1 PetBuffTotal "${MyIni}" ${Function} int
		/if (!${Defined[PetBuffTotal]}) /declare PetBuffTotal ${Ini[RD1_${Me.CleanName},PetStuff,PetBuffTotal]}
		/if (${Me.Class.ShortName.Equal[MAG]}) {
			/call LoadVar PetStuff SelfPetHealing FALSE SelfPetHealing "${MyIni}" ${Function} bool
			/call LoadVar PetStuff SelfPetHealPct 50 SelfPetHealPct "${MyIni}" ${Function} int
			/call LoadVar PetStuff SelfPetHeal "pet heal spell here" SelfPetHeal "${MyIni}" ${Function} string
			/call LoadVar PetStuff SelfPetHealGem "pet heal spell gem here" SelfPetHealGem "${MyIni}" ${Function} string
			}
		/if (${Me.Class.ShortName.Equal[MAG]}) {
			/call LoadVar PetStuff PetDelayedHealing FALSE PetDelayedHealing "${MyIni}" ${Function} bool
			/call LoadVar PetStuff PetDelayedHealPct 50 PetDelayedHealPct "${MyIni}" ${Function} int
			/call LoadVar PetStuff PetDelayedHeal "pet delayed heal spell here" PetDelayedHeal "${MyIni}" ${Function} string
			/call LoadVar PetStuff PetDelayedHealGem "pet delayed heal gem here" PetDelayedHealGem "${MyIni}" ${Function} string
			}
		/if (${PetBuffTotal}) {
			/if (!${Defined[PetBuffID]})      /declare PetBuffID[${PetBuffTotal}]      int    outer
			/if (!${Defined[PetBuffTimer]})   /declare PetBuffTimer                    timer  outer
			/call LoadVar PetStuff DoPetBuffs FALSE DoPetBuffs "${MyIni}" ${Function} bool
			/call LoadVar PetStuff ReportPetBuffs FALSE ReportPetBuffs ${MyIni} ${Function} bool
			/call LoadVar PetStuff PetBuffRecheck 10s PetBuffRecheck ${MyIni} ${Function} string
			/for i 1 to ${PetBuffTotal}
				/call LoadVar PetStuff PetBuff${i} "pet Buff Item/Spell #${i}" PetBuff${i} ${MyIni} ${Function} string
				/call LoadVar PetStuff PetBuffGem${i} "pet Buff #${i} Gem or put Item if an item" PetBuffGem${i} ${MyIni} ${Function} string
				/call LoadVar PetStuff PetBuffIcon${i} "pet Buff Icon as shown in the pet buff window" PetBuffIcon${i} ${MyIni} ${Function} string
				/if (${PetBuffGem${i}.Equal[alt]} && ${Me.AltAbility[${PetBuff${i}}].Spell.ID}) /varset PetBuffID[${i}] ${Me.AltAbility[${PetBuff${i}}].Spell.ID}
				/if (${PetBuffGem${i}.Equal[iteCm]} && ${FindItem[${PetBuff${i}}].ID}) /varset PetBuffID[${i}] ${FindItem[${PetBuff${i}}].ID}
				/if (${PetBuffGem${i}.NotEqual[item]} && ${PetBuffGem${i}.NotEqual[alt]} && ${Spell[${PetBuff${i}}].RankName.ID}) {
					/varset PetBuff${i} ${Spell[${PetBuff${i}}].RankName}
					/varset PetBuffID[${i}] ${Spell[${PetBuff${i}}].RankName.ID}
					}
|				/if (${Ini[${RDIni},PetStuff,PetBuffIcon${i},NOTFOUND].NotEqual[NOTFOUND]}) /varset PetBuffID[${i}] ${Spell[${Ini[${RDIni},PetStuff,PetBuffIcon${i},NOTFOUND]}].ID}
			/next i
			}			
		}	
	/if (${Select[${Me.Class.ShortName},WIZ,ENC]}) {
		/call LoadVar NukeStuff DoConcussion FALSE DoConcussion ${MyIni} ${Function} bool
		/call LoadVar NukeStuff ConcussionSpell "Concussion Item/Spell" ConcussionSpell ${MyIni} ${Function} string
		/call LoadVar NukeStuff ConcussionGem "Concussion gem# or put item if an item" ConcussionGem ${MyIni} ${Function} string
		}
	/call LoadVar HolyShit TotalShit 1 TotalShit "${MyIni}" ${Function} int
	/if (${TotalShit}) {
		/call LoadVar HolyShit DoHolyShit FALSE DoHolyShit "${MyIni}" ${Function} bool
		/for i 1 to ${TotalShit}
			/call LoadVar HolyShit HolyShit${i} "Name of Item/AA/Spell to cast." HolyShit${i} "${MyIni}" ${Function} string
			/call LoadVar HolyShit HolyShitGem${i} "HolyShit Gem# or aa" HolyShitGem${i} "${MyIni}" ${Function} string
			/call LoadVar HolyShit HolyShitHp${i} 90 HolyShitHp${i} "${MyIni}" ${Function} int
			/call LoadVar HolyShit HolyShitType${i} 0 HolyShitType${i} "${MyIni}" ${Function} int
			/call LoadVar HolyShit HolyShitRUN${i} FALSE HolyShitRUN${i} "${MyIni}" ${Function} bool
		/next i
	}
	/if (${Me.Class.ShortName.Equal[BRD]}) {
		/call LoadVar Bard DoRally FALSE DoRally "${MyIni}" ${Function} bool		
		/call LoadVar Bard DoDichotomic FALSE DoDichotomic "${MyIni}" ${Function} bool
		/call LoadVar Bard DoBardSwap FALSE DoBardSwap "${MyIni}" ${Function} bool
		/call LoadVar Bard DoBardMeleeSwap FALSE DoBardMeleeSwap "${MyIni}" ${Function} bool
		/call LoadVar Bard AutoRestOff FALSE AutoRestOff "${MyIni}" ${Function} bool
		/call LoadVar Bard AutoRestRadius 125 AutoRestRadius "${MyIni}" ${Function} int
		/call LoadVar Bard RestTwist "RestGems" RestTwist "${MyIni}" ${Function} string outer
		/call LoadVar Bard CombatTwist "CombatGems" CombatTwist "${MyIni}" ${Function} string outer 
		/for i 1 to ${MaxGems}
			/call LoadVar Bard-Combat SongsArray${i} "Song Name" SongsArray${i} "${MyIni}" ${Function} string outer Song Name
		/next i
		/for i ${Math.Calc[${MaxGems}+1]} to ${Math.Calc[${MaxGems}*2]}
			/call LoadVar Bard-Rest  SongsArray${i} "Song Name" SongsArray${i} "${MyIni}" ${Function} string outer Song Name
		/next i
		/if ((${BardSwap.Swapping} && !${DoBardSwap} && ${Bool[${Plugin[mq2bardswap]}]}) || (!${BardSwap.Swapping} && ${DoBardSwap} && ${Bool[${Plugin[mq2bardswap]}]})) /bardswap
		/if ((${BardSwap.MeleeSwap} && !${DoBardMeleeSwap} && ${Bool[${Plugin[mq2bardswap]}]}) || !${BardSwap.MeleeSwap} && ${DoBardMeleeSwap} && ${Bool[${Plugin[mq2bardswap]}]}) /bardswap melee
		/call CheckMaxSongs
		/call GetFreeGems
		/call MemSongs
	}
	/if (${Me.Class.ShortName.Equal[WAR]}) {
		/if (!${Defined[ShieldTimer]}) /declare ShieldTimer timer outer
		/call LoadVar MeleeStuff DoShield FALSE DoShield ${MyIni} ${Function} bool
		/call LoadVar MeleeStuff ShieldRange 25 ShieldRange ${MyIni} ${Function} int
		/call LoadVar MeleeStuff ShieldHPs 50 ShieldHPs ${MyIni} ${Function} int
		/call LoadVar MeleeStuff ShieldClasses |CLR|DRU|SHM|ENC| ShieldClasses ${MyIni} ${Function} string
	}
	/return